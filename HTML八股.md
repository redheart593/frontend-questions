# HTML八股

## 1、sre与href的区别

### **（1） `src`（Source）**

- **用途**：用于**嵌入资源**到当前文档中，表示资源是当前文档的组成部分。
- **行为**：浏览器会**下载并执行/显示**该资源，这个过程是**同步**过程，可能会**阻塞**页面解析（如 `<script>`），所以例如<script>嵌入js脚本，一般放在最后，防止阻塞html结构和css样式的加载。
- **常见场景**：
  - `<script src="app.js">`：嵌入 JavaScript 脚本。
  - `<img src="image.jpg">`：嵌入图片。
  - `<iframe src="page.html">`：嵌入另一个页面。
  - `<video src="video.mp4">`：嵌入视频。

#### **关键特性**：

- 资源会**直接替换当前标签的内容**。
- 如果资源加载失败，可能会影响页面功能或显示（如缺失图片）。

------

### **（2）`href`（Hypertext Reference）**

- **用途**：用于**关联外部资源**，建立当前文档与资源之间的**链接关系**。
- **行为**：浏览器会**异步加载**资源，通常不会阻塞页面解析（CSS 例外）。
- **常见场景**：
  - `<link href="styles.css" rel="stylesheet">`：关联 CSS 样式表。
  - `<a href="https://example.com">`：定义超链接。
  - `<link href="icon.png" rel="icon">`：关联网站图标（Favicon）。

#### **关键特性**：

- 资源与当前文档是**关联关系**，只是指向资源，不会直接嵌入到页面中。
- 加载失败可能不会直接影响页面结构（如 CSS 加载失败会导致样式丢失）。

------

### **核心区别总结**

| 属性   | 作用         | 加载行为                 | 典型用例            |
| :----- | :----------- | :----------------------- | :------------------ |
| `src`  | **嵌入资源** | 同步/阻塞（如 script）   | script, img, iframe |
| `href` | **关联资源** | 异步（CSS 可能阻塞渲染） | link, a, rel 属性   |

## 2、script标签中defer和async的区别

如果没有defer或async属性，浏览器会**立即加载并执行**相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就**阻塞**了后续文档的加载。

下图可以直观的看出三者之间的区别: ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a8a139519f46dfa2d1992c58eb5397~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。

**defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析**，其区别如下：

- **执行顺序：** 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；
- **脚本是否并行执行：\**async属性，表示\**后续文档的加载和执行与js脚本的加载和执行是并行进行的**，即异步执行；defer属性，加载后续文档的过程和js脚本的**加载(此时仅加载不执行)是并行进行的(异步)**，js脚本需要等到文档**所有元素解析完成之后才执行**

## 3、行级元素和块级元素分别有哪些及怎么转换？

常见的块级元素：`p、div、form、ul、li、ol、table、h1、h2、h3、h4、h5、h6、dl、dt、dd`

常见的行级元素：`span、a、img、button、input、select`

块级元素：

- 总是在新行上开始，就是每个块级元素独占一行，默认从上到下排列
- 宽度缺少时是它的容器的100%，除非设置一个宽度
- 高度、行高以及外边距和内边距都是可以设置的
- 块级元素可以容纳其它行级元素和块级元素

行内元素：

- 和其它元素都会在一行显示
- 无法直接通过width和height设置宽高
- 宽度就是文字或者图片的宽度，不能改变
- 行级元素只能容纳文本或者其它行内元素

- 设置`margin和padding`只有左右有效，上下无效

可以通过`display`属性对行内元素和块级元素进行切换(主要看第 `2、3、4`三个值)：

## 4、H5新增了多少内容

### **一、语义化新元素** 611

HTML5引入了多个语义化标签，替代传统`<div>`的滥用，增强代码可读性和SEO优化：

`<header>`（页眉）、`<footer>`（页脚）、`<nav>`（导航）、`<article>`（独立内容块）、`<section>`（文档分区）、`<aside>`（侧边栏）。

### **二、表单功能增强** 611

HTML5新增了多种输入类型和属性，简化表单开发并提升用户体验：

- **输入类型**：`email`、`url`、`number`、`range`（滑块）、`date`（日期选择）、`color`（颜色选择）等。相应的输入类型会限制输入，输入形式不符合就不合法
- **新增表单属性**：
  - `placeholder`（占位提示文本）、`autofocus`（自动聚焦）、`required`（必填项）。
  - `pattern`（正则验证）、`min/max`（数值范围限制）、`multiple`（多文件上传）。

### **三、多媒体支持** 711

原生支持音视频播放，无需依赖Flash等插件：

- **视频**：`<video>`标签支持`controls`（播放控件）、`autoplay`、`loop`等属性，兼容MP4、WebM、Ogg格式。
- **音频**：`<audio>`标签支持类似属性，兼容MP3、WAV、Ogg格式。

### 四、本地存储

localStorage`：持久化存储（上限约2.6MB~5MB），数据保留至手动清除。`

sessionStorage`：会话级存储，页面关闭后数据消失。

### 五、拖放

拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放

```html
<img draggable="true" />
```

### 六、canvas与SVG

画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。

```html
<canvas id="myCanvas" width="200" height="100"></canvas>
```

SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准

## 5. Canvas和SVG的区别

**（1）SVG：** SVG是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

其特点如下：

- 不依赖分辨率
- 支持事件处理器（由于每个元素都是DOM元素）
- 最适合带有大型渲染区域的应用程序（比如谷歌地图）
- 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）

**（2）Canvas：** Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。

其特点如下：

- 依赖分辨率，分辨率不同会导致图形变得不清晰
- 不支持事件处理器
- 弱的文本渲染能力
- 能够以 .png 或 .jpg 格式保存结果图像
- 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。

## 6、cookie、sessionStorage 和 localStorage 的区别

|                                                    | cookie                                               | localStorage | sessionStorage |
| -------------------------------------------------- | ---------------------------------------------------- | ------------ | -------------- |
| 由谁初始化                                         | 客户端或服务器，服务器可以使用 `Set-Cookie` 请求头。 | 客户端       | 客户端         |
| 过期时间                                           | 手动设置                                             | 永不过期     | 当前页面关闭时 |
| 在当前浏览器会话（browser sessions）中是否保持不变 | 取决于是否设置了过期时间                             | 是           | 否             |
| 是否随着每个 HTTP 请求发送给服务器                 | 是，Cookies 会通过 `Cookie` 请求头，自动发送给服务器 | 否           | 否             |
| 容量（每个域名）                                   | 4kb                                                  | 5MB          | 5MB            |
| 访问权限                                           | 任意窗口                                             | 任意窗口     | 当前页面窗口   |

### 共同点

- **客户端存储：**
  三者都属于浏览器端存储数据的方式，并且都受同源策略限制，只能在相同域名下访问。
- **键值对形式：**
  数据都是以键值对的形式存储，便于快速读取和修改。

------

### 主要区别

1. **数据传输方式**

   - **Cookie：**
     每次浏览器向服务器发起 HTTP 请求时，Cookie 都会自动附加在请求头中发送给服务器。

   - sessionStorage / localStorage：

     数据仅保存在客户端，不会自动参与 HTTP 请求，降低了不必要的数据传输。

2. **存储容量**

   - **Cookie：**
     单个 Cookie 数据量有限（约 4KB），适合存储少量数据，如会话标识或简单状态。

   - sessionStorage / localStorage：

     存储空间大得多（通常 5MB 甚至更多），适用于存储较大数据量。

3. **数据生命周期**

   - **Cookie：**
     生命周期由服务器设置的过期时间决定，可以是会话级（浏览器关闭后失效）或持久存储（在到期时间前一直有效）。

   - **sessionStorage：**
     数据仅在当前窗口或标签页的会话内有效，关闭后数据自动清除。

   - localStorage：

     数据持久存在，除非通过代码或用户手动清除，否则会一直保留。

4. **作用域/共享范围**

   - **Cookie & localStorage：**
     在同一源（同域、同协议、同端口）的所有窗口和标签页中共享。

   - sessionStorage：

     数据只在当前浏览器窗口或标签页内独立存在，不与其他窗口共享。

     **使用场景**

   - **Cookie：**
     适用于需要在客户端与服务器间频繁传递的数据，如身份验证、跟踪用户行为等。

   - **sessionStorage：**
     适合存储当前会话中的临时数据，如表单数据、页面状态等，不需要长久保存。

   - localStorage：

     适用于存储长期有效的数据，如用户设置、缓存数据等，数据持久性较好。

## 7、iframe的作用和优缺点

iframe 在嵌入外部内容、实现模块化和隔离安全环境方面具有明显优势，适用于广告、第三方服务、视频播放器等场景。但同时，它也存在 SEO、性能和跨文档通信等方面的限制。在使用时，需权衡实际需求与上述缺点，合理设计和优化页面结构。

### 作用与用途

- **嵌入外部内容：**
  iframe 可以加载并显示来自同源或跨域的网页，这在嵌入第三方内容（如广告、视频、地图等）时非常有用。
- **模块化页面：**
  通过 iframe 可以将页面拆分为多个独立模块，每个模块独立加载与渲染，便于维护和复用。
- **隔离环境：**
  iframe 内部的文档拥有独立的 DOM 和 JavaScript 执行环境，这能有效避免父页面与嵌入页面之间的样式和脚本冲突，同时也有助于安全隔离（配合 sandbox 属性可以进一步限制其行为）。

------

### 优点

- **环境隔离：**
  iframe 内的内容与父页面相互独立，能避免样式、脚本冲突，特别适合嵌入第三方内容。
- **独立加载：**
  嵌入的页面可以单独加载，不会阻塞父页面的主渲染流程，从而在一定程度上提升用户体验。
- **跨域嵌入：**
  在符合安全策略的前提下，iframe 可用来展示跨域内容，这对于一些需要集成外部服务的网站非常有帮助。
- **安全控制：**
  利用 sandbox 属性可以对 iframe 内的内容进行权限限制，增强安全性，防止不受信任的内容执行恶意脚本。

------

### 缺点

- **SEO 不友好：**
  搜索引擎对 iframe 内的内容索引不如父页面直接加载的内容全面，可能影响网站的搜索排名和可发现性。
- **性能影响：**
  如果页面中存在过多的 iframe，会增加额外的 HTTP 请求，影响加载速度和整体性能，尤其在移动设备上更为明显。
- **交互复杂：**
  父页面与 iframe 之间的通信（尤其跨域时）需要使用诸如 postMessage 之类的特殊机制，增加了开发复杂性。
- **样式与响应式设计难题：**
  由于 iframe 内部页面与父页面样式和布局独立，协调二者的响应式设计和统一的视觉风格可能较为困难。

## 8、meta viewport 是做什么用的，怎么写？

Viewport，适配移动端，可以控制视口的大小和比例：

- `<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">`

其中，content 参数有以下几种：

- width viewport ：宽度(数值/device-width)
- height viewport ：高度(数值/device-height)
- initial-scale ：初始缩放比例
- maximum-scale ：最大缩放比例
- minimum-scale ：最小缩放比例
- user-scalable ：是否允许用户缩放(yes/no）