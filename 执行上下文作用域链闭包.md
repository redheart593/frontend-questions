# 执行上下文/作用域链/闭包

### 1. 对闭包的理解

**闭包是指有权访问另一个函数作用域中变量的函数**，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

闭包有两个常用的用途；

- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
- 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

```javascript
javascript 代码解读复制代码function A() {
  let a = 1
  window.B = function () {
      console.log(a)
  }
}
A()
B() // 1
```

在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题

```javascript
javascript 代码解读复制代码for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

首先因为 `setTimeout` 是个异步函数，所以会先把循环全部执行完毕，这时候 `i` 就是 6 了，所以会输出一堆 6。解决办法有三种：

- 第一种是使用闭包的方式

```javascript
javascript

 代码解读
复制代码for (var i = 1; i <= 5; i++) {  ;(function(j) {    setTimeout(function timer() {      console.log(j)    }, j * 1000)  })(i)}
```

在上述代码中，首先使用了立即执行函数将 `i` 传入函数内部，这个时候值就被固定在了参数 `j` 上面不会改变，当下次执行 `timer` 这个闭包的时候，就可以使用外部函数的变量 `j`，从而达到目的。

- 第二种就是使用 `setTimeout` 的第三个参数，这个参数会被当成 `timer` 函数的参数传入。

```javascript
javascript 代码解读复制代码for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j)
    },
    i * 1000,
    i
  )
}
```

- 第三种就是使用 `let` 定义 `i` 了来解决问题了，这个也是最为推荐的方式

```javascript
javascript 代码解读复制代码for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

### 2. 对作用域、作用域链的理解

##### 1）全局作用域和函数作用域

（1）全局作用域

- 最外层函数和最外层函数外面定义的变量拥有全局作用域
- 所有未定义直接赋值的变量自动声明为全局作用域
- 所有window对象的属性拥有全局作用域
- 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。

（2）函数作用域

- 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到
- 作用域是分层的，内层作用域可以访问外层作用域，反之不行

##### 2）块级作用域

- 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）
- let和const声明的变量不会有变量提升，也不可以重复声明
- 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。

**作用域链：** 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。

### 3. 对执行上下文的理解

##### 1. 执行上下文类型

**（1）全局执行上下文**

任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。

**（2）函数执行上下文**

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。

**（3）**`eval`**函数执行上下文**

执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。

##### 2. 执行上下文栈

- JavaScript引擎使用执行上下文栈来管理执行上下文
- 当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

```javascript
javascript 代码解读复制代码let a = 'Hello World!';
function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}
function second() {
  console.log('Inside second function');
}
first();
//执行顺序
//先执行second(),在执行first()
```

##### 3. 创建执行上下文

创建执行上下文有两个阶段：**创建阶段**和**执行阶段**

**1）创建阶段**

（1）this绑定

- 在全局执行上下文中，this指向全局对象（window对象）
- 在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined

（2）创建词法环境组件

###### 一、词法环境（Lexical Environment）

1. **定义**

- **词法环境**是执行上下文中用于管理以下内容的组件：
  - 通过 `let`/`const` 声明的变量。
  - 块级作用域（如 `{}`、`if`、`for` 等）。
- ES6 引入的 `let`/`const` 需要通过词法环境实现块级作用域和暂时性死区（TDZ）。

2. **特点**

- **暂时性死区（TDZ）**：在变量声明前访问会报错。
- **块级作用域**：`let`/`const` 声明的变量仅在块内有效。
- **词法嵌套结构**：词法环境通过外部引用（Outer Reference）形成作用域链。

3. **示例**

```js
console.log(c); // ReferenceError: Cannot access 'c' before initialization（暂时性死区）
let c = 30;

// 块级作用域
if (true) {
  let d = 40;
  const e = 50;
}
console.log(d); // ReferenceError: d is not defined
console.log(e); // ReferenceError: e is not defined
```

（3）创建变量环境组件

###### 二、变量环境（Variable Environment）

1. **定义**

- **变量环境**是执行上下文中专门用于存储以下内容的组件：
  - 通过 `var` 声明的变量。
  - 函数声明（Function Declaration）。
- 在 ES6 之前，变量环境和词法环境是同一个概念。ES6 之后，为了支持 `let`/`const` 和块级作用域，两者被分离。

2. **特点**

- **变量提升（Hoisting）**：`var` 变量和函数声明在代码执行前被初始化。
  - `var` 变量初始化为 `undefined`。
  - 函数声明直接可用。
- **函数级作用域**：`var` 声明的变量仅受函数作用域限制，没有块级作用域。

3. **示例**

```js
console.log(a); // undefined（变量提升）
var a = 10;

function foo() {
  console.log("Function Declaration");
}
foo(); // "Function Declaration"

// var 没有块级作用域
if (true) {
  var b = 20;
}
console.log(b); // 20（块内的 var 会泄漏到外部）
```



###### 三、变量环境 vs. 词法环境

| 特性         | 变量环境（Variable Environment） | 词法环境（Lexical Environment）        |
| :----------- | :------------------------------- | :------------------------------------- |
| **存储内容** | `var` 变量、函数声明             | `let`/`const` 变量、块级作用域         |
| **作用域**   | 函数级作用域                     | 块级作用域                             |
| **变量提升** | 支持（初始化为 `undefined`）     | 不支持（存在暂时性死区）               |
| **设计目的** | 兼容 ES5 的 `var` 和函数声明     | 支持 ES6 的 `let`/`const` 和块级作用域 |

- **2）执行阶段** 此阶段会完成对变量的分配，最后执行完代码。

