[toc]

### JS数据结构与算法

​			作者：kerwin

​			版本：QF1.0

​			版权：千锋HTML5大前端教研院

​			公众号: 大前端私房菜



#### 一. 初识数据结构与算法

> - “数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。”——Sartaj Sahni，《数据结构、算法与应用》
> - “数据结构是ADT（抽象数据类型 Abstract DataType）的物理实现。”—— Clifford A.Shaffer，《数据结构与算法分析》
> - “数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。”
>   ——中文维基百科



##### 1. 常见的数据结构

- 数组（Aarray）
- 栈（Stack）
- 链表（Linked List）
- 图（Graph）
- 散列表（Hash）
- 队列（Queue）
- 堆（Heap）
- 树（Tree）

##### 2. 算法

算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间，空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。

![](%E7%AC%94%E8%AE%B0.assets/%E5%A0%86%E6%8E%92%E5%BA%8F.gif)

![快速](%E7%AC%94%E8%AE%B0.assets/%E5%BF%AB%E9%80%9F.gif)



#### 二. 数组结构

- 什么是数组？

- 字面理解就是 **数字的组合**

- 其实不太准确，准确的来说数组是一个 **数据的集合**

- 也就是我们把一些数据放在一个盒子里面，按照顺序排好

  ```javascript
  [1, 2, 3, 'hello', true, false]
  ```

- 这个东西就是一个数组，存储着一些数据的集合



**数据类型分类**

- `number` / `string` / `boolean` / `undefined` / `null` / `object` / `function`  /  `array` / ...
- 数组也是数据类型中的一种
- 我们简单的把所有数据类型分为两个大类 **基本数据类型** 和 **复杂数据类型**

- 基本数据类型： `number` / `string` / `boolean` / `undefined` / `null` 
- 复杂数据类型： `object` / `function`  /  `array` / ...



###### 1 创建一个数组

- 数组就是一个 `[]`
- 在 `[]` 里面存储着各种各样的数据，按照顺序依次排好



**字面量创建一个数组**

- 直接使用 `[]` 的方式创建一个数组

  ```javascript
  // 创建一个空数组
  var arr1 = []
  
  // 创建一个有内容的数组
  var arr2 = [1, 2, 3]
  ```



**内置构造函数创建数组**

- 使用 `js` 的内置构造函数 `Array` 创建一个数组

  ```javascript
  // 创建一个空数组
  var arr1 = new Array()
  
  // 创建一个长度为 10 的数组
  var arr2 = new Array(10)
  
  // 创建一个有内容的数组
  var arr3 = new Array(1, 2, 3)
  ```

  

###### 2 数组的 length

- `length`:  长度的意思

- `length` 就是表示数组的长度，数组里面有多少个成员，`length` 就是多少

  ```javascript
  // 创建一个数组
  var arr = [1, 2, 3]
  
  console.log(arr.length) // 3
  ```



###### 3 数组的索引

- 索引，也叫做下标，是指一个数据在数组里面排在第几个的位置

- 注意： **在所有的语言里面，索引都是从 0 开始的**

- 在 `js` 里面也一样，数组的索引从 0 开始

  ```javascript
  // 创建一个数组
  var arr = ['hello', 'world']
  ```

- 上面这个数组中，**第 0 个** 数据就是字符串 `hello`，**第 1 个** 数据就是字符串 `world`

- 想获取数组中的第几个就使用 `数组[索引]` 来获取

  ```javascript
  var arr = ['hello', 'world']
  
  console.log(arr[0]) // hello
  console.log(arr[1]) // world
  ```

###### 4 数组的常用方法

- 数组是一个复杂数据类型，我们在操作它的时候就不能再想基本数据类型一样操作了

- 比如我们想改变一个数组

  ```javascript
  // 创建一个数组
  var arr = [1, 2, 3]
  
  // 我们想把数组变成只有 1 和 2
  arr = [1, 2]
  ```

  - 这样肯定是不合理，因为这样不是在改变之前的数组
  - 相当于心弄了一个数组给到 `arr` 这个变量了
  - 相当于把 `arr` 里面存储的地址给换了，也就是把存储空间换掉了，而不是在之前的空间里面修改
  - 所以我们就需要借助一些方法，在不改变存储空间的情况下，把存储空间里面的数据改变了



**数组常用方法之 push**

- `push` 是用来在数组的末尾追加一个元素

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 push 方法追加一个元素在末尾
  arr.push(4)
  
  console.log(arr) // [1, 2, 3, 4]
  ```



**数组常用方法之 pop**

- `pop` 是用来删除数组末尾的一个元素

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 pop 方法删除末尾的一个元素
  arr.pop()
  
  console.log(arr) // [1, 2]
  ```



**数组常用方法之 unshift**

- `unshift` 是在数组的最前面添加一个元素

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 unshift 方法想数组的最前面添加一个元素
  arr.unshift(4)
  
  console.log(arr) // [4, 1, 2, 3]
  ```



**数组常用方法之  shift**

- `shift` 是删除数组最前面的一个元素

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 shift 方法删除数组最前面的一个元素
  arr.shift()
  
  console.log(arr) // [2, 3]
  ```



**数组常用方法之 splice**

- `splice` 是截取数组中的某些内容，按照数组的索引来截取

- 语法： `splice(从哪一个索引位置开始，截取多少个，替换的新元素)` （第三个参数可以不写）

  ```javascript
  var arr = [1, 2, 3, 4, 5]
  
  // 使用 splice 方法截取数组
  arr.splice(1, 2)
  
  console.log(arr) // [1, 4, 5]
  ```

  - `arr.splice(1, 2)` 表示从索引 1 开始截取 2 个内容
  - 第三个参数没有写，就是没有新内容替换掉截取位置

  ```javascript
  var arr = [1, 2, 3, 4, 5]
  
  // 使用 splice 方法截取数组
  arr.splice(1, 2, '我是新内容')
  
  console.log(arr) // [1, '我是新内容', 4, 5]
  ```

  - `arr.splice(1, 2, '我是新内容')` 表示从索引 1 开始截取 2 个内容
  - 然后用第三个参数把截取完空出来的位置填充



**数组常用方法之 reverse**

- `reverse` 是用来反转数组使用的

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 reverse 方法来反转数组
  arr.reverse()
  
  console.log(arr) // [3, 2, 1]
  ```

**数组常用方法之 sort**

- `sort` 是用来给数组排序的，会改变原始数组

  ```javascript
  var arr = [2, 3, 1]
  
  // 使用 sort 方法给数组排序
  arr.sort()
  
  console.log(arr) // [1, 2, 3]
  ```

  - 这个只是一个基本的简单用法，默认比较的是字符串第一位字符的**UTF-16 编码**，所以如果是[10,1,2]，排序后是[1,10,2]
  
    标准用法：
  
    **自定义比较函数**
  
    - **语法**：`arr.sort(compareFunction)`
    - **参数**：`compareFunction(a, b)`，返回负数、0或正数。a,b是数组从第一位元素开始遍历
    - **规则**：
      - 返回 **负数**：`a`排在`b`前面。
      - 返回 **正数**：`b`排在`a`前面。
      - 返回 **0**：保持原有顺序。
  
    #### **示例1：数字排序**
  
    javascript
  
    复制
  
    ```
    // 升序
    [3, 1, 2].sort((a, b) => a - b); // [1, 2, 3]
    // 降序
    [3, 1, 2].sort((a, b) => b - a); // [3, 2, 1]
    ```
  
    #### **示例2：对象属性排序**
  
    javascript
  
    复制
  
    ```
    const users = [
      { name: 'Alice', age: 30 },
      { name: 'Bob', age: 25 }
    ];
    users.sort((a, b) => a.age - b.age); // 按年龄升序
    ```
  
    #### **示例3：字符串排序（忽略大小写）**
  
    javascript
  
    复制
  
    ```
    const names = ['Zoe', 'Adam', 'bob'];
    names.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
    // 结果：['Adam', 'bob', 'Zoe']
    ```

**数组常用方法之 concat**

- `concat` 是把多个数组进行拼接

- 和之前的方法有一些不一样的地方，就是 `concat` 不会改变原始数组，而是返回一个新的数组

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 concat 方法拼接数组
  var newArr = arr.concat([4, 5, 6])
  
  console.log(arr) // [1, 2, 3]
  console.log(newArr) // [1, 2, 3, 4, 5, 6]
  ```

  - 注意： **`concat` 方法不会改变原始数组**



**数组常用方法之 join**

- `join` 是把数组里面的每一项内容链接起来，变成一个字符串

- 可以自己定义每一项之间链接的内容 `join(要以什么内容链接)` 如果没有字符就是直接变成字符串

- 不会改变原始数组，而是把链接好的字符串返回

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 join 链接数组
  var str = arr.join('-')
  
  console.log(arr) // [1, 2, 3]
  console.log(str) // 1-2-3
  ```

  - 注意： **join 方法不会改变原始数组，而是返回链接好的字符串**

**数组常用方法之 indexOf**

- `indexOf` 用来找到数组中某一项的索引

- 语法： `indexOf(你要找的数组中的项)`

  ```javascript
  var arr = [1, 2, 3, 4, 5]
  
  // 使用 indexOf 超找数组中的某一项
  var index = arr.indexOf(3)
  
  console.log(index) // 2
  ```

  - 我们要找的是数组中值为 3 的那一项
  - 返回的就是值为 3 的那一项在该数组中的索引

- 如果你要找的内容在数组中没有，那么就会返回 -1

  ```javascript
  var arr = [1, 2, 3, 4, 5]
  
  // 使用 indexOf 超找数组中的某一项
  var index = arr.indexOf(10)
  
  console.log(index) // -1
  ```

  - 你要找的值在数组中不存在，那么就会返回 -1



**数组常用方法之 forEach**

- 和 `for` 循环一个作用，就是用来遍历数组的，不能进行操作

- 语法：`arr.forEach(function (item, index, arr) {})`

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 forEach 遍历数组
  arr.forEach(function (item, index, arr) {
    // item 就是数组中的每一项
    // index 就是数组的索引
    // arr 就是原始数组
    console.log('数组的第 ' + index + ' 项的值是 ' + item + '，原始数组是', arr)
  })
  ```

  - `forEach()` 的时候传递的那个函数，会根据数组的长度执行
  - 数组的长度是多少，这个函数就会执行多少回



**数组常用方法之 map** 

- 和 `forEach` 类似，只不过可以对数组中的每一项进行操作，返回一个新的数组

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 map 遍历数组
  var newArr = arr.map(function (item, index, arr) {
    // item 就是数组中的每一项
    // index 就是数组的索引
    // arr 就是原始数组
    return item + 10
  })
  
  console.log(newArr) // [11, 12, 13]
  ```



**数组常用方法之 filter**

- 和 `map` 的使用方式类似，按照我们的条件来筛选数组

- 把原始数组中满足条件的筛选出来，组成一个新的数组返回

  ```javascript
  var arr = [1, 2, 3]
  
  // 使用 filter 过滤数组
  var newArr = arr.filter(function (item, index, arr) {
    // item 就是数组中的每一项
    // index 就是数组的索引
    // arr 就是原始数组
    return item > 1
  })
  
  console.log(newArr) // [2, 3]
  ```

  - 我们设置的条件就是 `> 1`
  - 返回的新数组就会是原始数组中所有 `> 1` 的项

**数组常用方法之`find()`**：返回数组中第一个满足提供的测试函数的元素的值。如果没有找到符合条件的元素，则返回 `undefined`。该方法不会修改原数组。

```
javascript复制编辑const arr = [1, 2, 3, 4, 5];
const result = arr.find(element => element > 3);
console.log(result); // 输出: 4
```

**数组常用方法之`findIndex()`**：返回数组中第一个满足提供的测试函数的元素的索引。如果没有找到符合条件的元素，则返回 `-1`。该方法不会修改原数组。

```
javascript复制编辑const arr = [1, 2, 3, 4, 5];
const index = arr.findIndex(element => element > 3);
console.log(index); // 输出: 3
```

**数组常用方法之`indexOf()**`**：返回数组中指定元素的第一个索引位置。如果元素不存在，则返回 `-1`。该方法不会修改原数组。

```
javascript复制编辑const arr = [1, 2, 3, 4, 5];
const index = arr.indexOf(3);
console.log(index); // 输出: 2
```

**数组常用方法之`includes()`**：判断数组中是否包含指定的元素，返回布尔值 `true` 或 `false`。该方法不会修改原数组。

```
javascript复制编辑const arr = [1, 2, 3, 4, 5];
const contains = arr.includes(3);
console.log(contains); // 输出: true
```

**数组常用方法之`some()`**：检查数组中是否至少有一个元素满足提供的测试函数，返回布尔值 `true` 或 `false`。该方法不会修改原数组。

```
javascript复制编辑const arr = [1, 2, 3, 4, 5];
const hasEven = arr.some(element => element % 2 === 0);
console.log(hasEven); // 输出: true
```

**数组常用方法之`every()`**：检查数组中的所有元素是否都满足提供的测试函数，返回布尔值 `true` 或 `false`。该方法不会修改原数组。

```
javascript复制编辑const arr = [1, 2, 3, 4, 5];
const allPositive = arr.every(element => element > 0);
console.log(allPositive); // 输出: true
```

**`reduce()` 方法**

`reduce()` 方法对数组中的每个元素执行一个提供的函数，并将其结果汇总为单个值。

**语法：**

```
javascript


复制编辑
array.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue)
```

- **`callback`**：用于处理数组每个元素的函数，接收四个参数：
  - **`accumulator`**：累加器，保存上一次调用 `callback` 的返回值，或者是 `initialValue`（如果提供了）。
  - **`currentValue`**：当前处理的元素。
  - **`currentIndex`**（可选）：当前元素的索引。
  - **`array`**（可选）：调用 `reduce()` 的数组本身。
- **`initialValue`**（可选）：作为第一次调用 `callback` 时的 `accumulator` 的值。如果未提供，`accumulator` 将是数组的第一个元素，`currentValue` 从第二个元素开始。

**示例：**

1. **计算数组元素的总和：**

   ```
   javascript复制编辑const numbers = [1, 2, 3, 4, 5];
   const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
   console.log(sum); // 输出: 15
   ```

**`Array.from()` 方法**

`Array.from()` 方法用于从类数组对象或可迭代对象创建一个新的数组实例。

**语法：**

```
javascript


复制编辑
Array.from(arrayLike[, mapFn[, thisArg]])
```

- **`arrayLike`**：想要转换成数组的类数组对象或可迭代对象。
- **`mapFn`**（可选）：对数组的每个元素调用的映射函数。
- **`thisArg`**（可选）：执行 `mapFn` 时用作 `this` 的值。

**示例：**

1. **从字符串创建数组：**

   ```
   javascript复制编辑const str = 'Hello';
   const arr = Array.from(str);
   console.log(arr); // 输出: ['H', 'e', 'l', 'l', 'o']
   ```
   
   **从 Set 创建数组：**
   
   ```
   javascript复制编辑const set = new Set([1, 2, 3, 4, 5]);
   const arr = Array.from(set);
   console.log(arr); // 输出: [1, 2, 3, 4, 5]
   ```
   
   **从类数组对象（如 `arguments`）创建数组：**
   
   ```
   javascript复制编辑function example() {
     const args = Array.from(arguments);
     console.log(args); // 输出: [1, 2, 3]
   }
   example(1, 2, 3);
   ```
   
   **使用映射函数转换数组元素：**
   
   ```
   javascript复制编辑const numbers = [1, 2, 3];
   const doubled = Array.from(numbers, x => x * 2);
   console.log(doubled); // 输出: [2, 4, 6]
   ```

**`split()` 方法**用于将字符串拆分为子字符串数组。该方法接受两个参数：分隔符和分割次数。

**语法：**

```
javascript


复制编辑
str.split([separator[, limit]])
```

**参数：**

- `separator`（可选）：指定用于分割字符串的分隔符。可以是字符串或正则表达式。
- `limit`（可选）：指定返回的子字符串数组的最大长度。

**示例：**

1. **使用分隔符分割字符串：**

   ```
   javascript复制编辑const str = 'apple,banana,cherry';
   const fruits = str.split(',');
   console.log(fruits); // 输出：['apple', 'banana', 'cherry']
   ```

   在上述示例中，字符串 `str` 被逗号 `,` 分割成了一个包含三个元素的数组。

#### 三. 栈结构

##### 1.认识栈结构

> 栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

**特点：后进先出即Last in First Out（LIFO）。**



![image-20221006102745956](%E7%AC%94%E8%AE%B0.assets/image-20221006102745956.png)

**函数调用栈**

![image-20221006102943824](%E7%AC%94%E8%AE%B0.assets/image-20221006102943824.png)





##### 2. 封装栈结构

```js
class Stack{
    // 这里变量名前边加井号，代表这是私有属性，外部无法访问
    // 如果是ts直接加private即可
    #items = []
	
    // 入栈，先入后出
    push(data){
        this.#items.push(data)
    }
	
    // 出栈，后入先出
    pop(){
        return this.#items.pop()
    }
	
    // 取栈顶
    peek(){
        //    return this.items[this.items.length-1]	at用来取括号内索引对应的元素，正整数从前往后从零开始，负整数从后往前从1开始
        return this.#items.at(-1)
    }
    
    // 判断是否为空
    isEmpty(){
        return this.#items.length===0
    }
	
    // 判断数组大小
    size(){
        return this.#items.length
    }
	
    // 清空数组
    clear(){
        this.#items = []
    }
	
    // 数组元素转换为字符串
    toString(){
        return this.#items.join("")
    }
}
```

##### 3. 应用

###### 3-1 十进制转二进制

```js
function convert(decNumber){
    let remStack = new Stack()
    let number = decNumber
    let rem 
    let string = ""
	
    // 经典辗转相除法（长除法）
    while(number>0){
        rem = number%2
        remStack.push(rem)
        // 向下取整
        number = Math.floor(number/2)
    }

    while(!remStack.isEmpty()){
        // 栈将后进的先pop出去，正好符合长除法算法
        string+=remStack.pop()
    }

    return string
}
```

###### 3-2 不确定进制转换法

```js
function convert(decNumber,base){	// 将进制作为参数传入
    let remStack = new Stack()
    let number = decNumber
    let rem 
    let string = ""
    // 由于没有9以上的数字，所以直接应用到十六进制无法表示9以上
    // 采用方法是规定一个数组按顺序包括所有16进制符号
    let baseStr = "0123456789ABCDEF"
    while(number>0){
        rem = number%base
        remStack.push(rem)
        number = Math.floor(number/base)
    }

    while(!remStack.isEmpty()){
        // 通过索引取值，实现16进制转换
        string+= baseStr[remStack.pop()]
    }

    return string
}
```



#### 四. 队列

##### 1.队列是什么？

> 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。

队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，**故队列又称为先进先出（FIFO—first in first out）线性表。** 



<img src="%E7%AC%94%E8%AE%B0.assets/image-20221007090409911.png" alt="image-20221007090409911" style="zoom:50%;float:left" />

![](%E7%AC%94%E8%AE%B0.assets/15586502-30ee422b0922669e.webp)



##### 2.队列的封装



```js
class Queue {
    // 通过对象的方式模拟数组，delete删除就直接删除，而直接用数组会留下一个空元素
    #items = {}
    // 所有元素的个数，相当于尾指针
    #count = 0
    // 删除到第几个元素，相当于头指针
    #lowCount = 0
	
    // 队首删除元素
    // 如果直接使用shift就不需要这么多变量和逻辑，但由于shift很占用内存，所以不采用
    dequeue() {
        // 如果对象是空就直接返回
        if(this.isEmpty()){
            return undefined
        }
        // 被删除的队首元素
        let res = this.#items[this.#lowCount]
        // 删除队首元素
        delete this.#items[this.#lowCount]
        // 头指针向后移动1
        this.#lowCount++
        return res
    }
	
    // 队尾添加元素
    enqueue(data) {
        this.#items[this.#count] = data
        // 队尾指针加1
        this.#count++
    }
	
    // 返回队首元素
    front() {
        return this.#items[this.#lowCount]
    }

    isEmpty() {
        return this.size() === 0
    }
	
    // 返回队伍长度，用尾指针减去头指针
    size() {
        // 用队伍
        return this.#count-this.#lowCount
    }
	
    // 所有都清空
    clear() {
        this.#items = {}
        this.#count = 0;
        this.#lowCount = 0
    }
	
    // 转换为字符串
    toString() {
        let str = ""
        for(let i =this.#lowCount;i<this.#count;i++){
            str += `${this.#items[i]} `
            }
        return str
    }
}
```



##### 3. 队列的应用-击鼓传花

每次按鼓声敲击次数决定传几次花，最后传到谁手里谁就淘汰，看最后剩下来的是谁

每次队首敲击后重新排到队尾，所以可以使用队列解决

```js
function game(list,num){
    let queue = new Queue()
    // 先将参与人员依次传入队列
    for(let i=0;i<list.length;i++){
        queue.enqueue(list[i])
    }
	
    // 当队列仅剩下一个人时结束循环，那个人就是胜者
    while(queue.size()>1){
        for(let i=0;i<num;i++){
            // 每次将队首删除，再添加到队尾
            queue.enqueue(queue.dequeue())
        }
        // 花传到最后就淘汰
        console.log(queue.dequeue(),"淘汰了")
    }

    return {
        winner:queue.dequeue()
    }
}

game(["kerwin","tiechui","xiaoming","gangdaner","guludunzi"],7)
```



##### 4. 双端队列

队列是只能尾插头删，而双端队列就是头部尾部都可以插入和删除

```js
class DeQueue {
    #items = {}
    #lowCount = 0
    #count = 0
    
    removeFront() {
        if (this.isEmpty()) {
            return undefined
        }
        let res = this.#items[this.#lowCount]
        delete this.#items[this.#lowCount]
        this.#lowCount++
        return res
    }
	
    addBack(data) {
        this.#items[this.#count] = data
        this.#count++
    }
	
    // 头部插入，有链表方法更加简便
    addFront(data) {
        // 如果为空就与尾插相同
        if(this.isEmpty()){
            this.addBack(data)
        }else if(this.#lowCount>0){
            	// 如果头指针不在第一位就先向前移一位，再给相应位置插入元素
                 this.#lowCount--;
                 this.#items[this.#lowCount] = data
                 }else{
                     // 如果头指针在第一位，就只好每个元素向后挪一位，再将空出来的队列首位插入元素
                    for(let i = this.#count;i>0;i--){
                        this.#items[i] = this.#items[i-1]
                        }
                    this.#count++;
                    this.#lowCount = 0;
                    this.#items[0] = data
        }
    }
	
    // 尾部删除
    removeBack() {
        if (this.isEmpty()) {
            return undefined
        }

        this.#count--;
        const result = this.#items[this.#count]
        delete this.#items[this.#count]

        return result
    }
	
    // 取队首元素
    peekFront() {
        return this.#items[this.#lowCount]
    }
    
    // 取队尾元素
    peekBack() {
        if (this.isEmpty()) {
            return undefined
        }
        return this.#items[this.#count - 1]
    }

    isEmpty() {
        return this.size() === 0
    }

    size() {
        return this.#count - this.#lowCount
    }

    clear() {
        this.#items = {}
        this.#count = 0
        this.#lowCount = 0
    }

    toString() {
        let str = ""
        for (let i = this.#lowCount; i < this.#count; i++) {
             str += `${this.#items[i]} `
             }
        return str
    }
}
```



#### 五. 链表

> 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。
>
> 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。



**链表的特点**

1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。
2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。

##### 1. 单链表

> 每个节点只包含一个指针，即后继指针。

![image-20221124153431191](%E7%AC%94%E8%AE%B0.assets/image-20221124153431191.png)

```js
// 定义节点，包括元素和向下的指针
class Node {
    constructor(element){
        this.element = element
        this.next = null
    }
}

// 定义链表
class LinkedList {
    // 包括头节点和链表长度
    constructor(){
        this.head = null
        this.count = 0
    }
	
    // 增加节点
    push(element){
        // 新节点node
        const node = new Node(element)
        let current ;
        // 如果链表内没节点就直接将node插入头节点
        if(this.head===null){
            this.head = node
        }else{
            // 否则就从头节点开始向下遍历，直到最后一个节点，然后使最后一个节点的next为node
            current = this.head

            while(current.next!==null){
                current = current.next
            }

            current.next = node
        }
        // 每次尾插长度加一
        this.count++
    }

	// 根据索引移除节点
    removeAt(index){
        // 需要位于范围内
        if(index>=0&&index<this.count){
            // 从头节点开始
            let current = this.head
            // 如果要移除头节点，直接使头节点为头节点的next
            if(index===0){
                this.head = current.next
            }else{
                // 如果移除的不是头节点，就开始遍历，直到current是要被移除的节点，previous是要被移除节点的上一个
                for(let i =0;i<index;i++){
                    previous = current
                    current = current.next
                }
                
				// 令被移除节点上一个节点的next是被移除节点的next
                // 这样链表就略过了中间的被移除节点，删除成功
                previous.next = current.next
            }
			// 列表长度也减一
            this.count--
            return current.element
        }

        return 
    }
	
    // 获得某个索引的节点
    getNodeAt(index){
        if(index>=0&&index<this.count){
            let node = this.head

            for(let i=0;i<index;i++){
                node= node.next
            }
            return node
        }
        return 
    }

    // 同样是移除，中间遍历逻辑套用getNodeAt
    removeAt2(index){
        if(index>=0&&index<this.count){
            let current = this.head
            if(index===0){
                this.head = current.next
            }else{
                const previous = this.getNodeAt(index-1)

                current = previous.next

                previous.next = current.next
            }

            this.count--
            return current.element
        }

        return 
    }
	
    // 两元素是否相等，都转化为JSON字符串来比较
    equalFn(a,b){
        return JSON.stringify(a)===JSON.stringify(b)
    }

    indexOf(element){
        let current = this.head
		
        // 将链表遍历，套用equalFn比较元素是否相等，若相等就返回索引值
        for(let i=0;i<this.count;i++){
            if(this.equalFn(element,current.element)){
                return i
            }
            current = current.next
        }

        return -1
    }

	// 按节点元素删除
    remove(element){
        // 先获取相应节点索引值
        const index = this.indexOf(element)
        // 再删除相应节点
        return this.removeAt(index)
    }

	// 插入节点
    insert(element,index){
        // 范围包括长度加一，因为可以后插，相当于push了
        if(index>=0&& index<=this.count){
            const node = new Node(element)
			// 头插
            if(index===0){
				// 定义一个当前节点为当前头节点
                const current = this.head
                // 插入节点的next为当前节点
                node.next = current
                // 头节点变为插入节点
                this.head = node
            }else{
                // 如果再中间或后插，与索引删除相似，先获取插入两边的节点
                const previous = this.getNodeAt(index-1)
                const current = previous.next
				// 令插入节点的next为下一个节点
                node.next =  current
				// 上一个节点的next为插入节点
                previous.next = node
            }
			// 总长度加一
            this.count++
            return true
        }
        return false
    }

    isEmpty(){
        return this.size()===0
    }
    size(){
        return this.count
    }

    getHead(){
        return this.head
    }
}

```



##### 2. 双向链表

> 节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。

![image-20221124153552974](%E7%AC%94%E8%AE%B0.assets/image-20221124153552974.png)

![image-20221130115202342](%E7%AC%94%E8%AE%B0.assets/image-20221130115202342.png)

```js
// 定义双向链表的节点，包括前后指针和元素
class DoublyNode extends Node { 
    constructor(element) {
        super(element); 
        this.prev = null; 
    }
}

// 定义双向链表，包括头尾指针
class DoublyLinkedList extends LinkedList {
    constructor() {
        super();
        this.tail = null;
    }
	
    // 增加节点
    push(element) {
        const node = new DoublyNode(element);
        // 如果链表为空，直接头尾指针都为插入节点
        if (this.head == null) {
            this.head = node;
            this.tail = node; 
        } else {	// 如果有值
            // 令尾指针的next为插入节点
            this.tail.next = node;
            // 插入节点的prev为尾指针
            node.prev = this.tail;
            // 把尾指针移到新尾插的节点
            this.tail = node;
        }
        // 总长加一
        this.count++;
    }
	
    // 插入节点
    insert(element, index) {
        // 需要在范围内，可以是尾插
        if (index >= 0 && index <= this.count) {
            const node = new DoublyNode(element);
            let current = this.head;
            // 如果是头插
            if (index === 0) {
                // 如果内部没值，就和增加一样
                if (this.head == null) { 
                    this.head = node;
                    this.tail = node; 
                } else {	// 如果内部有值
                    // 插入节点的next为头节点
                    node.next = this.head;
                    // 头节点的prev为插入节点
                    this.head.prev = node;
                    // 头指针移动到新插入的节点
                    this.head = node;
                }
            } else if (index === this.count) { // 如果尾插
                current = this.tail;	// 首先把current移到最后尾节点
                current.next = node;	// 尾节点的next为插入节点
                node.prev = current;	// 插入节点的prev为尾节点
                this.tail = node;		// 尾指针向后移动到新插入的节点
            } else {	// 如果中间插入，就像是单项列表一样，将左右两侧的节点的prev和next相互匹配即可
                const previous = this.getNodeAt(index - 1);
                current = previous.next;
                node.next = current;
                previous.next = node;
                current.prev = node; 
                node.prev = previous; 
            }
            // 长度加一
            this.count++;
            return true;
        }
        return false;
    }
	
    // 根据索引删除节点
    removeAt(index) {
        if (index >= 0 && index < this.count) {
            let current = this.head;
            if (index === 0) {	// 删除头节点，相当于把第一个节点断开
                this.head = this.head.next;	// 令head为head的next，如果只有一个节点则head变为空

                if (this.count === 1) {	// 如果链表只有一个节点，删除后链表为空，尾节点手动设置undefined
                    this.tail = undefined;
                } else {
                    // 如果不止一个节点，则尾节点不为空。头节点的prev手动设置为空
                    this.head.prev = undefined;
                }
            } else if (index === this.count - 1) {	// 删除尾节点
                current = this.tail;	// 首先令current为尾节点
                this.tail = current.prev;	// 尾指针向前一个，相当于把最后一个节点断开，就是删除
                this.tail.next = undefined;	// 将新的尾指针的next设置尾空，彻底断开
            } else {
                // 中间删除，过程与单向链表相同，只是要将两个指针都略过被删除节点
                current = this.getNodeAt(index);
                const previous = current.prev;
                previous.next = current.next;
                current.next.prev = previous; // NEW
            }
            // 总长度减一
            this.count--;
            return current.element;
        }
        return undefined;
    }


    getHead() {
        return this.head;
    }

    getTail() {
        return this.tail;
    }
}

```

##### 3. 循环链表

> 循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用 undefined，而是指向第一个元素（head）

![image-20221130143728398](%E7%AC%94%E8%AE%B0.assets/image-20221130143728398.png)

```js
 class CircularLinkedList extends LinkedList {
     constructor() {
         super();
     }
	
     // 增加节点
     push(element) {
         const node = new Node(element);
         let current;
         // 为空时直接添加
         if (this.head == null) {
             this.head = node;
         } else {	// 不为空就先取到最后一个节点，令其next尾新加的节点
             current = this.getNodeAt(this.size() - 1);
             current.next = node;
         }
         // 使新加节点的next为头节点
         node.next = this.head;
         // 长度加一
         this.count++;
     }
	
     // 插入节点
     insert(element, index) {
         if (index >= 0 && index <= this.count) {
             const node = new Node(element);
             let current = this.head;
             // 头插
             if (index === 0) {
                 if (this.head == null) {
                     // 如果链表为空。直接赋值，同时next要指到自己
                     this.head = node;
                     node.next = this.head;
                 } else {	
                     node.next = current;	// 如果链表不为空，就让插入节点的next指向头节点
                     current = this.getNodeAt(this.size() - 1);	// 取到最后一个节点
                     // 头指针指到插入节点
                     this.head = node;
                     // 尾指针指到头指针
                     current.next = this.head;
                 }
             } else {	// 如果不是头插，与单链表相同
                 const previous = this.getNodeAt(index - 1);	
                 node.next = previous.next;
                 previous.next = node;
             }
             this.count++;
             return true;
         }
         return false;
     }
	
     // 删除节点
     removeAt(index) {
         if (index >= 0 && index < this.count) {
             let current = this.head;
             if (index === 0) {	// 如果删除头节点
                 if (this.size() === 1) {	// 如果只有一个节点，直接删除即可。由于next还是指向的它本身，所以也一并删除
                     this.head = undefined;
                 } else {	// 否则就取到最后一个节点，令头指针直到它下一位，然后尾节点next指向新的头节点
                     let last  = this.getNodeAt(this.size() - 1);
                     this.head = this.head.next;
                     last.next = this.head;
                 }
             } else {	// 不删除头节点与单链表相同
                 const previous = this.getNodeAt(index - 1);
                 current = previous.next;
                 previous.next = current.next;// 如果删的是最后一个也不怕，current.next 是head
             }
             this.count--;
             return current.element;
         }
         return undefined;
     }
 }
```

#### 六. 集合

> 集合是由一组无序且唯一（即不能重复）的项组成的。



##### 1.集合类

集合与数组的区别在于集合内部所有元素都不重复

```js
class KerwinSet {
    constructor() {
        this.items = {};
    }
    
    //	增加元素
    add(element) {
        if (!this.has(element)) {
            // 如果没有该元素就添加，对应的属性和属性值都是传入的元素
            this.items[element] = element; 
            return true;
        }
        return false;
    }
	
    // 删除元素
    delete(element) {
        if (this.has(element)) {
            // 如果有该元素就删除
            delete this.items[element]; 
            return true;
        }
        return false;
    }
	
    // 清除所有元素
    clear() {
        this.items = {};
    }
	
    // 集合长度
    size() {
        return Object.keys(this.items).length; 
    }
	
    // 返回所有集合内所有值
    values() {
        return Object.values(this.items);
    }
	
    // 判断有没有某元素
    has(element) {
        // in用来检测对象中有没有对应属性名的属性
        return element in this.items;
    }
}
```



##### 2.ES6的Set

set就是集合，包括所有上边的方法。

可以通过add方法加入元素，也可以初始化赋值时就通过数组传入元素

```js
var myset = new Set([1,5,10])

myset.add(100)
myset.add(200)
myset.size
myset.values()
myset.delete(100)
myset.clear()
```



##### 3.集合的运算

- 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。

  ```javascript
  let myset1 = [1,2,3]
  let myset2 = [3,4,5]
  
  let myset = new Set([...myset1,...myset2])
  consolog(myset) // Set(5) {1, 2, 3, 4, 5}
  ```

  

- 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。 

  ```js
  let myset1 = [1, 2, 3]
  let myset2 = [3, 4, 5]
  
  let myset = new Set([...myset1].filter(item => myset2.includes(item)))        console.log(myset)//Set(1) {3}
  ```

  

- 差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集 合的元素的新集合。

  ```js
  let myset1 = [1, 2, 3]
  let myset2 = [3, 4, 5]
  
  let myset = new Set([...myset1].filter(item => !myset2.includes(item)))        
  console.log(myset)//Set(2) {1, 2}
  ```
  
  



#### 七. 字典

> 字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射、符号表或关联数组。



##### 1.字典的封装

```js
class Dictionary {
    constructor() {
        this.table = {};
    }
    // Map允许属性名为非字符串，而对象属性名只能为字符串，所以将所有形式的属性名都转化为字符串
    toStrFn(item) {
        if (item === null) {	// null空就返回NULL
            return 'NULL';
        } else if (item === undefined) {	// undefined就返回UNDEFINED
            return 'UNDEFINED';
        } else if (typeof item === 'string' || item instanceof String) {	// 如果是字符串就直接返回
            return `${item}`;
        }
        return JSON.stringify(item);	// 其他形式就通过JSON.stringify转化为字符串
    }
    
    // 按属性名判断有无某属性
    hasKey(key) {
        // 将传入属性名转化为字符串并判断
        return this.table[this.toStrFn(key)] != null;
    }
    
    // 设置键值对
    set(key, value) {
        if (key != null && value != null) {
            // 首先获得转化为字符串的属性名 (key)
            const tableKey = this.toStrFn(key);
           	// 将字符串作为属性名，存入对应属性值。
            // 如果有对象作为属性名，则转换为字符串后，再取出key也是字符串类型
            // 但希望取出key时依然保持之前的类型，所以将key和value放到一个对象里
            // 之后取出key则再取一下对象中的key属性，则能够得到原始属性的key
            // 这样一来所有的属性值都是包含Key和value的对象
            this.table[tableKey] = new ValuePair(key, value);
            return true;
        }
        return false;
    }
	
    // 按属性名移除
    remove(key) {
        if (this.hasKey(key)) {	// 如果有对应属性就删除该属性
            delete this.table[this.toStrFn(key)];
            return true;
        }
        return false;
    }
	
    // 获取某属性值
    get(key) {
        // 先得到属性值（对象）
        const valuePair = this.table[this.toStrFn(key)];
        // 判断，如果不是空就返回对象中真正的值
        return valuePair == null ? undefined : valuePair.value;
    }
    
    //它会以数组形式返回字典中的所有 valuePair 对象。
    keyValues() {
        return Object.values(this.table);
    }
	
    // 返回valuePair对象中真正的key
    keys() {
        return this.keyValues().map(valuePair => valuePair.key);
    }
	
    // 返回valuePair对象中真正的value
    values() {
        return this.keyValues().map(valuePair => valuePair.value);
    }
	
    // 根据key的个数求长度，得到字典的长度
    size() {
        return Object.keys(this.table).length;
    }
    //是否空
    isEmpty() {
        return this.size() === 0;
    }
	
    // 清除字典
    clear() {
        this.table = {};
    }
	
    // 迭代器，返回所有对象中所有的key和value
    forEach(callbackFn) {
        const valuePairs = this.keyValues(); 
        for (let i = 0; i < valuePairs.length; i++) { 
            callbackFn(valuePairs[i].key, valuePairs[i].value); 
        }
    }
}

// 定义一个包含键值的对象来存储，以保留类型
class ValuePair {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}

var mymap = new Dictionary()
```



##### 2.散列表(哈希表)

> HashMap 类，它是 Dictionary 类的一种散列表 实现方式。.散列算法的作用是尽可能快地在数据结构中找到一个值。
>
> 与普通Map的区别时，哈希表可以将所有的属性名都转通过函数转化为一个独一无二的数。这样一来通过数来寻找对应的属性，比通过可能有各种各样类型的属性名来寻找要减少很多性能消耗

![image-20221205165416371](%E7%AC%94%E8%AE%B0.assets/image-20221205165416371.png)

```js
class ValuePair {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}

class HashTable {
    constructor() {
        this.table = {};
    }
    toStrFn(item) {
        if (item === null) {
            return 'NULL';
        } else if (item === undefined) {
            return 'UNDEFINED';
        } else if (typeof item === 'string' || item instanceof String) {
            return `${item}`;
        }
        return JSON.stringify(item);
    }
    // key转化为数字，通常是对字符对应的码值进行处理，使其一定是一个独一无二的数字
    myHashCode1(key) {
        // 类型是数字就直接返回
        if (typeof key === 'number') {
            return key;
        }
        // 不是就进行处理
        const tableKey = this.toStrFn(key);
        let hash = 0; 
        for (let i = 0; i < tableKey.length; i++) {
            hash += tableKey.charCodeAt(i);	// 对每个字符都获得其码值并求和，得到数字
        }

        //为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数
        return hash % 37; 
    }
    // 上边的处理方式可能会遇到处理后相同数字的字符串，而下边的处理方式可保证都是独一无二的数字
    myHashCode2(key) {
        const tableKey = this.toStrFn(key); 
        let hash = 5381; 
        for (let i = 0; i < tableKey.length; i++) { 
            hash = (hash * 33) + tableKey.charCodeAt(i); 
        }
        return hash % 1013;
    }
    
    // 获得哈希数
    hashCode(key) {
        return this.myHashCode2(key);
    }
	
    // 添加元素，经过函数处理
    put(key, value) {
        if (key != null && value != null) {
            const position = this.hashCode(key); 
            this.table[position] = new ValuePair(key, value);
            return true;
        }
        return false;
    }
	
    // 得到key对应值，也是通过求函数处理得到哈希数再找对应值
    get(key) {
        const valuePair = this.table[this.hashCode(key)];
        return valuePair == null ? undefined : valuePair.value;
    }
	
    // 移除元素
    remove(key) {
        const hash = this.hashCode(key); 
        const valuePair = this.table[hash]; 
        if (valuePair != null) {
            delete this.table[hash]; 
            return true;
        }
        return false;
    }
}
```



##### 3. ES6的Map

```js
var mymap = new Map()
mymap.set("name","kerwin")
mymap.set({a:1},"aaaaaa")

mymap.get("name")
mymap.delete("name")
```

>Map无法直接hu获得类型为对象的key，因为两个对象虽然值相同，但引用不同，相当于两个分别的对象，并不相等

```
console.log({a:1}==={a:1}) 	// false
mymap.get({a:1})	// undefined
```

>如果想要获得类型为对象的key，需要将对象赋值到一个变量上，再进行添加和获取

```js
var obj = {a:1}
mymap.set(obj,'aaaa')
mymap.get(obj)	// 'aaaa'
```



>Map和WeakMap的区别如下:
>
>1、Map的键可以是任何类型，而WeakMap的键只能是对象
>
>2、Map不会自动回收，即使外部无调用还是存在，除非显示删除键值对。而WeakMap的键会跟随外部变化而变化，只要没有调用就自动删除
>
>3、Map可以对内部属性遍历，WeakMap不行



#### 八 . 树

> 树是一种分层数据的抽象模型。

![image-20221206101959855](%E7%AC%94%E8%AE%B0.assets/image-20221206101959855.png)

##### 1. 二叉树

> 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。



##### 2. 二叉搜索树

> 二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值， 在右侧节点存储（比父节点）大或等于的值。
>
> 如果有一个新插入的节点，先于根节点比较，根据大于或小于放在左边或右边。再与第二级、第三级...节点比较，重复上一过程直到遇到空值，就插入

```js
// 比较对象，存储了大于，小于，相同三种结果
const Compare = {
    LESS_THAN: -1,
    BIGGER_THAN: 1,
    EQUALS: 0
};

// 节点
class Node {
    constructor(key) {
        this.key = key; // 节点值
        this.left = null; // 左侧子节点引用
        this.right = null; // 右侧子节点引用
    }
}

// 二叉搜索树
class BinarySearchTree {
    constructor() {
        this.root = null; //Node 类型的根节点
    }
    
    // 插入
    insert(key) {
        if (this.root == null) {	// 如果二叉树没有节点就直接插入
            this.root = new Node(key);
        } else {	// 有节点就调用insertNode函数，传入根节点和插入值
            this.insertNode(this.root, key);
        }
    }
    
    // 这是一个递归函数，插入值与节点依次比较决定向左或向右递归，直到最后来到空值就插入
    insertNode(node, key) {
        if (this.compareFn(key, node.key) === Compare.LESS_THAN) {	// 如果插入值比节点小
            if (node.left == null) {	// 出口，左节点是空值就直接插入
                node.left = new Node(key);
            } else {	// 否则就接着调用左节点
                this.insertNode(node.left, key);
            }
        } else {	// 反之如果插入值大于等于节点
            if (node.right == null) {	// 出口，右节点是空值就直接插入
                node.right = new Node(key);
            } else {	// 否则就接着调用右节点
                this.insertNode(node.right, key);
            }
        }
    }
	
    // 比较返回大小情况
    compareFn(a, b) {
        if (a === b) {
            return Compare.EQUALS;
        }
        return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;
    }
	
    // 中序遍历，将回调函数和根节点传入
    inOrderMap(callback) {
        this.inOrderMapNode(this.root, callback); 
    }
	
    // 中序遍历递归函数，接收节点和回调函数
    inOrderMapNode(node, callback) {
        // 只要节点不是空就接着递归
        // 顺序是左节点，父节点，右节点
        // 这样可以使得节点由小到大遍历一遍
        if (node != null) { 	
            this.inOrderMapNode(node.left, callback); 
            callback(node.key); 
            this.inOrderMapNode(node.right, callback); 
        }
    }
	
    // 前序遍历
    preOrderMap(callback) {
        this.preOrderMapNode(this.root, callback);
    }
	
    // 前序遍历递归函数
    preOrderMapNode(node, callback) {
        // 顺序是父节点，左节点，右节点
        // 这样可以节点由高到低遍历一遍
        if (node != null) {
            callback(node.key);
            this.preOrderMapNode(node.left, callback);
            this.preOrderMapNode(node.right, callback);
        }
    }
	
    // 后续遍历
    postOrderMap(callback) {
        this.postOrderMapNode(this.root, callback);
    }
	
    // 后序遍历递归函数
    postOrderMapNode(node, callback) {
        // 顺序是左节点，右节点，父节点
        // 这样可以节点由低到高遍历一遍
        if (node != null) {
            this.postOrderMapNode(node.left, callback);
            this.postOrderMapNode(node.right, callback);
            callback(node.key);
        }
    }
	
    // 查询最小值
    min() {
        return this.minNode(this.root);
    }
    
    // 一直向左遍历即可，直到左节点无值就返回
    minNode(node) {
        let current = node;
        while (current != null && current.left != null) {
            current = current.left;
        }
        return current;
    }
    
    // 查询最大值
    max() {
        return this.maxNode(this.root);
    }
    
    // 一直享有遍历，直到右节点无值就返回
    maxNode(node) {
        let current = node;
        while (current != null && current.right != null) {
            current = current.right;
        }
        return current;
    }
	
    // 查询二叉树内有没有某值
    search(key) {
        return this.searchNode(this.root, key);
    }
    
    // 通过大小判断来查找
    searchNode(node, key) {
        if (node == null) {	// 如果查到最后也没有就返回false
            return false;
        }	
        if (this.compareFn(key, node.key) === Compare.LESS_THAN) { // 如果小于就接着向左递归
            return this.searchNode(node.left, key);
        } else if (	
            this.compareFn(key, node.key) === Compare.BIGGER_THAN // 大于就向右递归
        ) {
            return this.searchNode(node.right, key);
        } else {	// 相等就说明由对应节点，返回true
            return true;
        }
    }
	
    // 移除某节点
    remove(key) {
        // 这里要进行实时的覆盖，因为传入的是形参，再内部更改不影响外部root
        // 所以每一个节点都要返回，获取其返回值，这样才能形成连起来的树
        this.root = this.removeNode(this.root, key); 
    }
    
    // 移除的递归函数
    removeNode(node, key) {
        // 传进来节点是空就直接返回
        if (node == null) { 
            return null;
        }
        
        // 接下来两个if else就是根据值判断向左向右遍历，依次递归下去，直到遇到需要需要删除的节点
        if (this.compareFn(key, node.key) === Compare.LESS_THAN) { 
            // 注意要为left赋值并返回node，下边right同理 
            node.left = this.removeNode(node.left, key); 
            return node; 
        } else if (
            this.compareFn(key, node.key) === Compare.BIGGER_THAN
        ) {
            node.right = this.removeNode(node.right, key); 
            return node; 
        } else {
            // 键等于 node.key，删除
            // 第一种情况，这个节点即无左节点也无右节点，直接赋空值并返回即可
            if (node.left == null && node.right == null) { 
                node = null; 
                return node; 
            }
            // 第二种情况，只有一边有节点，使其等于其下一个节点并返回，就这样将要删除节点忽略过去
            if (node.left == null) { 
                node = node.right; 
                return node; 
            } else if (node.right == null) { 
                node = node.left; 
                return node; 
            } 
            // 第三种情况，两边都有节点。
            // 大体思路是从该节点的右树中找到最小节点，赋值给要删除的节点
            // 然后将冗余节点删除（前两种方法）
            // 这样就能做到删除了节点并保证二叉树结构不变
            const target = this.minNode(node.right); // 找到右子树的最小节点
			node.key = target.key; // 用最小节点的值覆盖当前节点
			node.right = this.removeNode(node.right, target.key); // 删除右子树中的原最小节点
			return node;
        }
    }
}
```



###### 2-1 遍历

- 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序
  访问所有节点。 中序遍历的一种应用就是对树进行排序操作。
- 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构
  化的文档。
- 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目
  录及其子目录中所有文件所占空间的大小。



###### 2-2 移除

![image-20221206115005839](%E7%AC%94%E8%AE%B0.assets/image-20221206115005839.png)



#### 九. 二叉堆

二叉堆是一种特殊的二叉树，有以下两个特性。 

- 它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点）， 并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。 
- 二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速 导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子 节点。这叫作堆特性。

![image-20221207093025844](%E7%AC%94%E8%AE%B0.assets/image-20221207093025844.png)

##### 1. 最小堆

```js
const Compare = {
    less: -1,
    bigger: 1,
    equ: 0
}

// 最小堆
class MinHeap {
    // 用数组来存
    heap = [];
	// 因为是数组，没有指向下一节点的指针。所以手动设置上下节点的关系以当作指针
getLeftIndex(index) {	// 传入父节点获得左节点
    return 2 * index + 1;	
}
getRightIndex(index) {	// 传入父节点获得右节点
    return 2 * index + 2;
}
    
    // 传入子节点（不论左右）获得父节点
getParentIndex(index) {
    if (index === 0) {
        return undefined;
    }
    return Math.floor((index - 1) / 2);
}

    // 插入节点
insert(value) {
    if (value != null) {
        this.heap.push(value); // 先把节点插入到数组最后
        this.siftUp(this.heap.length - 1); // 再通过siftUp函数将其移到合适的位置
        return true;
    }
    return false;
}
    
    // 比较函数
compareFn(a, b) {
    if (a === b) {
        return Compare.equ
    }
    return a < b ? Compare.less : Compare.bigger
}

    // shiftUp函数用来将插入到最后的节点移到正确位置
siftUp(index) {
    let parent = this.getParentIndex(index);	// 先获取插入节点的父节点
    // 通过循环或递归（这里用循环）将插入节点一层层向上移动到正确位置
    // 循环条件是索引值不小于0，子节点值比父节点值大
    while (
        index > 0 &&
        this.compareFn(this.heap[parent], this.heap[index]) ===
        Compare.bigger
    ) {
        // 将子节点和父节点交换
        swap(this.heap, parent, index);
        index = parent;	// 索引值也向上提升
        parent = this.getParentIndex(index);	// 获得父节点，继续比较
    }
}
	
    // 获得最小堆长度
size() {
    return this.heap.length;
}
	
    // 判断最小堆是否为空
isEmpty() {
    return this.size() === 0;
}
    
    // 寻找最小值
findMinimum() {
    return this.heap[0];
}
	
    // 删除最小值
extract() {
    // 如果是空直接返回
    if (this.isEmpty()) {
        return undefined;
    }
    // 只有一个节点就直接删除
    if (this.size() === 1) {
        return this.heap.shift();
    }
    
    // 如果不止一个节点
    const removedValue = this.heap[0];	// 获得并返回删除掉的值
    this.heap[0] = this.heap.pop(); //为保证不破坏结构，需要重新排序。方法是将最后一个值放到第一位，然后用ShiftDown函数一层层移下去，从头到尾移一遍，直到所有节点都位于正确位置
    this.siftDown(0);	// 重新比较排序
    return removedValue;
}
    
    // shiftUp函数用来将插入到最前面的节点移到正确位置
    // 思路是先于左边子节点比较，如果大于就交换，再与右边子节点比较，大于就交换
	// 这样就做到最小的节点为父节点，大的为子节点
    siftDown(index) {
    let element = index; 
    // 获取最开始节点的左右节点索引
    const left = this.getLeftIndex(index); 
    const right = this.getRightIndex(index); 
    const size = this.size();
        // 先与左节点比较，条件是不超过数组长度，并比左节点大，就交换
    if (
        left < size &&
        this.compareFn(this.heap[element], this.heap[left]) ===
        Compare.bigger
    ) {
        element = left;
        //如果大， element 改变了
    }
    if (
        //上面最新的element 与 右边进行对比
        right < size &&
        this.compareFn(this.heap[element], this.heap[right]) ===
        Compare.bigger
    ) {
        element = right;
    }
        // 如果这一通操作下来索引发生改变，就将索引对应的值也进行交换，并接着调用进行递归
        // 如果两次对比索引值不变（父节点比子节点都小），就推出递归
    if (index !== element) {
        swap(this.heap, index, element);
        this.siftDown(element);
    }
}

}

// 交换函数，传入数组是传入引用，所以内部交换外部也跟着交换
function swap(array, a, b) {
    const temp = array[a];
    array[a] = array[b];
    array[b] = temp;
}

var heap = new MinHeap()
```

##### 2. 最大堆

```js
// 把比较大小的函数小于号改为大于号，就能得到最大堆。所有逻辑都相同，只有比较时条件相反
class MaxHeap extends MinHeap {
    constructor() {
        super();
    }

    compareFn(a, b) {
        if (a === b) {
            return Compare.equ
        }
        return a > b ? Compare.less : Compare.bigger
    }
}

```







#### 十. 排序算法

##### 1. 冒泡排序

> 冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至 正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。

```js
function bubbleSort(array) {
    const {
        length
    } = array;
    for (let i = 0; i < length; i++) {
        for (let j = 0; j < length - 1; j++) {
            if (array[j] > array[j + 1]) {
                swap(array, j, j + 1);
            }
        }
    }
    return array;
}

function swap(array, a, b) {
    const temp = array[a];
    array[a] = array[b];
    array[b] = temp;
}
```



##### 2. 选择排序

> 选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并 将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。
>
> 先设置最小值为第0位，然后向后逐渐比较，遇到比最小值更小的就将索引赋值到最小值，直到最后最小值为真正的最小值
>
> 然后将最小值与第0位交换，并从第1位开始继续这个过程

```js
function selectionSort(array) {
    const {
        length
    } = array;
    let indexMin;
    for (let i = 0; i < length - 1; i++) {
        indexMin = i;
        for (let j = i; j < length; j++) {
            if (array[indexMin] > array[j]) {
                indexMin = j;
            }
        }
        if (i !== indexMin) {
            swap(array, i, indexMin);
        }
    }
    return array;
};
```



##### 3. 插入排序

> 插入排序每次排一个数组项，以此方式构建最后的排序数组。
>
> 从第二个元素开始对数组进行遍历，每次遍历的元素与前边的元素进行比较，插入到合适的位置

```js
function insertionSort(array) {
    const {
        length
    } = array;
    let temp;	// 定义temp变量来临时存储遍历到的元素值
    for (let i = 1; i < length; i++) {	// 开始遍历
        let j = i;	// 定义j变量来临时存储遍历到的索引
        temp = array[i];	// 存储数组元素
        while (j > 0 && array[j - 1] > temp) {	// 对之前的元素进行遍历，从后往前遍历，直到不再小于前一元素或到第零个元素就停止
            array[j] = array[j - 1];
            j--;
        }
        // 将元素插入到对应位置
        array[j] = temp;
    }
    return array;
};
```



##### 4. 归并排序

> 归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只 有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。

<img src="%E7%AC%94%E8%AE%B0.assets/image-20221209111002284.png" alt="image-20221209111002284" style="zoom:67%;" />



```js
// 归并排序
// 将大数组一分为二分为小数组，通过递归分下去直到每个数组只有一个元素
function mergeSort(array) {
    if (array.length > 1) { 
        const {
            length
        } = array;
        const middle = Math.floor(length / 2); 	// 先取得中间界限
        const left = mergeSort(array.slice(0, middle)); // left数组
        const right = mergeSort(array.slice(middle, length)); // right数组
        array = merge(left, right); // 通过merge函数将所有数组都按顺序合并起来
    }
    return array;
}

// merge函数
function merge(left, right ) {
    let i = 0;	// left和right的变量
    let j = 0;
    const result = [];	// 合并的函数
    while (i < left.length && j < right.length) { // 遍历，条件是left和right数组都没有遍历到最后
        result.push(
            left[i] < right[j] ? left[i++] : right[j++]	// 对比两个数组的元素，哪个小就添加哪个。添加之后相应的索引向后移一位
        ); 
        console.log(result)
        //先push ，再++
    }
    // 遍历到最后会剩下一个元素，判断出来哪个变量没有遍历到最后，通过concat合并上该元素即可
    return result.concat(i < left.length ? left.slice(i) : right.slice(j)); 
}
```



##### 5. 快速排序

>快速排序的原理是：数组先取一个基准值，然后按照大于或小于基准值分成两个数组。递归这个过程，最后分成都是单个元素的数组，其内部的元素是按照顺序排列的。将这些数组结合起来，就是一个按顺序排列的数组



```js
function quickSort(arr){
    const {length} = arr
    // 出口是数组长度为一，即只有一个元素。返回数组
    if(length<2){
        return arr
    }

    let base = arr[0]	// 基准值为第0位
    // 分成大小两个数组
    let min = arr.slice(1).filter(item=>item<=base)
    let max = arr.slice(1).filter(item=>item>base)
	
    // 对数字接着遍历，直至所有数组只有一个元素，将其结合起来就是整个数组
    return quickSort(min).concat([base]).concat(quickSort(max))
}
```



##### 6. 计数排序

> 计数排序使用一个用来存储每个元素在原始 数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序 后的结果数组。

```js
function countingSort(array) {
    if (array.length < 2) { 
        return array;
    }
    const maxValue = findMaxValue(array);
    const counts = new Array(maxValue + 1); 
    array.forEach(element => {
        if (!counts[element]) { 
            counts[element] = 0;
        }
        counts[element]++; 
    });
    let sortedIndex = 0;
    counts.forEach((count, i) => {
        while (count > 0) { 
            array[sortedIndex++] = i; 
            count--; 
        }
    });
    return array;
}

function findMaxValue(array) {
    let max = array[0];
    for (let i = 1; i < array.length; i++) {
        if (array[i] > max) {
            max = array[i];
        }
    }
    return max;
}

countingSort([5,7,4,9,1])
```



##### 7.  桶排序

> 桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组）， 再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行 排序。然后，它将所有的桶合并为结果数组。

![image-20221213091612715](%E7%AC%94%E8%AE%B0.assets/image-20221213091612715.png)

````js
function insertSort(arr) {
    const {
        length
    } = arr
    let temp; //存 当前这一轮对应索引的元素值
    for (let i = 1; i < length; i++) {
        temp = arr[i]
        let j = i;
        while (j > 0 && arr[j - 1] > temp) {
            arr[j] = arr[j - 1]
            j--
        }

        arr[j] = temp
    }

    console.log(arr)
}

function bucketSort(array, bucketSize = 3) { 
    if (array.length < 2) {
        return array;
    }
    const buckets = createBuckets(array, bucketSize); 
    //分桶装
    return sortBuckets(buckets); 
}

function createBuckets(array, bucketSize) {
    let minValue = array[0];
    let maxValue = array[0];
    for (let i = 1; i < array.length; i++) { 
        if (array[i] < minValue) {
            minValue = array[i];
        } else if (array[i] > maxValue) {
            maxValue = array[i];
        }
    }//一次循环找到最小最大值
    const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; // 最后一个索引+1
    const buckets = [];
    for (let i = 0; i < bucketCount; i++) {
        buckets[i] = [];
    }
    for (let i = 0; i < array.length; i++) { 
        const bucketIndex = Math.floor((array[i] - minValue) / bucketSize); 
        buckets[bucketIndex].push(array[i]);
    }
    return buckets;
}

function sortBuckets(buckets) {
    const sortedArray = []; 
    for (let i = 0; i < buckets.length; i++) { 
        if (buckets[i] != null) {
            insertSort(buckets[i]); 
            sortedArray.push(...buckets[i]); 
        }
    }
    return sortedArray;
}

bucketSort([5,4,3,2,6,1,7,10,9,8])
````



##### 8. 基数排序

> 基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排 序）将整数分布到桶中。基数是基于数组中值的记数制的。

```js
const arr = [35, 2, 26, 2, 5, 8, 34, 1, 56, 99, 33];
const radixSort = (arr = []) => {
    const base = 10;
    let divider = 1;
    let maxVal = 0;
    while (divider === 1 || divider <= maxVal) {
        const buckets = [...Array(10)].map(() => []);
        for (let val of arr) {
            buckets[Math.floor((val / divider) % base)].push(val);
            maxVal = val > maxVal ? val : maxVal;
        }

        arr = [].concat(...buckets);

        console.log(arr)
        divider *= base;
    };
    return arr;
};
```



#### 十一. 搜索算法



##### 1. 顺序搜索

> 顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找 的元素做比较。顺序搜索是最低效的一种搜索算法。

```js
function sequentialSearch(array, value) {
    for (let i = 0; i < array.length; i++) {
        if (value===array[i]) { 
            return i;
        }
    }
    return -1
}

sequentialSearch([3,2,1],2)
```



##### 2.二分搜索

先对数组进行排序，然后中间值与搜索值进行比较，判断位于哪边。然后再重复这一过程，直到找到具体位置

<img src="%E7%AC%94%E8%AE%B0.assets/image-20221214083405056.png" alt="image-20221214083405056" style="zoom:80%;float:left;" />

```js
var Arr = [5, 7, 4, 2, 9];

// 二分查找接收参数：查找值，数组，起始值（默认为数组首个元素），结束值（默认为数组最后一个元素）
function binarySearch(find, arr, low, high) {
    arr = quickSort(arr);	// 先排序
    if (low <= high) {	
        if (arr[low] == find) {	// 如果起始值就等于查找值，直接返回
            return low;
        }
        if (arr[high] == find) {// 同理直接返回结束值
            return high;
        }
        var mid = Math.ceil((high + low) / 2);	// 取得中间值
        if (arr[mid] == find) {	// 同理直接返回中间值
            return mid;
        } else if (arr[mid] > find) {	// 如果查找值比中间值大，就接着调用，结束值变为中间值-1
            return binarySearch(find, arr, low, mid - 1);
        } else {
            return binarySearch(find, arr, mid + 1, high);	// 如果比中间值小，起始值变为中间值+1
        }
    }
    return -1;	// 如果没有就返回-1
}
binarySearch(9, Arr, 0, Arr.length - 1)
```





##### 3.内插搜索

> 内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根 据要搜索的值检查数组中的不同地方。

<img src="%E7%AC%94%E8%AE%B0.assets/image-20221214090414035.png" alt="image-20221214090414035" style="zoom:80%;float:left;" />

```js
var arr = [5, 7, 4, 2, 9];

function InsertionSearch(arr, val, start, end) {
    arr = quickSort(arr);
    var end = end || arr.length - 1;
    var start = start || 0;

    if (start <= end && val>=arr[start] && val<=arr[end]) {
        // 通过这个公式能推出查找值的大致位置
        var mid = start + Math.floor((val - arr[start]) / (arr[end] - arr[start]) * (end - start))
        if (arr[mid] == val) {
            return mid;
        }

		// 如果没有就调整精度
        if (arr[mid] > val) {
            return InsertionSearch(arr, val, start, mid - 1);
        } else {
            return InsertionSearch(arr, val, mid + 1, end);
        }
    }

    return -1
}

InsertionSearch(arr, 2)
```





#### 十二. 随机算法

> 迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位 置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次

```js
function shuffle(array) {
 for (let i = array.length - 1; i > 0; i--) {
 const randomIndex = Math.floor(Math.random() * (i + 1));
 swap(array, i, randomIndex);
 }
 return array;
} 
```



#### 十三.算法设计

##### 1.分而治之

> 分而 治之是算法设计中的一种方法。它将一个问题分成多个和原问题相似的小问题，递归解决小问题， 再将解决方式合并以解决原来的问题。

分而治之算法可以分成三个部分。

 (1) 分解原问题为多个子问题（原问题的多个小实例）。 

 (2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子 问题。

 (3) 组合这些子问题的解决方式，得到原问题的解。



##### 2.动态规划

> 动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优 化技术。

用动态规划解决问题时，要遵循三个重要步骤：

 (1) 定义子问题；

 (2) 实现要反复执行来解决子问题的部分； 

(3) 识别并求解出基线条件。



###### 2-1 背包问题

> 背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背 包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。

<img src="%E7%AC%94%E8%AE%B0.assets/image-20221220150040895.png" alt="image-20221220150040895" style="zoom:67%;float:left;" />

<img src="%E7%AC%94%E8%AE%B0.assets/image-20221220154547224.png" alt="image-20221220154547224" style="zoom:67%;float:left;" />

```js
function knapSack(weights, values, W) {
    var n = weights.length;
    var f = new Array(n)
    f[-1] = new Array(W + 1).fill(0)//第-1个物品，
    //负一行的出现可以大大减少了在双层循环的分支判定。
    // console.log(f)
    for (var i = 0; i < n; i++) { 
        f[i] = new Array(W).fill(0)
        for (var j = 0; j <= W; j++) { 
            if (j < weights[i]) { 
                f[i][j] = f[i - 1][j]
            } else {
                f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - weights[i]] + values[i]); //case 3
            }//即使i = 0 也不怕，i-1 为-1 有-1行不怕
        }
    }
    return f[n - 1][W]
}
```





###### 2-2 最长公共子序列

> 找出两个字符 串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求 连续（非字符串子串）的字符串序列。

<img src="%E7%AC%94%E8%AE%B0.assets/image-20221221131801017.png" alt="image-20221221131801017" style="zoom:67%;float:left" />

<img src="%E7%AC%94%E8%AE%B0.assets/image-20221221131809239.png" alt="image-20221221131809239" style="zoom:67%;float:left" />

```js
function LCS(str1, str2) {
    var m = str1.length
    var n = str2.length
    var dp = [new Array(n + 1).fill(0)] //第一行全是0
    for (var i = 1; i <= m; i++) { //一共有m+1行
        dp[i] = [0] //第一列全是0
        for (var j = 1; j <= n; j++) { //一共有n+1列
            if (str1[i - 1] === str2[j - 1]) {
                //注意这里，str1的第一个字符是在第二列中，因此要减1，str2同理
                dp[i][j] = dp[i - 1][j - 1] + 1 //对角＋1
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
            }
        }
    }
    return dp[m][n];
}
console.log(LCS("abcadf", "acbaed"))
```





##### 3. 贪心算法

> 在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。



<img src="%E7%AC%94%E8%AE%B0.assets/image-20221226122030597.png" alt="image-20221226122030597" style="zoom:50%;float:left" />

<img src="%E7%AC%94%E8%AE%B0.assets/image-20221226122115470.png" alt="image-20221226122115470" style="zoom: 50%;float:left;" />

```js
function tanx(capacity, weights, values) {
    var list = [];
    for (var i = 0, len = weights.length; i < len; i++) {
        list.push({
            num: i + 1, //第几件商品
            w: weights[i], //重量
            v: values[i],
            rate: values[i] / weights[i]
        });
    }

    list.sort(function (a, b) {
        return b.rate-a.rate
    });
    // console.log(list)

    var selects = [];
    var total = 0;
    for (var i = 0, len = list.length; i < len; i++) {
        var item = list[i];

        if (item['w'] <= capacity) {
            selects.push({
                num: item.num,
                rate: 1, //完整的商品记录为1
                v: item.v,
                w: item.w
            });

            total = total + item.v;
            capacity = capacity - item.w;
        } else if (capacity > 0) {
            //选取不完整的商品
            var rate = capacity / item['w'];
            var v = item.v * rate;
            selects.push({
                num: item.num,
                rate: rate,
                v: item.v * rate,
                w: item.w * rate
            });
            total = total + v;
            break;
        } else {
            break;
        }
    }

    return {
        selects,
        total
    }
}

```

##### 4.回溯算法

> 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。

**题目**

> 给定一个 二维字符网格 board 和一个字符串单词 word
>  如果 word 存在于网格中，返回 true ；否则，返回 false
>  单词必须按照字母顺序，通过相邻的单元格内的字母构成
>  **二维数组：** board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]],
>  **目标：** word = "ABCCED"

<img src="%E7%AC%94%E8%AE%B0.assets/image-20221227114058124.png" alt="image-20221227114058124" style="zoom:50%;float:left;" />

```js
function exist(board, word) {
    let row = board.length;
    let col = board[0].length;

    for (let i = 0; i < row; i++) {
        for (let j = 0; j < col; j++) {
            const ret = find(i, j, 0); 
            if (ret) {
                return ret;
            }
        }
    }
    return false;

    function find(r, c, cur) {
        if (r >= row || r < 0) return false;
        if (c >= col || c < 0) return false;
        if (board[r][c] !== word[cur]) return false;
        if (cur == word.length - 1) return true;

        let letter = board[r][c]; 
        board[r][c] = null; 

        const ret =
              find(r - 1, c, cur + 1) ||
              find(r + 1, c, cur + 1) ||
              find(r, c - 1, cur + 1) ||
              find(r, c + 1, cur + 1);
        //用null做标记是避免重复查找
        board[r][c] = letter;
        return ret;
    }
};
```





#### 十四. 算法复杂度

> O 表示法用于描述算法的性能和复杂程 度。O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。

![image-20221227120714635](%E7%AC%94%E8%AE%B0.assets/image-20221227120714635.png)

1. **O(1)**

```js
function inc(n){
 	return ++n;
}
```

2. **O(n)**

```js
function search(arr,value){
    for(let i =0;i<arr.length;i++){
        if(arr[i]===value){
            return i
        }
    }
    return -1
}
```

3. **O(n2 )** 

```js
function bubbleSort(array) {
    const {
        length
    } = array
    for (let i = 0; i < length; i++) {
        for (let j = 0; j < length - 1-i; j++) {
            if (array[j] > array[j + 1]) {
                //交换位置的方法
                swap(array,j,j+1)
            }
        }
    }
    console.log(array)
}
```



![image-20221227122353023](%E7%AC%94%E8%AE%B0.assets/image-20221227122353023.png)

![image-20221227122417170](%E7%AC%94%E8%AE%B0.assets/image-20221227122417170.png)