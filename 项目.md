# 面试准备

## 1、自我介绍

​	面试官您好，我是王本硕，来自西安邮电大学。我在大一加入了学校的一个软件实验室，了解各个方向后，结合兴趣选择了前端方向进行学习。我先学习了html，css和js，然后选择了React框架并学习了相关知识。学完React后，我与实验室同学合作，作为前端开发负责人，一起协作开发了宅宿甄选项目，项目参加过挑战者杯、互联网加等比赛，获得了不错的名次。上学期我在杭州心识宇宙有限公司进行了一段实习，在其中我参与开发了核心项目 搭档型个人专属AI Mebot 的web端开发，在项目中独立负责开发了代言功能与好友社交模块，并完成了文件上传等若干功能模块的开发，此外还封装了比如说懒加载组件和图片裁剪上传hook等多种组件和hook，在项目中得到广泛使用。这段实习使我进一步提升了自己的代码能力，学习了许多新技术，熟悉了企业中实际开发项目的大致流程。我热爱前端开发，喜欢结合文档钻研问题，了解前端发展新动向。以上就是我的自我介绍，谢谢面试官。

## 2、实习介绍

#### 	项目背景

​	在这段实习里我参与的是我们公司的核心项目Mebot的Web端开发。Mebot是一种搭档型个人专属AI，它最大的特点就是针对不同用户的个性化与独特性。用户可以通过对话交流，或者是导入文件，图片，网页甚至是自己的社交账号等等，来为Mebot注入属于用户自己的独特记忆。和Mebot交流时，它会先进行记忆召回，也就是从所有存储的记忆中查找汇总和话题有关的记忆，结合这些记忆，从用户的角度来进行回复。比起现在常见的AI助手，它更像是一个用户专属的AI搭档，可以作为用户的第二大脑来出谋划策，也可以提供情绪价值为用户排忧解难，或者说可以帮用户进行各种记录。所以Mebot的定位是这样一种搭档型个人专属AI。



#### 实习内容

​	以上是项目背景，然后我给您介绍一下我的实习内容。我负责开发了项目的代言功能和好友社交功能。我先介绍一下代言功能吧，在代言功能中，用户可以通过Mebot为自己生成代言，让Mebot以用户的口吻来对某个话题进行探讨。比如说用户向Mebot发起话题，探讨一下AI的发展，那么跳转到代言创建页面后，Mebot就先去搜索汇总用户存储的与话题相关的记忆，然后以**流式输出**结合**Markdown格式渲染**的形式，生成针对话题的叙述，再生成对应的几张幻灯片，最后生成一个针对这一话题的视频。像这些叙述内容，以及幻灯片的图片URL，标题，简介等等都是通过**SSE通信**的方式接收的。代言创建成功之后，用户就可以点击复制链接将代言分享出去，也可以对代言的文本、图片、音频、视频进行**多种格式的下载**。在分享页中，用户可以播放视频，对于播放的音频实现了**可视化**，以体现用户“正在说话”的效果。此外我在项目中还借助**antd**的**Upload**组件实现了多种格式的**文件上传**功能，对于**大文件上传**也进行了专门处理。这是代言功能，对于好友社交功能，Mebot为用户提供专属的路径作为个人主页，用于展示用户头像，简介，个人的Mebot和代言等内容，用户在编辑页面也可以对路径和要展示的内容进行设置。访问其他用户的个人主页时，可以与他的个人Mebot进行交流，并播放他的代言视频，来对他进行一个初步的了解。感兴趣的话就可以申请添加好友，进行进一步的交流。除此之外，为了优化代码逻辑，提升代码效率，我还**封装了多个hook和组件**，hook的话比如多格式下载的**useDownload**，上传裁剪图片的**useImgCropper**，用于状态管理的**useStorage**；组件的话比如说**懒加载组件**和记忆Modal组件等等。这些组件和hook很多都在项目中得到了广泛的**复用**。本次实习也让我对于git版本管理的指令更加熟悉，对实际企业中的开发流程更加了解，并进一步提升了自己的代码能力。以上就是我这一段实习的大致内容。



## 3、项目介绍

​	（1）宅宿甄选·酒店民宿甄选平台

​	宅宿甄选平台致力于解决旅游或商务出行人士的住宿选择问题。项目集成了多家住宿平台优质酒店民宿资源，在项目首页中用户可以选择目的城市，然后通过热门、低价、高分等模块向用户展示该城市的优质房源。用户在首页点击更多房源链接，就可以跳转到全部房源页面。这个页面通过**虚拟滚动列表+懒加载**方式向用户推荐目的城市的海量房源，通过**WebSocket**实现AI助手功能，帮助用户推荐合适的房源，依靠**模糊查询**结合**防抖函数**给用户提供搜索功能，并尝试使用了**React19新API useActionState**优化表单提交过程。还拥有对价格和评分的排序功能。在全部房源页面点击任意一个房源，就可以进入该房源的详情页面。页面中集成了该房源在多家住宿平台的详细信息，如图片、价格、评分、热门评论等。在具体页面中，项目封装了**PictureBrowser**组件，为用户提供了沉浸浏览房源图片的功能。用户如果有心仪的酒店，就可以点击链接跳转到合适的平台进行购买。项目中使用了**路由懒加载**、**图片懒加载**、**React.memo**等方式进行性能优化，大幅提升首屏加载速度。项目使用**axios**进行前后端数据交互，并对axios进行了**二次封装**。未来项目希望结合**媒体查询与rem和Flex布局**实现**响应式布局**。

​	（2）记一笔·简易记账平台

​	记一笔记账平台是我结合React课程实现的一个简易记账平台。用户登陆平台后，可在首页选择日期（通过**AntDesign** 中的 **DatePicker 组件**）查看自己的过往账单，也可在记账页面根据消费类别记录新的收入或支出，还通过**Echarts**实现了一个统计页面，收入支出数据与账单分类数据进行展示。项目还提供了账单收藏功能，通过localStorage进行保存。项目使用了**React-Router** 的**数据路由**进行路由配置，实现了路由集中式配置与管理。

# 实习

## 1、SSE通信

### （1）项目中SSE简单介绍

​	代言功能通过Server-Sent Events (SSE) 实现实时通信，当用户创建代言任务时，前端先通过post将用户的话题和选择的记忆发送给后端，后端返回本次代言对应的id。然后跳转到创建页面，前端建立与服务器的SSE连接，监听多种事件类型，（如记忆召回、叙述生成、幻灯片生成、输出完成等等），并给每一种事件建立对应的事件处理机制。服务器会实时推送各种生成内容，前端接收到对应的事件后，通过对应事件的处理逻辑来更新UI状态，当任务完成时也会收到相应的结束信号，出错时也有对应的处理机制。整个过程为用户提供了流畅的实时生成体验。



### （2）项目中创建SSE连接的大致流程

#### 首先是发送用户输入内容

​	首先把用户输入的内容，以及用户手动选择的记忆对应的id通过post发送给后端，后端接收到后会返回本次代言对应的id，前端成功接收到id后，跳转到对应的创建页面。

#### 然后在创建页面建立SSE连接

​	SSE连接是通过浏览器原生的 `EventSource` 这个API来实现的。在项目中通过useRef来存储eventSource，每次创建SSE连接都先将上一次的SSE连接通过close关闭掉并重置ref，接着构建包含本次代言id的单独的url，通过url new一个EventSource对象存储到ref中，这样就创建好连接了。然后要对SSE事件进行监听并建立对应的处理机制。连接建立后服务器开始推送消息，标准事件的话会触发onMessage事件，但项目中我们通过自定义事件，规定了每一种事件并建立的对应的处理机制，后端推送的消息也会触发对应的事件，所以onMessage事件只负责一些兜底的处理。对于自定义事件的触发，按顺序来讲，首先会触发记忆召回事件，后端将汇总到的与话题相关的所有记忆的id返回，前端将找到了多少记忆渲染到页面上，用户点击可以弹出记忆Modal查看具体是哪些记忆。然后会触发叙述事件，叙述事件分为start、chat、end三种类型。start类型代表这段叙述内容开始推送，在回调中清空用来存储的状态变量，以避免上一次的生成影响（如果问起，编辑后可以重新生成）。然后接收到chat类型叙述事件，代表AI正在**输出叙述内容的分片**，将这个内容分片**追加**到当前存储内容里并重新渲染到页面上。最后收到end类型就代表本次代言叙述内容已经全部输出完毕。叙述事件结束后，会触发幻灯片事件。由于图片的生成需要一定的时间，所以幻灯片事件会先返回预估的生成时间，在前端设置一个计时器，并通过占位图的形式先填充幻灯片。当下一次的幻灯片事件返回了图片URL后，再将图片渲染到幻灯片里边。最后触发结束事件，代表后端对应的视频已经生成完毕，返回视频的封面和标题，前端成功接收后渲染到页面中，点击就可以跳转到对应的分享页来播放视频。



### （3）SSE的简单介绍

​	SSE（Server-Sent Events，服务器推送事件）是一种基于 HTTP 协议的**轻量级实时通信技术**，核心作用是让服务器能主动、持续地向客户端推送数据，而无需客户端频繁发起请求（避免 “轮询” 的资源浪费）。

它的核心特点可总结为 3 点：

1. **单向通信**：仅支持服务器→客户端的单向数据传输，客户端若需向服务器发数据，需额外用 HTTP 请求（如 POST）；
2. **基于 HTTP 长连接**：无需像 WebSocket 那样做 “协议升级”，只需通过一次 HTTP 请求建立长连接，连接建立后保持打开状态，服务器随时可推送数据；
3. **轻量易实现**：数据格式遵循简单规范（文本流，包含 “事件类型”“数据内容” 等标识），客户端只需通过浏览器原生的 `EventSource` API 即可监听，开发成本低。

常见适用场景：实时通知（如系统提醒）、数据实时更新（如股价、天气、新闻推送）、日志 / 监控数据实时展示等（只需服务器单向推数据的场景）。



### （4）SSE连接建立的大致原理

​	具体连接建立过程可简化为三步：首先，客户端通过普通 HTTP 请求（通常是 GET 方法）发起 “建立 SSE 连接” 的请求，并在请求头中携带关键标识 —— 比如 `Accept: text/event-stream`（告知服务器 “我要接收 SSE 格式的流式数据”）、`Connection: keep-alive`（告知服务器 “不要断开这个连接，保持长连接状态”）；其次，服务器收到请求后，若支持 SSE，会返回特殊的 HTTP 响应：响应状态码通常为 200（表示请求成功），响应头中会明确标注 `Content-Type: text/event-stream`（确认传输的数据格式为 SSE 规范格式）、`Cache-Control: no-cache`（禁止缓存推送的数据，确保客户端收到实时数据），同时也会用 `Connection: keep-alive` 呼应客户端，确认保持长连接；最后，当客户端收到这样的响应后，就知道连接已成功建立，会维持这个 HTTP 连接不关闭，此后服务器无需等待客户端再次请求，可随时通过这个长连接向客户端推送符合 SSE 格式的数据（比如带 “事件类型”“数据内容” 的文本流），客户端则会持续监听这个连接的数据流，一旦收到服务器推送的内容，就触发预设的回调函数进行处理（比如更新页面内容、展示实时消息等）。整个过程中，连接始终是基于 HTTP 的单向长连接，无需像 WebSocket 那样做 “协议升级”，实现逻辑更轻量，更适合只需服务器向客户端单向推送数据的场景（如实时通知、股价更新、新闻推送等）。



### （5）错误处理及重连机制

​	当前代言功能的错误处理，一种情况是后端返回的error事件，代表业务错误，但传输是正常的。对于这种错误会这里会展示错误提示、记录错误、针对特定subCode（比如已经生成）跳转到分享页面。另一种情况是onerror事件，代表传输发送错误。对于这种错误进行处理，通过close来关闭连接，并清除ref。

​	（如果问起重连机制）项目中不存在重连机制，但对于重连机制的话我也有大致了解。

​	当SSE连接发生错误时会触发error事件，在这时前端会尝试进行重连。首先EventSource的onError事件本身具有重连机制，但是这个重连是没有上限的，所以最好还是要手动设置重连机制。具体的过程就是，先再外部确定好最大重连次数5次，重连间隔时间3秒。如果发生错误时，达到重连间隔时间就会重新调用连接函数，并将重连次数+1。到最后如果重连次数超过最大重连连接次数就不再继续尝试，触发close事件关闭SSE连接，并给用户弹出错误信息。



​	**（不主动说）如果问起重连后如何处理错误期间生成的内容**

​	当进行重连后，在onopen事件里发起一次请求，把之前所有后端生成的内容都重新获取一遍，覆盖到当前的state里渲染到页面上。之后就是正常的监听事件并处理。



### （6）为什么选择SSE而不是其他通信方式（与轮询，WebSocket相比）

#### 和轮询相比

轮询原理：客户端以固定的时间间隔持续不断的向服务器发送一次 HTTP 请求，询问服务器是否有新数据。如果服务器有新数据，则在响应中返回；否则返回空或状态标示客户端继续下一次轮询。

与SSE相比，轮询的缺点首先就是不够实时。通过SSE通信，服务器产生新内容就马上推送客户端，中间不会耽误时间，更适合这种打字机式的实时流式输出的效果。而对于轮询，它是有一个固定的时间间隔的，可能内容早就生成好了，但还是需要等待下一次请求的到了，无法实现真正的实时输出。其次的话，轮询本身需要不断重复的发起请求，这种重复行为会消耗很多服务器资源，而且这种请求是没有目的性的，并不是说生成了数据再去请求，很多时候请求下来它可能是没有结果的，是无效的。这样本来请求就会消耗资源，还有可能什么也没得到，显得就比较浪费。使用SSE通信的话，建立一次持久连接后，服务器可以在有新数据时主动推送给客户端，不需要客户端频繁发起请求，这样就大幅减少了资源消耗和无效的通信。



#### 和WebSocket相比 

主要是根据实际的需求决定的。

WebSocket原理：WebSocket是一种全双工通信的协议，它和SSE一样都是建立连接后保持通道的长连接，WebSocket可以实现客户端和服务器彼此主动发送消息，是一种实时通信方式。

不过对于代言功能的话，用户只需要发送一个话题，剩下的所有生成内容，包括记忆找回、叙述内容、幻灯片等等都是由服务器发送给前端的，用户并不需要给服务器发送什么其他内容，所以使用WebSocket就显得比较大材小用。WebSocket是专门为了实现双向通信的，但这个需求只需要从服务器到客户端单向实时推送消息就可以了，所以SSE这种单向通信，由服务器主动推送消息到客户端的通信方式就比较适合。



如果问更多和WebSocket相比：

- WebSocket 的连接、心跳、断线重连、资源管理……这套机制确实强大，但同时也让开发复杂度和服务器资源占用都提高了不少



## 2、流式输出

### （1）简单介绍

​	在代言创建页面的叙述过程，ai是通过流式输出的形式进行回复的，可以让用户体验到ai边生成边输出的效果。所谓流式输出就是服务器在数据还没有未全部准备好时，就将生成的部分内容分片不断推送给客户端，客户端接收到一段就立刻渲染，不需要等待服务端完整的输出结果。在我们这个项目中流式输出的实现，具体来讲就是服务器与前端之间，采用SSE由服务端主动推送消息的通信形式，让服务器生成每段消息分片都实时推送给前端，前端监听自定义的叙述事件，每次接收到后端推送来的消息分片，就把它追加到当前 AI 回复的消息中，从而实现了用户能实时看到ai边生成边输出的效果。

### （2）详细讲讲如何接收到消息并渲染到页面上的

​	前端对SSE自定义的叙述事件进行监听，返回的**event**点**data**里存在消息type，根据type判断不同的返回的消息类型并进行不同的处理。与流式输出有关的有**start**、**chat**、**end**三种类型。当类型为**start**时，代表AI开始输出，重置state为空，准备**接收输出内容**。当类型为**chat**时，代表AI正在**输出内容的分片**，将这个内容分片**追加**到当前存储的内容里，重新渲染到页面上。当类型为end时，代表这个消息的结束。

### （3）流式输出是否有做防抖或节流来控制渲染频率

​	并没有做防抖或节流。首先，防抖或节流目的是为了**控制高频的操作**以**减轻性能压力**。而对于流式输出，每个内容分片大概几十毫秒返回一次，相对来说渲染的**性能压力并没有那么大**，而且流式输出以**用户体验**优先，追求AI“打字”效果最好越快越流畅，所以并没有进行防抖或节流，每次返回消息分片都**立即渲染**到页面上。







### （4）如何处理流式输出的停止

​	由于代言功能采用的是SSE的通信方式，所以前端无法主动发送消息去停止后端的生成，所以我们没有停止生成的机制，如果用户退出这个页面或者是直接关闭浏览器，服务端都会继续生成内容，只是前端不再进行接收。如果正在生成，在外部的代言列表中会显示生成中的占位符。生成完毕后就和其它代言一样渲染到代言列表中，可以进行分享和下载。

​	

### （5）如何处理输出时的加载效果

​	当ai的最新消息在渲染时，右下角会出现一个**闪烁的小圆点**代表正在加载。这个小圆点通过css动画实现闪烁效果，当监听message时，如果event.data.type为start或chat，代表ai回复开始或在进行中，就将控制小圆点显示的状态变量设置为true，吧小圆点动画渲染出来，从而实现了加载效果。

（如果问起样式写法）在开始结束都是opacity: 0，50%（即中间时）是opacity: 1，动画持续时长是1秒，无限重复播放。通过状态变量控制小圆点的**显示**和**位置**，保证其只在**ai输出时**显示，且只在**最新的回复**中显示。

### （6）markdown格式的渲染

​	在项目中，Mebot的输出内容支持markdown格式的渲染，从而可以实现**丰富的内容展示**，让用户能够一目了然地了解Mebot输出的内容。项目中使用了`react-markdown` 库来实现 Markdown 格式的渲染，支持标题、段落、列表等元素，并通过`remark-gfm` 插件实现了表格的渲染。使用时，通过`react-markdown` 库引入ReactMarkdown标签，被标签包裹的内容就会通过被渲染成markdown格式，标签的属性中有remarkPlugins={[remarkGfm]}，从而将`remark-gfm` 插件加入以实现表格的渲染。





### 弃用（7）思考内容如何渲染到页面上

​	与正式回复内容的流程基本相同，思考过程同样被看做是一条对话消息。是根据start，end，think三种类型来判断，当类型为**start**时，代表AI 开始输出，往chatData中push一个**新的消息对象**准备**接收输出内容**。当类型为**think**时，代表AI正在**输出思考内容的分片**，将这个内容分片**追加**到当前消息对象（通过id确定）的思考内容里并重新渲染到页面上。当类型为end时，代表这个消息的结束，启用发送按钮和重新生成按钮，禁用停止生成按钮。



## 3、hook与组件

### hook

#### （1）状态管理工具 useStorage

**简单介绍**：这是一个基于 React Context 的轻量级的状态管理Hook，适合快速在多组件间同步一些临时数据，不需要zustand实现完整的全局状态存储的情景。通过 Provider 为需要共享状态的组件提供发布-订阅的机制，被包裹的组件用 useStorage() 读取存储的状态，并获得set更新状态的方法，更新会同步推送到所有订阅该这个状态的组件。useStorage支持函数式更新与变更去重（仅在新旧值不等时向所有组件发布）。

- 怎么用:

​	用 UseStorageProvider 包裹需要共享状态管理的组件。

​	组件里调用 const [value, setValue] = useStorage('some-key')。

​	任意地方 setValue() 会触发 Provider 包裹下订阅了相同 key 的所有组件同步更新。

**原理介绍**：首先定义了 StoreEmitter 这个用来管理状态的类，并且设置了订阅、取消订阅、状态更新和状态获取这几种方法。然后通过createContext来创建 StoreEmitter实例的context上下文，再用context.Provider包裹子组件，让每个子组件都能访问到同一个 StoreEmitter 实例。然后是通过useContext得到实例，调用get方法得到管理的状态并注册订阅。在hook中设置set方法来实现状态更新，更新时进行比较，新旧值如果不同再调用方法推送到所有订阅的组件中。最后将状态和对应的set方法return，从而能够暴漏给外部使用。



**存储机制的解释**：

1. **双重 Map 架构设计**

这个存储系统采用了两个 Map 的分离设计。第一个 Map 专门负责数据存储，第二个 Map 负责管理事件监听器。这种分离的好处是数据存储和事件管理互不干扰，可以独立优化。

数据存储 Map 使用字符串作为 key，这样可以支持任意命名的存储键，比如 'userInfo'、'theme'、'cartItems' 等。值可以是任意类型，提供了极大的灵活性。

事件监听器 Map 的 key 与数据存储的 key 一一对应，但值是一个 Set 集合，里面存放着所有需要响应这个 key 变化的组件状态更新函数。使用 Set 而不是数组，可以自动去重，避免同一个组件被重复注册。

**2. 发布-订阅模式的实现**

当组件调用 useStorage 时，实际上是在订阅特定 key 的数据变化。组件将自己的状态更新函数注册到事件系统中，这样当数据发生变化时，所有相关的组件都能收到通知。

on 方法负责注册监听器。它会检查是否已经存在该 key 的事件集合，如果存在就直接添加新的监听器，如果不存在就创建一个新的 Set 并添加监听器。这种设计确保了即使多个组件同时使用相同的 key，也能正确管理所有监听器。

off 方法负责取消监听。它不仅会移除指定的监听器，还会检查事件集合是否为空。如果为空，就会删除整个 key 的事件记录，这样可以避免内存泄漏。但注意，它只清理 events Map，不会清理 store Map 中的数据，这符合存储系统的持久化特性。

**3. 数据更新的精确控制**

emit 方法是整个系统的核心。它首先将新数据存储到 store Map 中，然后通知所有监听该 key 的组件。这里有个重要的设计细节：即使当前没有组件监听某个 key，数据仍然会被存储。这解决了异步场景下的数据一致性问题。

比如，一个异步请求完成后要更新数据，但此时组件可能已经卸载并取消了监听。如果系统只在有监听器时才存储数据，那么这个异步更新就会丢失。通过先存储再通知的设计，确保了数据的完整性。

**4. 组件生命周期的精确管理**

在 useStorage hook 中，useEffect 负责管理组件的订阅生命周期。组件挂载时注册监听器，卸载时取消监听。这种设计确保了内存不会泄漏，同时保证了数据的实时同步。

特别值得注意的是，在注册监听器后，代码会再次检查当前存储的值是否与组件状态一致。这是因为在组件初始化和注册监听器之间可能存在时间差，期间其他组件可能已经更新了数据。通过这个检查，确保了组件能获取到最新的数据。

**5. 函数式更新的支持**

setStorage 函数支持两种更新方式：直接传值和函数式更新。函数式更新允许基于当前值计算新值，这在处理复杂状态逻辑时非常有用。系统会先获取当前值，然后根据传入的参数类型决定是直接使用新值还是调用函数计算新值。

更新前还会进行值比较，只有值真正发生变化时才会触发存储和通知。这避免了不必要的重新渲染，提高了性能。





**应用场景**：比如项目中pc端和移动端样式不同，需要根据页面宽度进行切换，切换的临界点宽度就是由useStorage来存储的。在对应的hook中调用useStorage来存储临界点宽度并进行设置。在组件中需要使用到样式切换的组件都调用useStorage来获取到临界宽度。



##### **为什么有些地方要用 useStorage 而不是 Zustand：**

- 作用域隔离：useStorage 的状态是挂在 UseStorageProvider 的上下文里，天然按子树隔离，不会在页面之间“泄露”。非常适合在某个页面或弹窗内部件之间共享一些临时值。

- 轻量化无样板：API 与 useState 一致，返回 [value, setValue]，无需建全局 store、写 selector、中间件、类型样板，对一次性/临时场景上手成本低。虽然Zustand已经很轻量化了，但是还是每部分存储的状态都要去写对应的store文件来存储，并设置更新的方法。

- 按需订阅：内部用事件总线按 key 精确订阅，不会像把状态塞进一个大 store 那样引发无关组件的重渲染；且只有值变更时才广播：

- 子树可重复实例化：每个 Provider 会生成独立的 StoreEmitter，不同页面/模块互不干扰，适合这类局部“会话态”。 

- 处理卸载时序的安全性：即使监听还未绑定或组件已卸载，也会先写入 store，再通知现有订阅，避免竞态：

  

**什么时候优先用 useStorage**

- 页面/模块内的短生命周期 UI 状态：表单向导步骤数据、兄弟组件间临时共享、弹窗内部状态、创建流程缓存等。

- 不需要全局、持久化、时间旅行、跨路由共享 的场景。

**什么时候用 Zustand 更合适**

- 全局业务状态：用户信息、代言列表数据、权限、主题等需要跨页面共享。

- 需要中间件/生态：持久化、本地存储、devtools、异步流、选择器优化等。

- 复杂逻辑与派生状态：依赖 selector、计算属性、性能精细化订阅。



##### **和普通的context的区别**

**1.存储机制不同**

- 普通 Context: 数据存储在 React 的 Context 中，组件重新渲染时数据会丢失

- useStorage: 使用自定义的 StoreEmitter 类，把数据和状态存储起来，具有持久化特性

**2. 性能优化**

- 普通 Context: 当 Context 值变化时，所有消费该 Context 的组件都会重新渲染

- useStorage: 只有订阅特定 key 的组件才会更新，实现了更细粒度的更新控制



#### （2）图片裁剪上传 useImgCropper

这个hook对应的是图片的选择裁剪与上传功能。在个人主页设置、用户资料设置等场景都有使用，使用时只需要传入回调来接收上传后的 图片URL就可以。裁剪主要用到了第三方库react-cropper的Cropper来实现裁剪。文件选择Input和裁剪modal以及loading状态变量被暴露给外部进行使用。

**实现原理：**

​	hook中设置FileInput来实现文件选择，在input中规定accept属性只接受图片类型的文件，这样文件选择时只会筛选出图片文件给用户选择。文件选择后会触发onImgSelect函数，在函数中进行先判断文件类型是否符合要求，符合要求就创建FileReader对象来读取文件， 读取成功会触发onload事件，把文件的读取结果（这里是 Base64 编码的图片数据，通过result获取）存储起来，以供后续使用。最后更新状态打开裁剪Modal。

​	裁剪Modal中使用到了第三方库react-cropper的Cropper来实现裁剪功能，将存储的图片传入src，裁剪比例由aspectRatio设置，会根据不同的应用场景裁剪不同比例的图片。裁剪完成后点击确定，调用Modal onOk属性绑定的回调函数，先设置loading 为true，在通过cropper.getCroppedCanvas()来获得一个 Canvas DOM 元素，里面绘制的内容就是裁剪框内用户裁剪后的图像。通过toBlob把canvas导出的元素转换为二进制数据Blob对象，在新建文件对象，将blob包装成新的图片文件。然后调用项目中的上传方法，把图片文件传入进行上传。上传成功会返回裁剪后的图片URL，调用外部传入的回调把图片URL传出。最后关闭裁剪Modal，并设置Loading态为false。

**实际应用：**

​	在上传头像，上传背景之类的应用场景，调用useImgCropper，拿到文件选择input和裁剪Modal，以及loading状态。把input和外部展示的图片放在一个label里边，而因为nput的样式默认是hidden隐藏的，这样外部不需要显式的选择按钮，点击图片就可以触发Input的点击事件进行图片选择。并通过loading状态来设置加载时的样式。



**上传方法**

1. 获取上传凭证 - 调用后端 API 获取预签名 URL 或 Token
2. 文件处理 - 将文件转换为 ArrayBuffer
3. 直接上传 - 使用 fetch 直接上传到云存储
4. URL 转换 - 将云存储 URL 替换为 CDN 域名
5. 监控上报 - 记录上传耗时、文件大小等数据



#### （3）多格式下载 useDownload 

**介绍**

useDownload是一个封装多格式下载逻辑的 Hook，用于下载多种类型的代言内容，包括视频、文本、音频和图片。Hook对外暴露 handleDownloadShare 和下载状态downloading，在外部使用时调用 handleDownloadShare 将类型传入即可完成对应资源的下载。



**下载过程**：

​	在handleDownloadShare中先进行防抖判断，由于下载对于资源的消耗比较多，所以这里的防抖比较严格。因为异步更新并不是马上执行的，所以说除了下载状态判断，还要判断同步的ref锁是否为false。没问题的话，就将downloading和ref都设置为true。然后调取请求函数请求下载内容，包括文本、音频URL、图片URL以及文件名，如果是视频类型还要专门获取视频的URL。当然这些下载内容请求下来后都是会被保存的，只有第一次需要请求接口消耗一些时间，之后都会直接使用保存好的内容。获取下载内容后，就调用handleDownload函数，并把类型传入进行下载。在handleDownload函数中，会根据不同的类型进行不同的下载处理，不过原理都是差不多的。首先通过fetch将URL传入获取到数据，成功后转换成blob对象。对于文本这种没有URL的就直接把文本内容包装到一个blob对象里边。接下来创建一个A链接，把blob对象创建成一个URL再赋值给a链接，触发点击事件就能够实现下载。下载完成后，通过revokeObjectURL来清除URL释放内存。



**1. 引入库**

先安装或在页面引入，然后在代码里 `import { saveAs } from 'file-saver'`。
 目的：`saveAs` 是触发浏览器“另存为/下载”交互的简单 API，帮你跨浏览器处理细节（包括 IE 的 `msSaveBlob` 回退）。

**2. 获取要保存的二进制数据（Blob/ArrayBuffer）**

有三类常见来源：

- 浏览器直接生成：例如 `new Blob([...])`、`canvas.toBlob()`、或者把字符串/二进制拼接成 Blob。
- 通过网络请求拿到：使用 `fetch`（`.blob()` 或 `arrayBuffer()`）或 `axios`（`responseType: 'blob'`）。
- 本地 base64/dataURL：把 base64 解成二进制、再 `new Blob()`。

为什么要变成 Blob：浏览器下载文件的标准方式是把要保存的数据作为 Blob（或一个可下载的 URL）交给下载接口。

**3. 从响应头解析文件名（可选，但常用）**

当你通过网络拿到文件时，后端通常在 `Content-Disposition` header 里给出建议文件名（`attachment; filename="xxx"` 或 `filename*=UTF-8''...`）。
 做法：读取响应头（`res.headers.get('Content-Disposition')` / `xhr.getResponseHeader(...)` / `axios` 的 `res.headers`），解析出文件名；如果没有就用默认名。

注意：跨域时要后端返回 `Access-Control-Expose-Headers: Content-Disposition` 才能在浏览器读取该 header。

**4. 调用 `saveAs(blob, filename)` 触发下载**

把刚得到的 Blob 和文件名传给 `saveAs`。它会：

- 在大多数浏览器上创建临时对象 URL 并模拟 `<a download>` 点击，或
- 在 IE 上用 `msSaveOrOpenBlob`，从而触发下载对话框。
   你不需要手动 `URL.createObjectURL`（虽然也可以），`saveAs` 会做兼容性处理。

**5. 清理（如果你自己创建了 objectURL）**

如果你手动用了 `URL.createObjectURL(blob)`，记得 `URL.revokeObjectURL(url)` 释放内存。用 `saveAs` 的常规用法通常不需要你自己 revoke。

**6. 额外考虑（常见问题与替代方案）**

- **进度条**：`fetch` 默认没有进度回调；要显示下载进度可以用 `XMLHttpRequest`（`onprogress`）或用 `fetch` 的 ReadableStream 来手动统计分块大小。拿到最终 Blob 后再 `saveAs`。
- **大文件内存占用**：把整个大文件读成 Blob 会占内存。若文件非常大，优先让后端直接给一个可下载的 URL，或用流式写入方案（如 stream-saver）避免把整个文件缓存在内存中。FileSaver 适合常规/中等大小文件。
- **跨域(CORS)**：请求文件和读取 `Content-Disposition` 都受 CORS 限制，后端需相应配置。
- **文件名编码**：后端可能使用 `filename*=`（RFC5987）来传 UTF-8 名称，要用 `decodeURIComponent` 解码。
- **IE/旧浏览器**：FileSaver 会自动 fallback 到 `msSaveOrOpenBlob`，通常无需你做额外兼容代码，但记得测试。



### 组件

#### （1）懒加载组件 

**介绍**：项目中有很多场景需要向用户展示存储的所有记忆或者是生成的所有代言，让用户进行选择或者是跳转。当这些记忆和代言数量比较多的时候，如果说一次性全部加载出来肯定会导致加载时间过长，消耗大量资源等等性能问题，所以比较好的方法就是进行懒加载，每次只加载一部分的元素即可。

​	为了实现懒加载功能，我封装了一个懒加载组件。使用时将懒加载组件放在懒加载容器的底部，把容器元素id以及数据加载回调loadMore传入组件就可以使用。在组件中会渲染一个表示加载中的小点动画，通过Intersection Observer对这个元素进行监听，判断它是否进入视口，如果进入就调用loadMore函数来加载数据。所以说实现的效果就是，用户每次往下划到底部时，就会看到加载中的动画，代表这个元素进入了视口，触发加载操作，加载出新的数据渲染到容器中，直到用户又一次划到底部，就再次进行同样的加载操作。

​	我在自己的宅宿甄选项目中也实现了懒加载功能，但是相比于这样效率比较低下。我在项目中没有使用到Intersection Observer，而是在触发滑动事件时实时计算离容器底部的距离，当距离小于一个阈值时就进行加载。这样的坏处就是一方面滚动事件会高频触发，即使在项目中通过节流函数控制也会触发多次，造成多次重复计算，而且获取位置信息也会触发浏览器的回流和重绘，总的来说就是消耗较多资源，性能比较差。相比较使用懒加载组件的好处就是不会造成冗余计算和资源消耗，并且还能够复用到其他地方。



**核心逻辑**

**（2）Intersection Observer 配置**

**观察器**

```TypeScript
const observer = new IntersectionObserver(callback, {
  rootMargin: '300px', // overflow:auto 的时候，rootMargin不生效
  root: document.querySelector(scrollContainerId),
  threshold: [0.1]
});
```

- rootMargin: '300px' - 在元素距离视口300px时就开始触发，提供预加载效果
- root: 指定滚动容器为传入的id对应的元素，默认为 #scrollContainer
- threshold: [0.1] - 当元素有10%可见时就触发回调
- Callback: 触发时调用的回调函数

**回调函数**

对所有观察的元素进行遍历（在本组件中同时间只有一个元素被观察），如果元素进入视口且当前未处于加载状态，就调用loadMore函数并设置加载状态loadingRef为true。函数加载完成后加载状态loadingRef设置回false。

```TypeScript
function callback(entries: IntersectionObserverEntry[]) {
      entries.forEach((entry) => {    // 遍历
        if (entry.isIntersecting && !loadingRef.current) {    // 判断条件
          loadingRef.current = true;    // 设置加载中状态

          loadMore().finally(() => {    // 调用load函数
            loadingRef.current = false;    // 设置未加载状态
          });
        }
      });
    }
```

**延迟观察机制**

给组件500ms的初始化时间，确保DOM元素已经完全渲染，避免在组件刚挂载时就触发加载

通过observer.observe(eleRef.current)给对应的元素启动观察

```TypeScript
const delayInMilliseconds = 500;
const timeoutId = setTimeout(() => {
  eleRef.current && observer.observe(eleRef.current);    
}, delayInMilliseconds);

 // 绑定要观察元素的ref，并渲染加载中的小点
 <div ref={eleRef} className={classNames(styles.container, className)}>
   <DotsLoading />
 </div>
```

**清理机制**

```TypeScript
return () => {
    clearTimeout(timeoutId);    // 清除计时器
    observer.disconnect();      // 结束观察
};
```

**loadMore使用**

```TypeScript
// 先判断是否还有数据，是否找到了对应的记忆。都有才渲染loadMore组件
// noMore是请求完后端的数据后，设置的表明后端还有没有数据的状态变量
{!noMore && !!memoryList.length && (
   <LoadMore
    className={classNames(styles.loadMore, { [styles.inMobile]: inMobile })} // 样式
    loadMore={loadMore}    // loadMore函数
    scrollContainerId={loadMoreScrollId || undefined}    // 容器id
   />
)}
```

**loadmore请求函数**

(1) 在ai回复的对话消息里点击“相关记忆”后弹出 RelatedNoteModal，内部渲染 NoteModal 列表。请求NoteModal列表的数据，使用到loadmore函数

```TypeScript
  const searchNote = () => {
  // 若有相关记忆的nodeIds，把noteIds映射到对应的notes，id为对应id，type为NOTE
    if (noteIds?.length) {
      const notes: { id: string; type: 'NOTE' }[] = noteIds.map((id) => ({ id, type: 'NOTE' }));

      // 调用searchMemoryList接口找到Note对应id的记忆，参数是传入选中的记忆
      return searchMemoryList({ memoryIds: notes, ...paginationRef.current })
        .then((res) => {
          if (res.data.code === 0) {
            // 设置存储Note
            pushNote(res.data.data.list);
          } else {
            throw { message: res.data.message };
          }
        })
        .catch((e) => {
          message.error(e.message || 'Get Note List failed!');
        })
        .finally(() => {
          setLoading(false);
        });
    }

    // 没有选中的记忆，讲所有记忆都传进去
    return searchMemoryList({ memoryIds, ...paginationRef.current })
      .then((res) => {
        if (res.data.code === 0) {
          pushNote(res.data.data.list);
        } else {
          throw { message: res.data.message };
        }
      })
      .catch((e) => {
        message.error(e.message || 'Get Memory List failed!');
      })
      .finally(() => {
        setLoading(false);
      });
  };

// 调用searchNote函数
  const loadMore = () => {
    return searchNote();
  };
```

## 

## 4、性能优化

### （1）防抖结合ref锁

#### **介绍**

对于用户高频触发的事件，一般是通过防抖函数来减少触发的次数，只有最后一次达到一定事件间隔才会真正触发事件。而对于像下载功能这种会消耗服务器大量资源的行为，对安全要求更高，所以希望实现点击后马上“锁住”不允许再次点击，这样需要使用ref做判断结合防抖。以下载功能为例，点击后设置ref.current为false，下载完成后再设置回true。中间的下载过程点击时对ref.current进行判断，如果为false就说明正在下载，直接返回即可。

#### **为什么使用ref而不是state来控制是否锁住？**

最重要的原因在于，state是**异步更新**的，并不能及时更新状态。如果说用户在短时间内多次点击，可能状态还没有更新好，目前还是解锁的状态，那么就没有做到防抖，造成问题。而通过ref来控制的好处就在于，ref的更新过程是**同步的**，状态更新是立即更新的，可以立刻锁住。对于下载这种比较重要的，没有锁住会有严重后果的功能，通过ref来进行控制是很必要的。

当然，state也是有它的作用的。由于state更新后会将**组件重新渲染**，可以及时对于ui进行更新，从而实现状态切换的展示，例如展示转圈，downloading…等等。而ref在更新之后，**不会引起组件重新渲染**，也就无法及时实现状态切换的展示。对于要求比较高的防抖，既要通过ref来马上锁住，也要通过state来及时展示状态。



### （2）React.Memo

`React.memo` 是 React 提供的高阶组件（HOC），主要用于优化函数组件的渲染性能。它的核心优势是可以**避免不必要的重新渲染**

当父组件更新时，即使子组件的 `props` 未变化，默认情况下子组件也会重新渲染。使用 `React.memo` 后，子组件会**浅层比较新旧 `props`**，仅当 `props` 变化时才会重新渲染。

如果`props`是一个对象，即使内容一样，但由于每次传过来的都是一个新对象，引用不同，子组件也会重新渲染。解决方法就是给memo添加一个shallowEqual，这样如果引用不同，会再对内部属性方法进行比较，如果相同就不用重新渲染。

### （3）useMemoriedFn

​	`useMemoizedFn` 是一个ahook库中的hook，作用是返回一个恒定引用的函数，函数内部会调用每次渲染时最新的变量——因此你既能保证函数引用不变，又不会遇到闭包“过期”的问题。

**应用场景**：对于需要传入子组件的函数，通过useMemoriedFn对函数包裹可以避免子组件不必要的渲染。或者是在 `useEffect`/事件监听器里边注册回调，但又不想反复因为引用变化而进行添加删除函数消耗资源。

#### 与useCallBack相比

​	useCallback也是返回一个函数，通过监听依赖项是否变化来对函数进行更新。但跟useMemoriedFn的区别就是，每次依赖项更新后，返回的函数就是一个新的函数，拥有一个新的引用。所以如果函数要传入子组件，每次引用更新都会造成函数的重新渲染，或者是如果函数放在`useEffect`/事件监听器，每次都要重新卸载再添加上去，造成不必要的资源浪费。而使用useMemoriedFn的话，就能保证函数引用是恒定不发生变化的，从而不会造成子组件重新渲染的问题。



## 5、zustand

**介绍**：Zustand 是一个轻量的 React 状态管理库。核心是 create() 创建的hook形式的store，在组件中直接调用就可订阅状态，得到存储的状态和对应的更新方法。再项目中项目将各个领域状态拆分在 src/store 下多个独立的 useXxxStore.ts 文件，按功能模块解耦，组件直接引入对应的 store。

**用法**：首先通过create创建store，参数设置为一个箭头函数，函数的参数是set和get。在store中设置存储的状态，并通过get来获取对应的状态，通过set来更新状态。可以构建不同的方法来对状态进行处理，比如获取某个状态的数据，就先对请求对应接口，请求成功再通过set设置到存储的状态里边。或者是更新某个状态，就先通过get来获取原状态，再通过set把新的状态覆盖上去。

外部组件中使用到zustand时，只需要调用对应的store hook来获取对应的状态和方法，就可以直接使用，不需要像redux那样很繁琐的通过useSelector获取，再通过dispatch更新。

**中间件**：使用到immer来简化复杂对象状态set时需要手动拷贝嵌套对象的样板代码。当我们通过set来设置状态时，一般做法需要将整个整个对象拷贝下来，把新的对象整个的覆盖过去。但对于复杂的嵌套对象，可能只需要更新里边某一项的内容。这种情况就使用与immer，找到draft下边对应状态的某一项，单独对其进行修改即可，大大简化了代码。

**zustand和redux对比**

最主要的还是zustand的轻量级，样板代码少的优点。对于redux，即使时简化后的redux-toolkit，也是需要通过创建store，定义slice并放入store，通过provider包裹组件，组件中通过useSelector获取状态，通过useDispatch分发事件来更新状态这一系列操作来完成的，样板代码很多，比较复杂。而zustand只需要创建store并以hook的形式导出即可，在任意的组件中，直接调用对于的hook，就能获取到对应的数据和更新方法，更新状态也是直接更新就可以，大大减轻了复杂度。

而且zustand在项目中共享状态的范围还更广一些，因为它不需要provider来专门包裹对应的组件，只要调取就可以使用，某种程度上相当与是一种全局的状态管理了。

再有的话zustand包的体积比较小，适合注重整体大小的项目。



## 6、Web Audio Api

### **介绍**：

​	在代言功能的分享页面中，播放视频时希望通过根据音量的大小来调整头像边框的粗细和深浅，以体现出用户正在说话来叙述观点的效果。而获取到当前页面的音量我是借助了html5新增的Web Audio Api来实现的。

### 实现方法

首先是初始化操作

 （1）初始化Web Audio Api音频上下文，用于音频处理

 （2）创建分析节点，对音频上下文使用createAnalyser方法来创建，用于获取音频数据

 （3）接入音频源，通过MediaElementSource将HTML5 audio元素连接到Web Audio API

 （4）构建连接，把将音频源（HTML5 audio元素）连接到分析器节点，再将分析器节点连接到音频输出目标（通常是扬声器）。这样音频数据既能被分析，又能正常播放出来

接下来准备数据采集

（1）准备好存放本次采集到的音频数据的数组，new一个Uint8Array，大小由分析器采集数据的FFT大小决定。

（2）设置采样间隔和事件戳

然后定义采样函数

（1）进行防抖判断是否达到采样间隔，达到了才可以继续执行

（2）通过analyser.getByteTimeDomainData(dataArray)采集音频，并将音频数据都存放到了dataArray里边

（3）对音频数据进行遍历，通过均方根方法将它们归一化

（4）将音频数据存入state，由于普遍音量较低，对音量重新映射到0-1均匀分布后再存入

最后通过requestAnimationFrame()来启用采样函数



### 为什么使用 requestAnimationFrame

音频检测是要在播放时始终进行监听的，所以要通过requestAnimationFrame保持对监听函数的调用

**1. 与浏览器渲染周期同步**

- requestAnimationFrame 会在浏览器下一次重绘之前执行回调

- 避免不必要的重绘，提高性能

**3. 自动暂停和恢复**

- 当页面不可见时，requestAnimationFrame 会自动暂停

- 页面重新可见时自动恢复，节省 CPU 资源

- 这是 setInterval 无法提供的特性

**4. 性能优化**

- 浏览器会优化 requestAnimationFrame 的执行时机

- 在后台标签页中自动降低执行频率

- 避免阻塞主线程

5. **触发频率控制**

确保音频可视化更新与屏幕刷新率同步（通常 60fps）

- 通过时间间隔控制，实现 10Hz 的采样频率

- 避免过于频繁的音频分析，平衡性能和实时性

### **代码示例**

```JavaScript
const startAudioAnalysis = () => {
    if (!audioRef.current) return;

    if (!audioContextRef.current) {
      // 1、初始化操作
      audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
      analyserRef.current = audioContextRef.current.createAnalyser();
      const source = audioContextRef.current.createMediaElementSource(audioRef.current);

      source.connect(analyserRef.current);
      analyserRef.current.connect(audioContextRef.current.destination);
    }

    const analyser = analyserRef.current;

    if (!analyser) {
      console.log('analyser is null');

      return;
    }

    // 2、准备操作
    const dataArray = new Uint8Array(analyser.fftSize);
    let lastSampleTime = 0;
    const sampleInterval = 100; // ms，10Hz

    // 3、定义采样函数
    function tick(now: number) {
      if (!analyser) {
        console.log('analyser is null in tick');

        return;
      }
      if (!lastSampleTime || now - lastSampleTime >= sampleInterval) {
        analyser.getByteTimeDomainData(dataArray);
        let sum = 0;
        // 均方根归一化处理
        for (let i = 0; i < dataArray.length; i++) {
          const val = (dataArray[i] - 128) / 128;

          sum += val * val;
        }

        const rms = Math.sqrt(sum / dataArray.length);
        // 划定范围，避免音量过低导致数据普遍过低
        const maxVolume = 0.2;

        if (rms > maxVolume) {
          // 大于直接就等于1
          setAudioVolume(1);
        } else {
          // 小于则按范围重新取值，提高数值
          setAudioVolume(Math.min(1, Math.max(0, rms / maxVolume)));
        }

        lastSampleTime = now;
      }

      animationRef.current = requestAnimationFrame(tick);
    }
    // 4、调用函数
    requestAnimationFrame(tick);
  };
```

## 7、html2canvas

### **介绍：**

​	在项目中代言的分享页，或者是AI打分等页面，希望用户以名片的形式保存页面并分享出去，我采用的实现方式就是通过第三方库html2canvas，将对应的html元素转化为canvas元素，下载成图片。

### 实现方法：

​	首先调用html2canvas，将当前元素通过ref绑定的方式传入，在下一个参数选择设置背景颜色并允许跨域（因为有跨域的图片）。成功后就会返回一个canvas元素，将canvas元素转化为URL链接的形式，再创建一个a链接将URL传给它，触发点击事件，就可以实现图片的下载。



## 8、文件上传

**介绍**：在代言功能或者是其他的一些AI生成页面中，用户可以向AI进行多模态消息的传递。可以向AI发送图片，文档，音频等等不同类型的文件，这时就需要实现文件上传功能。

### （1）如何实现的文件上传

介绍：文件上传是基于antd的upLoad组件来实现的，首先是设置upload组件的name action accept等等属性，可以配置上传的参数名，地址，数量，文件类型之类的。同时组件内置了onchange API，上传成功、失败或是正在上传中都会调用这个函数，函数返回的event中会返回上传的状态、进度、URL等。根据不同的状态来进行不同的处理，比如上传中就根据进度条来展示当前的上传进度。此外upLoad组件还有beforeUpload API可以在文件上传前先进行检查，看看文件大小、类型和数量是否符合用户标准。



**上传进度如何显示？**

​	项目中的实现方法是onChange api返回的info.event.percent确定的，代表前端上传数据的进度，也可以在axios中通过onUploadProgress来得到，对于xhr是upload.onprogress。



### （2）如何实现大文件上传

​	在项目中对于普通用户支持10MB的文件上传，对于付费用户则支持50MB的文件上传，而且有每天三次的大文件上传机会。

​	当大文件上传时，如果直接通过普通文件上传的模式，通过FormData包装上传，很容易上传失败，重新上传又从头开始，非常浪费时间。就算上传成功，下次上传同样的文件又要重新上传，对用户体验也是比较差。
​	为解决这些问题，可以通过秒传+分片上传+断点续传实现大文件上传。

我讲一下**整体思路**

1. **分片切片**

   `Blob`提供数据截取的方法`slice`，而文件对象 `File`是`Blob`的子类继承了`slice`方法，所以可以利用`slice`方法将大文件分割成若干份文件分片，每个分片都有固定大小（比如 1 MB、2 MB、5 MB，或业务可配置），将分片存储起来，并记录各自的索引。

2. 秒传 **计算文件指纹（或者叫Hash值）**

   - 用于“秒传”场景：文件选择后，通过MD5结合webWorker，先在前端对整个文件计算一个唯一哈希值。之所以用到webWorker是因为哈希值的计算需要一段时间，而如果放在主线程里边的话就会阻塞页面导致页面卡死，给用户带来不好的体验。所以说使用到WebWoker来进行计算，它相当于是一个独立的线程，不会对主线程造成干扰，也就不会造成页面卡死的问题。
   - 哈希值一旦计算出来，向后端查询该哈希值是否已存在。如果后端已有这个哈希值且对应的文件完整可用，则说明后端已经上传过了这个文件，则告知前端可以“秒传”跳过，直接标记上传成功。

3. **上传分片**

   向服务器上传时对每个文件分片构造FormData，发送到后端。发送时采用并发上传的方式，设置一次发送的数量，对这些分片一起进行发送。这样可以提升整体上传的进度。当然需要做最大限流（六个），避免压垮网络或服务器。对于上传失败的切片，会增加一次计数，失败三次以上就标记文件上传失败。

4. **断点续传**

​	向上传文件分片前，前端先请求后端，得到所有已成功上传的文件分片的索引列表，在所有的文件分片索引中进行过滤，得到剩余的未成功上传的文件分片，仅对这部分分片进行上传就可以。如果全部上传完毕了就返回告知前端，前端直接秒传完成。如果过滤后发现所有分片都上传过了，前端就调用合并接口告知后端进行合并。

（如果问如何合并：发送时将文件分片的索引发送过去，后端进行合并前会通过索引进行排序）

（如果问如何保存的）并不保存，而是上传文件之前都进行webworker进行计算出分片列表和文件的哈希值哈希值

5.**上传进度控制**

​	在界面上实时展示上传进度，这里的上传进度可以通过onUploadProgress来获得，但是这个是前端上传的进度，不一定代表服务器一定上传成功了，所以断点续传时还是要根据后端返回的上传成功的分片来进一步确定，进度是通过服务端返回的已上传分片结合本地记录来确定的。



如果问：

**为什么要用 Web Worker？**
 浏览器中，主线程（UI 线程）同时负责渲染界面、响应用户操作、执行 JavaScript 等。如果直接在主线程里对一个很大的 `File` 对象做哈希（比如用 SparkMD5 一次性读完整个文件），这段计算会持续几秒甚至更长时间，页面会卡死，用户体验很差。
 Web Worker 相当于一个独立的 JavaScript 线程，它和主线程之间只能通过 `postMessage` 发送消息，互不干扰。我们可以把文件分片后的哈希计算逻辑放到 Worker 里，让主线程保持流畅。

**总体流程**

- 把worker的使用封装到了一个hook里边，选择文件后，主线程调用 useWorker(file) 传入文件和分片大小，创建 Worker、通过postMessage 发入参数、计算完成后在 onmessage 拿回 fileHash （哈希值）和 fileChunkList（文件分片列表）。

```
useWorker(file) {
  return new Promise((resolve) => {
    const worker = new Worker(new URL('@/worker/hash-worker.js', import.meta.url), { type: 'module' })
    worker.postMessage({ file, chunkSize: this.chunkSize })
    worker.onmessage = (e) => {
      const { fileHash, fileChunkList } = e.data
      if (fileHash) {
        resolve({ fileHash, fileChunkList })
      }
    }
  })
}
```

- 在Worker 用 Blob.slice 对文件依次截断，生成 文件分片列表（仅含每片的文件分片）。

```
function createFileChunk(file, chunkSize) {
  let fileChunkList = []
  let cur = 0
  while (cur < file.size) {
    fileChunkList.push({ chunkFile: file.slice(cur, cur + chunkSize) })
    cur += chunkSize
  }
  resolve(fileChunkList)
}
```

- 计算整文件哈希（MD5）

Worker 依次用 FileReader.readAsArrayBuffer 读取每个切片，按顺序喂给 SparkMD5.ArrayBuffer()，持续累加。

期间会按进度比例向主线程 postMessage({ percentage })。

所有切片读完后得到“整文件哈希”并一次性回传。

```
async function loadNext(index) {
  if (index >= fileChunkList.length) {
    return spark.end()
  }
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.readAsArrayBuffer(fileChunkList[index].chunkFile)
    reader.onload = (e) => {
      spark.append(e.target.result)
      percentage += 100 / fileChunkList.length
      self.postMessage({ percentage })
      resolve(loadNext(index + 1))
    }
```

将结果返回并结束 Worker，回传的数据包含：fileHash（整文件 MD5）与 fileChunkList（切片 Blob 列表）。完成或出错后都会self.close()。

```
const fileHash = await loadNext(0)
self.postMessage({ percentage: 100, fileHash, fileChunkList })
self.close()
```

worker中也是通过监听message事件，调用对应的函数



**并发上传大致思路**

1. 准备队列

- 解析文件切片后，生成待传队列 allChunkList（每项含 index/chunkFile/chunkHash/...）。

- 设置whileRequests上传的任务对象，上传时for循环就是遍历这个对象，并设置每轮的切片maxRequest 。每轮从 allChunkList 中取 maxRequest 个切片 → 放入 whileRequests 作为并发窗口；同时从 allChunkList 中截取范围向后移动maxRequest 。

- 对窗口内每个切片调用 uploadChunk接口 发请求（FormData → POST /upload）。

- 单片请求与回调

- 成功：

- finishNumber++，needObj.finish = true，更新进度 finishNumber / chunkNumber。

- 从 whileRequests 移除该切片。

- 若 finishNumber === chunkNumber → 调 /merge；否则递归调用 uploadSignleFile 补位，保持并发不降。

- 失败：

- errNumber++，未超过 3 次就对该切片重试；超过 3 次标记文件失败（v2 为 state = 4）。





### **（3）普通上传关键点解释**

#### 1、基本组件**`<Upload {...props}>`**

​	

- `name`：指定传给后端的图片参数名。
- `action`：上传地址，即后端接收上传请求的 URL。Upload 组件会把文件以 `multipart/form-data` 的形式 POST 到此地址。
- `headers`：因为后端需要鉴权（如 Bearer Token、Cookie 等）在这里统一设置请求头，这里直接调用request.js文件中设置好的**getDynamicHeaderData**函数动态设置请求头。
- maxCount： 设置最多上传图片数量，项目中为10张
- fileList = {picList} ：把 Upload 的“文件列表属性”与usestate picList数组 关联起来，属于受控模式。这样做可以在 `onChange` 里随时拿到当前所有上传进度、状态、后端返回信息等，并决定如何更新展示。
- `onChange(info)`：上传中、完成、失败都会调用这个函数，`info` 对象包含以下重要字段：
  - `info.file`：代表当前操作的文件对象（包含 `status`、`name`、`uid`、以及后端返回的 `response` 等）。
  - `info.fileList`：当前所有上传中文件的列表（数组）。
  - `info.event`：在上传过程中，如果开启了分片或流式，可以看到更详细的进度条事件。
- `info.file.status`：代表当前状态，可能的状态有
  - `"uploading"`：正在上传
  - `"done"`：上传完成并收到后端响应
  - `"error"`：上传出错
  - `"removed"`：文件被移除



**假如问为什么 “进行中” 会多次调用 `onChange`**

- `<Upload>` 底层其实是通过 `<input type="file" />` 选中文件后，使用 XHR（或 `fetch` + `FormData`）向后端上传文件。
- 浏览器在真正开始上传时，会不断触发 XHR 的 `upload.progress` 事件（每下载/上传一定字节就会发一次），以便前端更新进度条。
- Ant Design 的源码对这个 `progress` 事件做了监听，一旦收到新的进度，就会给当前那条 `file` 的 `percent` 字段“打上新值”，并且把更新后的 `file`（以及新的 `fileList`）传给你在 `onChange(info)` 中的 `info` 对象。
- 因此，当后端正在接收数据、浏览器不断上报进度时，`onChange` 会**随着每一次 XHR 进度事件**被调用一次，而且每次调用里的 `info.file.status` 都是 `'uploading'`，`info.file.percent` 则会逐步从 0 → 100。

简而言之，**“进行中”状态的 `onChange` 触发时机，就是每当浏览器报告上传进度时**。这个次数并不是固定的 “3 次” 或 “5 次”，而是取决于：

1. 你的网络带宽与后端处理速度。
2. 文件大小越大，越多字节被分批上传，浏览器就会触发更多次 `xhr.upload.progress`。
3. 浏览器和服务器之间的握手、分片策略也会影响进度事件触发的粒度。



最基本的用法，仅演示如何上传图片到后端（假设后端上传地址为 `/api/upload`）：

```jsx
import React from "react";
import { Upload, Button, message } from "antd";
import { UploadOutlined } from "@ant-design/icons";

export default function SimpleImageUpload() {
  const props = {
    name: "file",                           // 后端接收文件字段名，例如 req.file 或 req.files["file"]
    action: "/api/upload",                   // 文件上传的后端接口 URL
    headers: {
      authorization: "Bearer token_here",    // 如需鉴权，可在头部加 token；若无可省略
    },
    onChange(info) {
      // info.file.status: 上传状态：uploading | done | error | removed
      if (info.file.status === "uploading") {
        console.log("上传中：", info.file, info.fileList);
      }
      if (info.file.status === "done") {
        message.success(`${info.file.name} 上传成功`);
        // info.file.response: 后端返回的数据（假设后端返回 { url: "http://..." }）
        console.log("后端返回：", info.file.response);
      } else if (info.file.status === "error") {
        message.error(`${info.file.name} 上传失败`);
      }
    },
  };

  return (
    <Upload {...props}>
      <Button icon={<UploadOutlined />}>点击上传图片</Button>
    </Upload>
  );
}
```



#### 2、限制上传格式与大小

在项目中，需要校验用户只能上传指定图片类型（image下边的文件类型）且体积不能超过5MB。我们可以通过 `beforeUpload` 属性在前端先行拦截。	

**详细解释**

1. **`beforeUpload(file)`**
   - 会在文件发出网络请求之前被调用，参数 `file`为上传的文件。
   - 在函数中检查 `file.type`，来判断是否是图片类型文件（file.type.startsWith("image/")）、`file.size`，来检查图片是否小于5MB （file.size / 1024 / 1024 < 5）。
   - 如果返回 `false`，Upload 就会阻止该文件继续上传，并向用户进行提示。
   - 如果返回 `true`，则正常上传。
2. **`accept=".jpg,.jpeg,.png"`**
   - 只让用户在系统文件选择对话框中可见指定后缀的文件，但注意这只是前端“视觉”层面的过滤，让用户选择文件时只出现相关类型的文件，有可能被用户绕过，所以仍建议在 `beforeUpload` 中做二次校验。



#### 3、图片预览功能

用户选图进行上传，上传成功在输入框上方展示缩略图，上传失败显示错误的占位符，正在上传显示进度条。无论那种状态都附带叉号按钮可以将图片删除。核心在于：

1. 从后端获取到返回的文件对象，包括状态、URL、id和百分比，把它存到一个数组里（`picList`）；
2. 让 React 根据这个数组，动态地渲染出一排缩略图；
3. 每个缩略图外层用相对定位，里层是 `<img>`，右上角叠加一个 “×” 图标，点击时从数组里把对应项移除。

**详细说明**：

​	1、首先设置`picList`这个数组来存储每个上传文件的返回结果，数组的对象元素中包括状态status、URL（上传成功才有）、id和百分比percent（上传中才有）

​	2、在onchange事件对应的函数中，根据后端返回的不同的文件状态进行不同处理。

- `"uploading"`：代表正在上传中，通过find方法结合文件id在picList中找到那个文件对象，修改其百分比属性为新的file.percent；如果找不到相应文件代表这是新上传的图片，就给数组追加一个新的对象。
- "done"： 上传成功，后端返回结果中包括图片的URL,在picurls数组中找到相应文件对象并将图片URL和成功状态加进去
- "error"：上传失败，给用户弹出错误，并将失败状态赋值给数组中相应文件对象

​	3、对整个picList进行渲染，也分成三种状态对不同的文件进行渲染。

- `"uploading"`：结合antd库的Progress进度条组件，给Percent属性传入文件对象的百分比属性值，从而实现进度条加载效果。
- "done"： 将URL设置为img图片的src地址，显示缩略图
- "error"：显示一个错误的占位图标



#### **4、上传图片浏览**

​	用户可以对所有成功上传图片进行全屏浏览，我在做自己项目时封装过一个图片浏览器组件，这里需求相同，我就复用了之前封装的组件。给picList数组通过filter根据状态过滤出所有上传成功的图片，传入图片浏览器组件即可。



### （4）如果不使用antd，如何实现文件或图片上传功能？

​	可以使用input表单，表单类型为file，用户点击表单后就可以选择文件。再构造FormData，将用户选择的文件通过append添加到里边。最后把‘formData通过post发送到相应的后端接口，即可实现文件或图片上传。

#### **什么是FormData**

**定义**：`FormData` 是浏览器内置的一个构造函数（Web API），专门用来以 `multipart/form-data` 的格式组织键值对（key/value），其中 value 可以是简单的字符串，也可以是 `File`、`Blob` 等二进制对象。

**作用**：它会自动为你拼装出符合 HTTP “多部分表单”标准的请求体，包括自动生成 boundary（分隔符）并在请求头中加上正确的 `Content-Type: multipart/form-data; boundary=…`。开发者只需把字段（和文件）一一追加进去，最后把整个 `FormData` 对象当作请求体发送即可。



#### **什么是content-type**

**`Content-Type`** 实体头部用于指示资源的MIME类型 media type 比较常用的有数据接口`application/json`，文本`text/css`，图片`image/jpeg`

在请求中 (如`POST`或 `PUT`)，客户端告诉服务器实际发送的数据类型



#### **什么是multipart/form-data**

`multipart/form-data` 是一种在 HTTP 请求中传输“表单数据+文件”时常用的编码格式，主要用于实现文件上传功能。

1. **作用场景**
    当你在网页里有一个带文件输入（`<input type="file">`）的表单，并且要把文本字段和二进制文件（如图片、视频）一起发送到服务器时，就需要用 `multipart/form-data`。相比普通的 `application/x-www-form-urlencoded`（只能传文本），它能把文件分片并打包，让服务器正常解析。

2. **分段边界（boundary）**
    请求头里multipart/form-data后边会出现boundary

   ```
   Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAbCdEf123456
   ```

   `boundary`（分界符）是浏览器随机生成的一段字符串，用来把整个请求体分成若干“段”。每一段对应一个表单字段（可以是普通文本，也可以是文件），每遇到一个 `boundary`，就表示新一段内容开始。浏览器和服务器通过这个分隔符，就能把整块二进制数据拆成若干个独立的字段。

3. **请求体结构**

   - **普通字段**：
      每段最上面有一行 `Content-Disposition: form-data; name="字段名"`，紧接着空一行，然后放字段值。
   - **文件字段**：
      除了 `Content-Disposition` 里有 `filename="文件名"`，还会额外有一行 `Content-Type: 文件MIME类型`（如 `image/jpeg`、`application/pdf`），然后空一行后直接跟文件的二进制内容。

4. **优点**

   - 可以同时上传文本和一个或多个文件。
   - 浏览器自动处理边界，无需开发者手动拼接，只需把字段或文件 `append` 到 `FormData`，然后用 `fetch` 或 `XMLHttpRequest` 发送即可。
   - 后端框架（如 Node.js 的 multer、PHP 的 $_FILES、Java 的 MultipartResolver 等）都能自动识别 `multipart/form-data` 并提取各段数据。

5. **与其他编码的区别**

   - **`application/x-www-form-urlencoded`**：只能发送文本字段，所有数据都会被 URL 编码（例如把空格变成 `+`、把特殊字符变成 `%**`）。
   - **`text/plain`**：将表单内容按纯文本方式发送，根本不常用于文件上传。
   - **`multipart/form-data`**：把每个字段或文件都当成一段，用边界分隔，既能传文本又能传二进制，适合文件上传。



### （5）假如要实现拖拽功能

#### 拖拽上传逻辑

1、拖拽事件处理

我为上传区域（一个带有虚线边框的div）添加了两个拖拽相关的事件处理器：

- onDragOver：当文件被拖拽到上传区域上方时触发，需要调用event.preventDefault()来阻止浏览器默认行为，这样才能让drop事件正常触发展示对应状态
- onDrop：当文件被放置到上传区域时触发

在onDrop事件处理器中，我通过**event.dataTransfer.files**获取到用户拖拽的文件列表，然后调用与点击上传相同的addFiles函数来处理这些文件

## 9、白屏问题

白屏通常指的是页面加载过程中，由于各种原因导致用户在一段时间内看到一个空白页面，无法看到预期的内容。

### （1）出现白屏的原因

几种主要的原因：

1、资源加载失败页面依赖的关键资源(CSS、JS、图片等)加载失败,导致页面无法正常渲染。

2、资源加载延迟(或阻塞)，导致页面长时间等待资源加载完成。出现空白。

3、 代码执行中出现未被捕捉的错误，例如JavaScript执行错误，Promise错误等等。导致页面功能无法正常工作，出现空白。

4、浏览器兼容问题 不同的浏览器对于前端技术的支持程度不同，如果我们使用了浏览器不支持的语法或者CSS类型，可能导致某些浏览器无法正常显示页面。

### （2）如何排查白屏原因

#### 1、打开开发者工具（Console/Network）观察

**Console（控制台）报错**

- 通常首要打开控制台，看看有没有语法错误（`SyntaxError`）、找不到模块（`404` 或 `Module not found`）、运行时异常（`ReferenceError`、`TypeError` 等）。
- 如果出现报错，很可能是 JS 执行到某一行出错，导致后续的渲染流程直接中断，让页面显示白屏。

**Network（网络）请求**

- 查看 HTML、JS、CSS、图片等资源的请求状态。
- 如果核心的 `index.html`、`bundle.js`、`main.css` 加载失败（HTTP 404/500），页面肯定无法渲染。
- 注意检查 MIME 类型、CORS、域名配置、路径前缀（尤其是 SPA 部署在子目录时容易出错）。

**在代码中**

- 可以在代码中在一些关键的节点通过colsole.log输出一些关键的变量、参数、对象、数组等，判断流程是否成功
- 可以在react中的使用 Error Boundary，以便在渲染阶段出错时展示兜底 UI，并在 Console 打日志展示错误，避免直接白屏。
- 在关键的节点可以通过debugger添加调试节点，方便在开发者工具中进行调试

### （2）如何监测页面白屏

​	在代码中可以通过一些自动化方案，通过性能监测埋点，对白屏情况进行检测。

**方案一：检测根节点是否渲染+onerror监听**

原理很简单，DOM 一般挂载在一个根节点之下（比如 `<div id="app"></div>` ），发生白屏后通常是根节点下所有 DOM 被卸载。该方案就是通过监听全局的 `onerror` 事件，在异常发生时去检测根节点下是否挂载 DOM，若无则证明白屏。

这种方案，简单直接，直接检测根节点是否渲染完成即可。适用于SPA。SPA页面主要内容通过根节点下的组件渲染,所以监测根节点渲染情况可以判断SPA页面主要内容是否正常渲染。

**方案二：Mutation Observer 监听 DOM 变化**

实现方法：

- 在页面最早能执行的脚本里（比如放在 `<head>` 中的轻量埋点脚本），先定义一个 `MutationObserver` 实例。
- 同时在脚本里启动一个定时器（例如 `setTimeout`，5 秒或 10 秒为阈值）。
- 如果在阈值时间内，Observer 回调从未“认为页面已渲染”（即关键容器依旧空空如也），就可以判定为“疑似白屏”，然后在定时器到点时执行上报逻辑。
- 在回调和定时器中分别调用不同上报方法：
  - **正常渲染**：`reportRendered()` 上报首屏渲染成功的时间点、页面路径等。
  - **疑似白屏**：`reportWhiteScreen()` 上报白屏事件，包括 URL、UserAgent、网络类型、时间戳等。

收到埋点后，后端监控系统可以统计白屏率，并结合 `window.onerror`、资源加载失败等其他埋点进行分析。



一点小问题

同时如果用户长时间未操作DOM，Mutation Observer 监听到一定时间内没有 DOM 变化，就可能会误判为页面白屏。

实际应用中，可以通过一些手段来增加 DOM 的变化，从而避免误判。比如，在页面初始化时，可以在页面中插入一些隐藏的元素，然后定时更新这些元素的样式或内容，从而让 Mutation Observer 监听到 DOM 的变化。另外，一些自动化的数据推送、广告展示等行为也会引起 DOM 的变化，这些行为也可以被 Mutation Observer 监听到，从而避免误判。



**方案三：关键点采样对比**

所谓关键点采样就是在我们的屏幕中，随机取几个固定的点，利用document.elementsFromPoint（x,y）该函数返还在特定坐标点下的 HTML 元素数组。

在获取页面宽高之后，在页面垂直/交叉位置确定多个采样点，通过 [elementFromPoint](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDocument%2FelementFromPoint) 方法获取采样点的元素，然后判断采样点冒泡元素集合的第一个元素是否为容器元素（如标签为body）、加载态元素（例如骨架屏或有loading类名的元素），当存在一定比例（例如超过80%）的采样点元素为容器元素或加载态元素时则可以判定为白屏。



### 白屏优化

**1. 优化 HTML 结构**

- **减少 HTML 文件大小**：压缩 HTML 文件，移除不必要的空格、注释和冗余代码。
- **使用语义化标签**：使用语义化标签（如 `<header>`、`<footer>`、`<article>` 等），提高页面结构的可读性和可维护性。

**2. 优化 CSS**

- **内联关键 CSS**：将关键路径的 CSS 内联到 HTML 文件中，减少首次渲染时的网络请求。
- **使用 CSS 预处理器**：使用 Sass、Less 等 CSS 预处理器，减少重复代码，提高 CSS 的可维护性。
- **压缩 CSS 文件**：压缩 CSS 文件，减少文件大小，加快加载速度。

**3. 优化 JavaScript**

- **异步加载 JavaScript**：使用 `async` 或 `defer` 属性异步加载 JavaScript 文件，避免阻塞页面渲染。

  ```
  <script src="script.js" async></script>
  <script src="script.js" defer></script>
  ```

- **延迟加载非关键 JavaScript**：将非关键的 JavaScript 延迟加载，优先加载关键内容。

  ```
  <script src="non-critical.js" defer></script>
  ```

- **按需加载路由**：将每个页面路由组件，拆成单独的一个个 chunk 文件，这样 main.js 文件体积降低，在首屏加载时，不会再加载其他页面的资源，从而提升首屏渲染速度。

- **减少 JavaScript 文件大小**：压缩 JavaScript 文件，移除不必要的空格、注释和冗余代码。

**4. 优化图片**

- **使用适当的图片格式**：根据图片内容选择合适的格式（如 JPEG、PNG、WebP 等），减少图片文件大小。

- **压缩图片**：使用图片压缩工具（如 ImageOptim、TinyPNG 等）压缩图片，减少文件大小。

- **延迟加载图片**：使用懒加载技术，延迟加载页面中的图片，优先加载关键内容。

  ```
  <img src="placeholder.jpg" data-src="image.jpg" alt="Image">
  ```

**5. 优化网络请求**

- **减少 HTTP 请求**：合并 CSS 和 JavaScript 文件，减少页面加载时的 HTTP 请求数量。
- **使用 CDN**：使用内容分发网络（CDN）加速静态资源的加载。
- **启用 HTTP/2**：使用 HTTP/2 协议，提高页面加载速度。

**DNS 查询优化**

前端侧，可以通过在页面中加入 **dns-prefetch**，在静态资源请求之前对域名进行解析，从而减少用户进入页面的等待时间。如下所示：

```ini
<meta http-equiv="x-dns-prefetch-control" content="on" />

<link rel="dns-prefetch" href="https://s.google.com/" >
```

其中第一行中的 x-dns-prefetch-control 表示开启 DNS 预解析功能，第二行 dns-prefetch 表示强制对 s.google.com 的域名做预解析。这样在 s.google.com 的资源请求开始前，DNS 解析完成，后续请求就不需要重复做解析了。

**通过骨架屏或loading进行优化**

在未加载出来时展示骨架屏或loading，以提高用户体验

**借助webWorker**

Web Worker 相当于一个独立的 JavaScript 线程，它和主线程之间只能通过 `postMessage` 发送消息，互不干扰。我们可以把文件分片后的哈希计算逻辑放到 Worker 里，避免阻塞主线程加载，让主线程保持流畅。





## 10、实习中有遇到什么困难吗，最后是怎样解决的

### **图片下载时的跨域问题**

#### **问题介绍**

在下载图片时，出现了很奇怪的跨域问题。本来对于localhost已经配置好了cors，理论上来讲不应该出现跨域问题。但实际操作时发现，第一张图一直会触发跨域，其余的不会。

![https://mindverse.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjRmMDJiMGNkZDI4YWFlM2UyNzI4NGRiZjc5MDdkZjFfaU1BNHNweE5ZY29nT09RMUhhNVNGUjNaSTM4ZnlWOENfVG9rZW46QzBIUmJVaVl3b1dKS054cVJZMmNjRFNkbjVlXzE3NTU4NDEyMDA6MTc1NTg0NDgwMF9WNA](https://mindverse.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjRmMDJiMGNkZDI4YWFlM2UyNzI4NGRiZjc5MDdkZjFfaU1BNHNweE5ZY29nT09RMUhhNVNGUjNaSTM4ZnlWOENfVG9rZW46QzBIUmJVaVl3b1dKS054cVJZMmNjRFNkbjVlXzE3NTU4NDEyMDA6MTc1NTg0NDgwMF9WNA)

#### 解决方法

尝试把devtool network里边的disable cache勾选上，发现跨域问题不再出现，说明问题和缓存相关，那么解决思路就是避免触发缓存。

```TypeScript
const response = await fetch(url + '?_t=' + Date.now(), { mode: 'cors' });
```

可以给url加上一个时间戳，从而保证了每个url的唯一性。url是独一无二的，每次请求也就不会触发缓存（因为缓存里面根本就没有这个url）。请求直接到达服务器，而服务器是配置了cors的，从而避免了跨域问题。

#### 问题解释

那么究竟为什么只有第一张图片会产生跨域问题，其余图片不会呢？

关键就在于**缓存**上。在页面中，第一张图片已经被**img标签加载**出来放在了封面上，并被标记为跨域资源放在了**缓存**里边。所以当下载图片时，第一张图片的请求会命中缓存，而不是发送到服务器。在缓存中第一张图片被标记为跨域资源，而且缓存中是不带有cors配置的，自然就会触发跨域问题。

至于其余的图片，它们并没有被img标签加载到页面上，也就没有被放到缓存里，下载时请求直接到达服务器，服务器配置了cors，自然也就没有跨域问题。而且下载这个过程并没有把图片放到img标签进行加载，所以其余的图片始终没有被放进缓存里，所以每次下载都是只有第一张图片触发跨域，其余的不会。当这些图片也被加载过以后，它们也就会触发跨域了。

​	

## 11、实习中有什么收获

​	在实习中，我首先了解到了参与到一个真实的企业项目开发的大致流程，有了实践的经验。也了解到了彼此间如何协作开发，进一步掌握了git的使用，并锻炼了我的沟通交流能力。参与到实际项目中的代码开发，也使我的技术进一步熟练。此外，我在项目中也学到许多之前没有用过的新知识新技术，并进行了实际应用，如SSE的使用以及文件上传、懒加载等功能的实现等等，拓宽了我的知识面。总的来讲收获很多。



## 12、项目的开发流程是怎样的？

​	开发流程的话，我实习的公司比较小，人也比较少，开发流程可能没有那么完整。我们项目使用的是腾讯云的CODING进行代码管理的。首先如果要开发一个新业务，需要从main_release分支中开一个新的分支，在这个分支中进行开发。开发完之后，从本地验证没问题了，就发起合并请求。随后带我的老师会大致审阅一下我的代码有没有问题，看出来的问题返回来就进行修改，没有的话就合并到main_release分支中，等这一波需求都做的差不多了就部署到测试网站上。在测试网站上我会和测试人员一起使用功能看看有无我没发现的问题，或者是生产环境与开发环境不同造成的问题，如果发现有问题就修改再重新测试。直到测试没问题后，代码就从dev分支合并到master分支中，进行部署上线。



## 13、有没有测试出现的问题，是如何修改的？

​	先看上边图片加载	

​	

​	有的，有时会因为生产环境和开发环境不同造成问题。比如我在开发分享页中，新用户登录步骤的Modal，在本地实现很成功，但部署到测试网站中发现不管是否登录都会显示。后来排查发现是由于登录鉴权的问题。登录步骤Modal只有在用户未登录才会显示，这需要登录鉴权来实现。项目在用户登录后会往localstorage中传递token，未登录时不存在token。所以我通过getItem加if条件判断检测是本地存储中是否有token这一项，有就不显示，没有就显示，从而实现登录鉴权。但生产环境和开发环境中，后端返回的token名称不一致，存储在本地存储的键名也就不一致，我在代码中if对比的是开发环境的token键名，在生产环境中没有这一项，所以不会显示。修改很简单，把对比的token名改成生产环境的token名就可以。





其他问题比如：在自己的项目中实现切换历史会话功能时，一开始只考虑到静态时的操作，未考虑到AI正在输出时点击切换的问题。自己测试时发现AI正在输出时，由于上一个对话的webSocket未关闭，有时会出现消息串台的问题，在当前会话中输出另一会话的内容。所以马上进行了修改，给切换会话的函数最开始就加上关闭WebSocket和清楚心跳检测的代码，并在输出时加上判断会话id是否一致的条件，从而解决了问题。



## 14、项目中的技术选型是怎么确定的

​	基本的技术选型是根据项目统一的标准已经确定好的，比如使用react框架，使用antd库。当然也有一些技术栈是新添加进去的，比如使用SSE来进行代言功能的通信，这个是和其它通信方式进行比较后确定的，使用react-markdown来渲染markdown格式的文本，这也是经过了和markdown-it，MDX等其他渲染方式比较后选择的。

**react-markdown的优势：**

**原生 React 组件化渲染**

- 直接把 Markdown 文本作为子节点传给 `<ReactMarkdown>`，输出结果就是标准的 React 元素，能够和你项目中其他组件无缝组合、复用、测试和样式化。

**内置安全过滤（防 XSS）**

- 默认会移除或转义潜在的危险 HTML（如 `<script>`），避免手写 innerHTML 时常见的跨站脚本攻击风险。

**丰富的插件生态**

- 可以套用大量现成插件：
- 插件机制让你无需从零实现这些功能，只需几行配置即可完成。

**轻量高效**

- 核心包小（gzip 后约 6 KB），只做 Markdown→React 的“管道”工作，不捆绑样式，也不强制你引入不必要的依赖。
- 渲染性能优秀，处理大型文档或频繁更新时不容易成为瓶颈。



**与markdown-it，MDX的对比**

**markdown‑it**

- **核心思路**：
  - 将 Markdown 文本解析成 HTML 字符串。
  - 使用 `dangerouslySetInnerHTML` 注入渲染结果。
- **相较于 react‑markdown 的不足**：
  1. **React 组件化**：输出是纯 HTML，无法生成可定制的 React 元素树，难以在 `<h1>`、`<code>` 等标签上挂载 React 组件或自定义 props。
  2. **安全性**：由于是直接通过html注入渲染结果，默认不做 XSS 过滤，可能会造成一定风险，还需要额外引入并配置诸如 DOMPurify；而 react‑markdown 默认即防 XSS。
  3. **测试与复用**：无法像 React 组件那样独立单元测试或复用渲染逻辑，样式隔离也更麻烦。

**MDX** (`@mdx-js/react`)

- **核心思路**：
  - 将 Markdown 当作 JSX 语法解析，能在 Markdown 文档中直接写入和渲染任意 React 组件。
  - 编译时（Babel/Webpack）把 `.mdx` 文件转成 React 组件，再在运行时使用。
- **相较于 react‑markdown 的不足**：
  1. **构建复杂度**：需要额外的编译工具链（Babel/Webpack/ESBuild 插件），不能直接在运行时把字符串渲染成元素。
  2. **运行时开销**：MDX 在客户端动态渲染时，包体积和启动成本较高；react‑markdown 只引入一个轻量的运行时库。
  3. **灵活性过剩**：项目中仅需普通 Markdown 渲染，MDX 的能力往往过剩且配置较繁琐。



**XSS 攻击**

**概念：**指**跨站脚本攻击**，攻击者**在网站注入恶意脚本**，在用户浏览器运行，窃取用户信息，调用网站接口执行攻击者操作

**攻击操作：**

- 获取页面的数据，如DOM、cookie、localStorage；
- DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
- 破坏页面结构；
- 流量劫持（将链接指向某网站）；

**攻击类型：**

- **储存型：**恶意脚本储存在服务器上，请求资源时传回（论坛发布，商品评论）
- **反射型：**诱导服务器返回恶意代码的 URL，服务器接收带有 XSS 的数据当作脚本运行（网页搜索，跳转）
- **DOM 型：**通过修改页面的 DOM 节点形成 XSS（ JS 自身的安全漏洞）

**如何防御：**

- **输入验证和过滤：**确保只接受复合预期格式和类型的输入，过滤潜在的危险字符（> < " ’ &）
- **输入编码和转义：**对所有不恶心的数据进行编码 （`<` 转换为 `<`，将 `>` 转换为 `>`），防止解释为 HTML 或者 JS
- **使用安全的库或框架：**React，Vue
- **内容安全策略（CSP）：**能够限制网页允许执行的内容来源，可以防止注入的脚本运行，限制脚本的来源，发送 `Content-Security-Policy` HTTP 头来配置 CSP，如``Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-scripts.com;``



## 15、项目中如何处理的跨域问题

在项目中通过在后端设置CORS，告知浏览器允许的跨域请求

包含：

- 允许来源：Access-Control-Allow-Origin 设置为请求头中的 Origin，即允许所有来源跨域访问。

- 允许的方法：Access-Control-Allow-Methods设置：POST, GET, OPTIONS, PUT, DELETE, UPDATE。

- 允许的请求头：Access-Control-Allow-Headers：如 Authorization、Content-Type、自定义的 Chat-Token、Admin-Authorization 等。

- 允许携带 Cookie：Access-Control-Allow-Credentials: true。



其他的处理跨域方式：

**JSONP**

- 原理: script标签的src不受到同源策略的限制。但是只能使用get请求。
- 后端返回一段js代码，代码的内容是一个前端定义好的函数的调用，把需要返回的内容传递进去。

**代理服务器**

**跨域是浏览器特有的，而服务器和服务器之间不存在跨域**。 前端请求同源服务器，同源服务器充当代理，转发请求至目标服务器，再将结果返回前端，就可实现跨域。

（如果问）可以用打包工具自带的服务器代理请求，解决跨域。也可以通过nginx配置一个代理服务器。

**WebSocket协议跨域**

WebSocket 是一种基于 TCP 协议的双向通信协议，它提供了一种浏览器和服务器之间实时、低延迟、高效率的全双工通信方式，同时允许跨域通讯。

浏览器在发送 WebSocket 请求时，会在请求头中携带 Origin 字段，用于告诉服务器该请求的来源。服务器在收到请求后，会根据 Origin 字段判断是否允许该跨域请求，如果允许，则在响应头中添加 Access-Control-Allow-Origin 字段，告诉浏览器该请求被允许访问。



## 16.遇到过代码冲突吗，怎样解决？

遇到过，在开发完自身代码后，拉取线上最新代码后，有时候可能会产生冲突

或者在改完版本分支的代码想要pick到dev时可能会产生冲突

**当代码提示冲突时解决办法：**

及时与相关开发者沟通，来决定代码是否留存或者改动

解决完所有冲突后，通过 `git add <冲突文件>` 标记冲突已解决，再执行 `git commit` 提交合并结果，完成冲突处理。

先沟通，再合并

**避免冲突的方法：**

1. **频繁同步代码** 每天开发前、开发中（完成一个小功能后）都拉取最新代码，减少本地代码与远程的差异，从源头降低冲突概率。
2. **拆分任务，减少文件重叠修改** 多人协作时，尽量将任务拆分到不同文件或同一文件的不同模块（如 A 负责 `user.js`，B 负责 `order.js`），避免多人同时修改同一文件的同一部分。
3. **使用短生命周期的分支** 基于 `main` 或 `develop` 分支创建 feature 分支，开发完成后**尽快合并**（如 1-2 天内），避免分支长期脱离主分支导致大量冲突。
4. **规范代码风格** 统一代码格式（如缩进、换行）、函数命名规则，减少因 “格式修改” 导致的无意义冲突（可通过 ESLint、Prettier 自动格式化）。

## 17.提交代码前拉取最新代码的方式

当你开发时，在几天前线上基于dev主分支创建的自己的feat分支，并在本地基于该分支进行开发调用，当你开发完成之后，发现你创建的分支落后于dev分支几次提交，这时候的处理办法：

开发过程中拉取最新代码 **先 stash 存改动 → 拉最新 develop → 合并/衍合 → stash pop 恢复 → 继续提交** **step1:把当前改动暂存起来** 这会把你的未提交改动**保存到一个临时栈**里，工作区变干净

```React
git stash push -m "暂存本地改动"
```

**step2:切回 develop 并拉最新**

```React
git checkout develop
git pull origin develop
```

**step3:回到你的分支并合并最新 develop**

```React
git checkout 你的分支名
git merge develop        # 或者 git rebase develop，看团队习惯
```

**step4:把暂存的改动“弹”回来**

```React
git stash pop
```

这会把刚才保存的改动恢复到工作区，并自动从栈里删除。 如果有冲突，Git 会提示，按正常流程解决即可。 **step5:继续开发或提交**

```React
git add .
git commit -m "feat: xxx"
```

**总结**：就是将当前暂存到临时栈中清空工作区之后，将dev最新代码同步到自己的feat分支上之后，在将临时栈中的代码弹回来再提交\

# 项目

## **1、虚拟列表+懒加载**

### （1）简单介绍

在项目的全部房源页面中，会向用户展示目的城市的**海量房源**。如果一次性将这些房源全部渲染出来，可能会导致加载时间过长，房源dom元素过多导致页面卡顿等**性能问题**，所以考虑使用虚拟列表+懒加载实现。

一开始是单纯使用的懒加载，当用户滑动到**靠近列表底部**时，就重新向后端**请求新的数据**并**添加到列表**中再**重新渲染到页面**上。这样由于开始页面中的房源dom很少，所以能够大幅减少首屏加载时间。但如果用户一直向下滑，加到页面中的房源**dom会越来越多**，最后还是会降低性能，造成页面卡顿等等。

所以后来考虑使用虚拟列表+懒加载的方式，同样是接近列表底部请求，区别在于虚拟列表只渲染数据列表中**当前页面以及附近两页**的房源dom，不论列表中有多少数据，都只渲染**有限的一部分**，所以可以避免页面卡顿等性能问题。多渲染两页dom，可避免滑动过快还未渲染，出现白屏。

### （2）具体如何实现的虚拟列表

1、设置**开始索引**和**结束索引**，代表列表**开始渲染的位置**和**结束渲染的位置**。设置**预留两屏的item数**（容器可视高度除以item高度乘五（一行有五列）），然后通过**已划过距离scrollTop**除以单个房源item高度再乘五就是已划过的item数，再减去预留数，得到开始索引，默认是0（通过Math.max(0,上边的操作)）。通过已划过距离scrollTop加上可视区域高度offsetHeigh以单个房源item高度再乘五，再加上预留数，得到结束索引。

2、通过**slice截取到数据列表**中的从开始索引到结束从索引的部分，在页面中进行渲染。

3、还需要计算通过开始和结束索引计算**顶部块**和**底部块**（如果结束索引比列表还长就是0）的高度，用来**撑开进度条**

4、如果划到了靠近列表底部（总高度scrollHeight-已划过距离scrollTop-容器可视高度<距离阈值），就触发请求函数，重新向后端请求数据并加到列表后边

### （3）为什么使用节流函数，起到什么作用

滚轮滚动可能会触发多次滚动事件，造成不必要的性能消耗，快速滚动也可能造成白屏问题。所以考虑采用节流函数来减少滚动触发的次数。

一开始采用的是防抖函数，防抖函数的作用就是短时间内触发多次事件，只执行最后一次，可以有效减少滚动触发的次数。但是在实际操作时出现问题，如果快速滑动滑轮，会导致房源item未渲染出来，页面出现白屏。分析后发现是由于滚动时页面会向下划，但由于速度过快，未达到防抖函数要求的时间，所以防抖函数并未执行，页面未重新渲染，导致白屏问题。

随后改用节流函数，节流函数的作用是触发一次在短时间内就不再次触发，从而既有效减少了滚动触发的次数，由于每次都会成功执行节流函数，也实现了及时渲染，从而顺利解决了白屏问题。



### **（4）如何优化快速滚动时的白屏问题？**

**考察点**：性能优化经验
**解答**：

1. **节流渲染**：使用 **节流函数** 控制滚动事件触发频率。

2. **占位符**：图片未加载时用**骨架屏**填充，提高用户体验。

   骨架屏方案，通过isPending判断是否处于请求中，返回为pending就渲染骨架屏，请求结束就渲染请求到的图片

3. **加载符**：如果滑倒列表底部请求新数据还未返回，同样是通过pending来判断，渲染`加载中...`的盒子，请求结束就渲染新item

### （5）使用**Intersection Observer**

**Intersection Observer** 方案优势：

- 原生API，简化可视区域判断逻辑。
- 自动检测，减少手动计算误差。

**局限性**：

- 兼容性问题（部分旧浏览器不支持）。
- 大量元素监听时性能开销较大（需配合虚拟列表减少节点数量）。

**结论**：结合两者，用虚拟列表控制DOM数量，用Intersection Observer实现了图片懒加载细节。

### **（6） 如何处理动态高度的元素（如高度不固定的图片或文本）？**

**考察点**：复杂场景的解决方案
**解答**：
动态高度需实时测量并缓存，常用方案：

1. **预估高度+惰性测量**：初始用预估高度渲染，元素进入可视区域后测量实际高度，更新缓存并调整布局。
2. **位置缓存表**：维护一个 `positions` 数组记录每个元素的真实高度和偏移量，重新计算后续元素的位置。
3. **ResizeObserver API**：监听元素尺寸变化，动态更新缓存。

**优化**：对已测量的元素跳过重复计算，使用二分查找快速定位滚动位置。

### **（7）如果列表项包含复杂组件（如视频），需要注意什么？**

**考察点**：实际应用细节
**解答**：

1. **组件销毁**：离开可视区域时销毁视频播放器，释放内存。
2. **状态保存**：使用 `keep-alive` 或缓存组件状态（如播放进度）。
3. **懒加载分级**：先加载轻量内容（如缩略图），用户交互后再加载完整资源。
4. **性能监控**：确保单个复杂组件不影响整体滚动性能。

### **（8） 如何测试虚拟列表+懒加载的准确性和性能？**

**考察点**：质量保障意识
**解答**：
**准确性测试**：

- 快照比对：确保不同滚动位置渲染内容正确。
- 交叉验证：手动滚动到特定位置，检查渲染数据与预期一致。

**性能测试**：

- **Chrome DevTools**：通过Performance面板分析FPS、布局重绘（Layout Thrashing）。
- **内存占用**：Memory面板检查是否存在内存泄漏（如未销毁的DOM节点）。
- **大数据压测**：渲染10万条数据，监控滚动流畅度（FPS≥50）。

**自动化工具**：

- Puppeteer模拟滚动并截图对比。
- Lighthouse生成性能报告。



## 2、websocket通信

### （1）简单介绍

​	WebSocket 主要用于朋友页面的前后端双向实时通信，好友之间的聊天功能，以及好友申请、最新消息等都是通过WebSocket实现的。在项目中WebSocket通信的底层是通过我们的一个私有包实现的，通过调用私有包封装好的方法来实现连接的建立与消息的接收与推送，以及其他事件的监听和处理。



### （2）websocket连接建立的大致过程（理论）

​	客户端会先通过一次普通的 HTTP 请求告知服务器“我想把这条连接升级到 WebSocket”，并附带一个用于安全校验的随机值；服务器收到后进行验证并以特殊回应表示同意升级，此时原本的 TCP 连接就从 HTTP 切换到 WebSocket，随后双方即可在同一条持久化连接上进行双向实时通信。 



### （3）项目中websocket的大致流程（项目）

#### 首先是用户点击好友列表中的一个好友

​	点击之后会分发建立连接的全局事件，并携带上会话id以及好友的id，用户名等信息。在对话hook中监听到事件，调用封装好的createSession方法来创建新的对话。



#### 1、建立连接

​	当点击列表中一个朋友时，就会开启对话，建立一个新的websocket连接，过程是：

- 关闭已有连接并清空心跳机制，防止资源泄漏和重复连接。如果是新消息没有会话id就生成一个

- new websocket初始化一个新的websocket连接（通过ref保存 ref.current来注册事件监听），其中地址是参数化拼接的，包括基础URL，用户id、会话id、角色id、模型id等参数，保证每个连接的唯一性和安全性。

- 注册open message close error事件监听器，为后续消息收发和异常处理做准备

- 当打开新对话或切换到历史对话都会触发**open事件**，如果是新对话，通过send向后端发送一条“初始化对话”的消息，后端会在数据库中为该用户新建一条会话记录（ChatItem），并一个**对话已创建**的消息。并建立新的心跳机制

  (初始化消息如果问起详情)包括

  - type: "chat"：表示这是一次聊天消息（但content为空，属于初始化）。

  - content: ""：内容为空，说明不是用户主动输入，而是系统初始化。

  - 其它如 chatId、roleId、modelId等，都是会话的元信息。

  - imageUrls: []：没有图片。

  - useNetwork、useLocalRag：是否联网、是否用本地知识库。



#### 2、如果问起上边这些id如何获取

基础URL通过getURL函数获取，window.location.hostname得到网站的url

用户id通过getSession函数获取，会从localStorage找有没有session，如果没有就通过定义好的**randString**方法生成一个（问起的话，生成方法就是从0-9和a-z中随机通过for循环结合Math.random随机取值获得一个session）

会话id是如果是历史会话则已经存在，直接拼接；如果是新对话则不存在，通过uuid库的方法重新生成一个

角色id和模型id都是确定好的，因为在这两个页面中的角色和模型都是固定的。



#### 3、websocket接收消息

**消息的接收通过监听message事件进行处理**，返回的**event**点**data**里存在消息type用来区分消息类型，根据type判断不同的返回的消息类型并进行不同的处理。（心跳检测、用户输入、AI回复分阶段等）。分阶段推送消息分片，实现ai回复的流式输出。

- 如果类型是心跳检测就直接跳过消息处理，

- 如果类型是用户输入代表后端将用户输入发送回来进行回显，前端存储消息数组是**chatData**，给chatData追加一个新消息对象，包括id 类型prompt 和用户输入内容content，随后渲染到页面上。不过回显后来不再使用了，改为用户点击发送后直接从前端将新的消息对象追加到chatData数组中。这是因为回显操作虽能保证前后端数据一致，但当前后端通信出现问题时，前端用户收不到后端返回的回显，连自己输入的内容都无法出现再页面上。改为从前端直接追加，当出现网络问题时至少能显示出用户的输入，体验好一些。

- 如果类型是对话已创建，就通过get获取由新对话的历史会话列表，链接由用户id和角色id决定。这里未进行更改，因为历史会话列表希望追求前后端一致性，所以等接收到后端返回的对话已创建的消息后再对chatData进行更新并渲染。

  剩下的是ai回复的输出部分，与ai输出有关的有**start**、**chat**、**end**三种类型。前端存储消息数组**chatData**，当类型为**start**时，代表AI 开始输出，往chatData中push一个**新的消息对象**准备**接收输出内容**，对象包括新消息的**id**（后端传过来的）、**内容**（空字符串）和消息**类型**（reply），并禁用发送按钮和重新生成按钮，启用停止生成按钮。当类型为**chat**时，代表AI正在**输出内容的分片**，将这个内容分片**追加**到当前消息对象（通过id确定）的内容里并重新渲染到页面上。当类型为end时，代表这个消息的结束，启用发送按钮和重新生成按钮，禁用停止生成按钮。



#### 4、websocket发送消息

​	发送消息会触发sendMessage函数，先判断ai是否正在回答或发送内容是否为空（prompt.value.trim.length）。如果没问题，一是将用户输入的内容作为新的消息对象push到chatData中，包括id（前端randString生成的），类型prompt，用户输入内容content，以及已上传图片的URL。二是通过send事件将消息对象发送给后端，里边包含（用户输入的内容，消息类型，会话id模型id和角色id，上传图片的URL，是否使用联网搜索和数据库等）。



#### 5、关闭连接

​	当退出登录，关闭页面，切换对话等操作都会关闭连接，通过触发close事件实现。并将心跳检测清空。在ai正在生成回复的时候，如果用户**点击停止按钮**，或者是**切换到其他会话**，都会**停止**当前进行的流式输出。具体来讲，项目通过状态变量来控制**是否正在渲染**，在**message**事件中对其进行判断，如果为false就直接结束事件，**不再执行**接下来的渲染过程。当点击停止按钮或切换其他对话时，就会调用**停止函数**，将状态变量设置为false，并向后端通过**webSocket.send**发送**停止生成**的信号，信号类型为stop并包含当前消息id，然后通过**webSocket.close**关闭通信。后端接收到停止生成信息后，立即发送给大模型服务器，让大模型停止继续生成。从而实现了流式输出的停止。



#### 6、错误重连

​	当连接发生错误时会触发error事件，前端会尝试进行重连。具体的过程是，先再外部确定好最大重连次数5次，重连间隔时间3秒；并定义连接次数。每次创建websocket连接时，在open事件触发时都会重置连接次数。如果发生错误时，达到重连间隔时间就会重新调用连接函数，并将重连次数+1。到最后如果重连次数超过最大重连连接次数就不再继续尝试，触发close事件关闭websocket连接，并给用户弹出错误信息。

```js
let socket = null;
let reconnectTimer = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_INTERVAL = 3000; // 3秒

function connect() {
  // ...参数拼接略
  socket = new WebSocket(wsUrl);

  socket.addEventListener("open", () => {
    console.log("WebSocket连接已打开");
    reconnectAttempts = 0; // 重置重连次数
    // 启动心跳、注册消息监听等
  });

  socket.addEventListener("message", onMessage);

  socket.addEventListener("close", () => {
    // 这里一般不自动重连，除非你想支持“意外断开”场景
    // 可以根据业务需求判断是否需要重连
  });

  socket.addEventListener("error", (error) => {
    console.error("WebSocket连接错误:", error);
    // 避免多次重连
    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
      reconnectAttempts++;
      reconnectTimer = setTimeout(() => {
        console.log(`WebSocket重连第${reconnectAttempts}次...`);
        connect();
      }, RECONNECT_INTERVAL);
    } else {
      console.error("WebSocket重连失败，已达最大次数");
      // 可以提示用户“网络异常，请刷新页面”
    }
  });
}
```



#### 7、心跳检测

​	在项目中，每30秒通过send发送一条{ type: "heartbeat", content: "ping" }的消息到后端，并记录一个“等待回应”的状态。后端接收到后，也会返回一个心跳检测的消息{ type: "heartbeat", content: "pong" }代表心跳检测，前端清除“等待回应”状态。如果下次发送心跳包时，上一次的回应还没收到，即仍然处于等待回应状态，就认为连接异常，可以主动关闭WebSocket并触发重连。

​	在连接成功时启动心跳检测，定时发送心跳消息。在连接断开或发生错误时停止心跳检测。

```js
let socket = null;
let heartbeatInterval = null;   // 心跳定时器
let waitingHeartbeat = false;   // 是否在等待心跳回应
const HEARTBEAT_INTERVAL = 30000; // 30秒发送一次心跳

function connect() {
  socket = new WebSocket("ws://yourserver/ws");

  socket.addEventListener("open", () => {
    console.log("WebSocket已连接");
    startHeartbeat();
  });

  socket.addEventListener("message", (event) => {
    const data = JSON.parse(event.data);
    if (data.type === "heartbeat") {
      // 收到心跳回应
      waitingHeartbeat = false;
      // 你可以在这里做一些连接状态的UI提示
    } else {
      // 处理其他类型消息
    }
  });

  socket.addEventListener("close", () => {
    stopHeartbeat();
  });

  socket.addEventListener("error", (error) => {
    stopHeartbeat();
  });
}

function startHeartbeat() {
  stopHeartbeat(); // 防止重复定时
  heartbeatInterval = setInterval(() => {
    if (waitingHeartbeat) {
      // 上一次心跳还没回应，说明连接异常
      socket.close(); // 触发close事件，自动重连
      return;
    }
    // 发送心跳包
    waitingHeartbeat = true;
    socket.send(JSON.stringify({ type: "heartbeat", content: "ping" }));
  }, HEARTBEAT_INTERVAL);
}

function stopHeartbeat() {
  clearInterval(heartbeatInterval);
  waitingHeartbeat = false;
}

// 启动连接
connect();
```

**为何选择前端发ping后端发pong？**

​	1、**客户端主导监测**：只要后端不返回 `pong`，前端就能立即做出重连判断，能够恢复连接。主导权掌握在自己手里。

​	2、项目规范，在之前的项目中有使用到心跳检测都是前端发ping后端发pong

**如何通过后端发ping而前端发pong**

**流程示例**

1. **后端** 每隔固定时间（比如 30 秒）主动向所有已连接的 WebSocket 客户端广播一条心跳消息：

   ```json
   { "type": "heartbeat", "content": "ping" }
   ```

2. **前端** 一旦收到这条 `{ type: "heartbeat", content: "ping" }`，马上返回：

   ```json
   { "type: "heartbeat", "content": "pong" }
   ```

3. **后端** 在发送 `ping` 后，给自己打个“已发送心跳，还在等待 pong”标记；如果在下次期望收到 pong 的时限（比如 5 秒内）没收到前端回来的 `pong`，就默认客户端掉线／断网，直接把 WebSocket 关掉或标记为“失效”，并决定要不要在后端层面进行重连或通知上游逻辑。



### （4）自定义的消息格式是怎样的?

发送消息格式

```json
socket.current.send(
    JSON.stringify({
      type: "chat",	// 消息类型
      content: content,	// 消息内容
      chatId: curChatInfo.value.chatId,	// 会话id
      roleId: roleId.value,	// 使用的角色id
      modelId: modelId.value,	// 使用的模型id
      imageUrls: imageUrls, // 图片URL数组
      useNetwork: isUseNetwork.value,	// 是否使用联网搜索
      useLocalRag: isUseLocalRag.value,	// 是否使用本地知识库
    })
  );
```

返回消息格式

```
type	// 消息类型
text	// 消息内容
chatId	// 消息id
roleId	// 使用的角色id
modelId	// 使用的模型id
```

### （5）轮询、长轮询和websocket的对比

#### 1. 基本原理

**1.1 轮询（Polling）**

- **原理**：客户端以固定的时间间隔（如每隔 1 秒或 5 秒）向服务器发送一次 HTTP 请求，询问服务器是否有新数据。如果服务器有新数据，则在响应中返回；否则返回空或状态标示客户端继续下一次轮询。
- **连接方式**：一个独立的短链接（HTTP 请求-响应）完成一次查询后即断开，下次查询时重新建立连接。

**1.2 长轮询（Long Polling）**

- **原理**：客户端向服务器发起一次 HTTP 请求，如果服务器端暂时没有新数据则保持此请求（不立即返回），直到有新数据可用时才返回响应；客户端收到数据后立即发起下一次长轮询请求，如此循环。相当于“服务端先等数据准备好再回复，客户端收到后马上重连”。
- **连接方式**：与轮询类似，依旧是一次请求对应一次响应，但服务器可以“延迟”响应以减少空回应。每次响应后，客户端重新开启新的连接。

**1.3 WebSocket**

- **原理**：基于 HTTP/1.1 的一次“握手”升级（Upgrade）请求，将连接从 HTTP 协议切换到 WebSocket 协议；握手完成后，客户端与服务器之间建立起一个**持久双向**的 TCP 连接，双方可随时互发消息，无需再次建立 HTTP 请求。
- **连接方式**：一次握手后创建长连接，后续在同一连接上双向通信。

#### 2. 优缺点对比

**3.1 连接建立与开销**

- **轮询**：每次轮询都是一个完整的 HTTP 请求/响应周期（包括 TCP 建立三次握手、TLS 握手（若使用 HTTPS）、请求报头 + 响应报头等）。如果轮询间隔设置得很短（如 1 秒），会产生非常大的网络开销和服务器压力。
- **长轮询**：客户端发出一次请求后，如果服务器暂时没有可用数据，便“挂起”此请求并保持连接一段时间（通常服务端会设置超时时间，如 30 秒）。当出现新数据时立即响应，否则在超时后返回“没有数据”，然后客户端再发起新请求。这样能大大减少“空回应”的次数，但在数据空闲期仍会维持一定数量的长连接。
- **WebSocket**：通过一次 HTTP 握手，将连接升级为 WebSocket。之后无需多次握手，客户端与服务器之间在同一 TCP 连接中互发数据。省去了每次都建立连接和关闭连接的开销，只需传输很少的 WebSocket 报头，即可实现低开销的双向通信。

**3.2 实时性与延迟**

- **轮询**：实时性最差。假设轮询间隔为 5 秒，服务器在第 1 秒左右产生一条新消息，客户端要等到第 5 秒才能下一次请求拿到数据。平均延迟约为 `轮询间隔 / 2`。
- **长轮询**：实时性较好。服务器一有新消息就立即返回响应，客户端马上收到并处理，响应时间仅受网络往返的影响。缺点是客户端收到一次响应后，要重新发起新的 HTTP 请求才能继续“保持等待”状态，这中间会有极短暂的延迟（毫秒级）。
- **WebSocket**：实时性最好。客户端与服务器在同一连接里，任一方随时都能“推送”消息，网络往返延迟几乎与纯 TCP 消息传输相同，没有额外的重连耗时。

**3.3 服务器资源和并发**

- **轮询**：短连接模式，每次请求都创建、处理、关闭连接。若并发用户数高、轮询间隔短，将导致服务器频繁创建/销毁连接，造成 CPU 与内存压力，网络带宽浪费也很严重。
- **长轮询**：每个活跃客户端至少会有一个“挂起”的 HTTP 连接，即使在长时间没有新消息期间也占用一个 TCP 连接。相比轮询，减少了空回应次数，但当用户量极大时也可能出现大量长连接，需要服务器以“异步非阻塞”或“事件驱动”的方式进行优化，防止线程/进程数爆炸。
- **WebSocket**：与长轮询类似，保持着持久 TCP 连接。不同的是，不仅能接收数据，也能主动向客户端推送。服务器需要维护这些持久连接的状态（如每个连接对应的会话、心跳检测等），如果使用不当（如线程模型不合理），并发量大时同样会出现瓶颈。但由于协议层面更加轻量（没有 HTTP 报头的开销），整体吞吐通常更高，更适合持续双向通信。

### （6）webSocket和sse对比

#### 1. 通信方向

- **WebSocket**：双向（full‑duplex），客户端和服务端可以随时相互推送消息，无需重新建立连接。
- **SSE（Server‑Sent Events）**：单向，只能从服务端向客户端推送数据，客户端若要发送消息，必须另起 HTTP 请求（如 POST）。

#### 2. 延迟与效率

- **WebSocket**：一次握手后保持 TCP 连接，消息帧头开销小，适合高频、低延迟交互。
- **SSE**：基于 HTTP 长连接，消息以文本流方式输送，每条消息带有一定格式开销，且在 HTTP/2 下可能受“队头阻塞”影响。 

#### 3. 实现复杂度

- **SSE**：客户端原生支持 `EventSource`，自动重连简单易用；服务端实现也较轻量。
- **WebSocket**：需处理握手、心跳、断线重连等逻辑，实现复杂度略高。

#### 4、为什么在项目中前端和后端之间使用webSocket，而后端和大模型端使用sse，这样的好处是什么

1. **端到端低延迟的流式体验**
   - 后端直接对接大模型的 `text/event-stream`，一有新 token 就马上拿到并透传，不用等完整响应。
   - WebSocket 长连接在前端随时可推，实现“用户输入 → 模型输出”几乎无缝的流水线感。
2. **职责分离，协议各司其职**
   - **SSE**（`text/event-stream`）天然适合后端与模型 API 这种“服务端→服务端”单向、高并发的流式推送，简单可靠。
   - **WebSocket** 则更擅长“服务端←→客户端”双向交互，不仅可以推送模型消息，也可实时接收前端的控制指令（比如取消、修改参数、心跳等）。
3. **更灵活的错误处理与重连策略**
   - 后端与模型 API 之间发生错误时，可以在这一层做重试等错误处理，和前端的 WebSocket 断线重连逻辑互不干扰。
   - 前端也只需关心 WebSocket 的生命周期和重连策略，屏蔽了模型 API 端的细节。
4. **安全与认证边界清晰**
   - 后端统一管理对大模型 API 的访问密钥、限额、审计日志等，避免将敏感凭证泄露到前端。
   - 前端只需与后端建立 WebSocke，简化客户端安全设计。
5. **可观测性与监控**
   - 在后端切面可以对 SSE 流量（如每秒 token 数、平均延迟）做精细监控。
   - WebSocket 连接数、带宽、RTT 也可独立监控，从而快速定位是模型 API 侧瓶颈还是客户端网络问题。
6. **演进路径灵活**
   - 日后若要支持其它流式源（自研模型、不同云厂商），只需要在后端适配新的 SSE 接口，前端无感知。



### （7）历史会话

#### （1）如何获取的历史会话列表数据？

​	在项目的websocket连接中监听的Message事件，返回的**event**点**data**里存在消息type，根据type判断不同的返回的消息类型并进行不同的处理。在打开页面后，会返回一个conversation_created的类型消息，这个消息代表已创建的历史会话。前端得到这个消息后，就向后端通过get获取历史会话列表，拿到后存储起来渲染到页面上。

#### （2）如何实现历史对话的切换？

​	在项目中，每个对话都有其对应的独一无二的会话id，通过会话id就可以判断是哪一段对话。切换历史对话时，会触发changeChat函数，将这一历史对话的id传进去。

在函数中

1、如果当前有正在进行的会话，先关闭掉websocket连接，清空心跳检测。然后清空存储当前多轮对话的chatData数组并重置当前对话信息，将其中的id改为历史会话的id

2、通过get将历史会话id传到后端，获取到对应历史会话的多轮消息，将这些新获取到的消息遍历存入chatData数组中，成为当前对话消息

3、将历史会话渲染到页面上，调用函数重新建立webSocket连接

在切换到历史对话后，用户可以接着就之前的话题进行问答。因为AI具有上下文记忆的功能（大模型端本身具有的功能，如果没有这个功能，可以由后端在向大模型发送用户消息时，带上之前几条的历史对话），所以可以无缝衔接，继续讨论之前的问题。



### （7）如果两个用户之间通过websocket进行聊天，中间有服务器，大致描述一下这个过程应该如何实现

​	用户A（浏览器） ⇄ WebSocket ⇄ 服务器 ⇄ WebSocket ⇄ 用户B（浏览器）

​	实现步骤（概述）

#### 1️⃣ 客户端连接 WebSocket 服务器

用户A 和 用户B 都通过 WebSocket 建立连接，new一个WebSocket，链接是服务器：

```
const socket = new WebSocket('ws://your-server.com');
```

当连接建立后，可以open事件监听连接状态：

```
socket.onopen = () => {
  console.log('Connected to server');
};
```

#### 2️⃣ 客户端发送消息

用户A 发出消息给用户B，通过send发送：

```
socket.send(JSON.stringify({
  type: 'chat',
  to: 'userB-id',
  from: 'userA-id',
  content: '你好！'
}));
```

#### 3️⃣ 服务器接收并转发消息

服务器通监听message事件，接收到用户A的消息后，查找用户B对应的 WebSocket 连接，然后将通过send消息转发过去。

伪代码如下（Node.js 示例）：

```
const clients = new Map(); // userId -> WebSocket

wsServer.on('connection', (socket) => {
  socket.on('message', (raw) => {
    const msg = JSON.parse(raw);
    const toUserSocket = clients.get(msg.to);
    if (toUserSocket) {
      toUserSocket.send(JSON.stringify({
        from: msg.from,
        content: msg.content
      }));
    }
  });
});
```

#### 4️⃣ 接收方收到消息并展示

用户B 的前端同样通过message事件监听 WebSocket 消息：

```
socket.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  displayMessage(msg.from, msg.content);
};
```

### （8）axios二次封装

#### 为什么要对axios进行二次封装？

对 Axios 的二次封装主要是为了**统一管理网络请求逻辑**，通过拦截器**全局处理错误提示**、**Token 鉴权**、**处理参数格式**等，减少重复代码；同时规范数据响应结构（如自动提取嵌套数据），**简化api（如get，post）调用方式**（如统一设置参数，统一返回 `[err, data]` 格式），并支持扩展缓存、重试等定制功能，最终提升代码复用性、维护性及项目协作效率。

#### 项目中进行了哪些封装？

**1. 基础配置**

- 动态获取后端 API 域名

设置 getBaseURL() 方法，根据当前前端页面的域名自动切换对应的后端 API 地址，方便在不同环境（如测试、生产）下自动适配。

- axios 全局配置

设置了请求超时时间、基础 URL、跨域携带 cookie、默认请求头（如 Content-Type、Authorization、Chat-Token 等）。

**2. 动态请求头处理**

- 设置 getDynamicHeaderData() 方法，动态获取用户的 token、sessionId 等信息，并在每次请求时自动加到请求头里，保证接口安全和用户身份校验。

**1、对get和post这些api进行了封装**

以get api为例，封装了一个新的get函数来获取各项数据，里边调用axios.get(url, params)方法，参数是请求路径url和和要查询的查询参数params。在then中处理请求结果，通过res.data获取到数据。获取成功就用resolve返回数据。请求失败通过catch接到，用rejected返回一个error。

post情况也类似，调用axios.post方法，传入请求数据与URL，在then中处理数据并返回，在catch中处理错误并返回

**2、对请求拦截器进行了封装**

请求拦截器是通过`axios.interceptors.request.use`，对config赋值实现，每次请求前调用getDynamicHeaderData()方法，自动添加动态请求头。

**3、对响应拦截器进行了封装**

对后端返回的数据进行统一处理，只有 code === 0（即请求成功）时才返回数据，否则抛出错误，方便前端统一处理异常。



## 3、模糊查询 多条件精准查询 useActionState 排序 防抖函数

#### 简单介绍：

**（1）搜索功能**

在项目的全部房源页面中，有着搜索功能，可以在输入框中输入想要查询的字符串，点击搜索按钮后就可以匹配到标题中有相应字符串的房源渲染在页面上，这个过程通过模糊查询实现。在搜索框输入时还会有一个下拉菜单，可以根据输入值实时显示匹配到的前五条房源标题，也是应用到了模糊查询，同时还做了防抖处理，防止高频输入造成多次渲染的性能问题。

**（2）条件筛选功能**

在项目的全部房源页面中，有条件筛选功能，可以根据人数、价格、位置条件来筛选房源。通过多条件精准查询来实现这一功能。

### （1）模糊查询简单介绍

全部房源页面中有搜索功能，可以匹配并渲染出标题中有搜索字符串的房源item。搜索功能主要应用到了模糊查询。模糊查询的基本原理是对房源数据列表通过filter进行遍历，对每个遍历到的item取标题，通过includes判断标题中有没有要搜索的字符串，有返回的就是true，item添加到filter得到的新数组里边。搜索时还具有搜索建议功能，使用onChange根据表单的输入值，通过下拉菜单实时展示出通过模糊搜索匹配到前五条的房源标题。

### （2）多条件精准查询简单介绍

全部房源中页面中有筛选功能，可以按照人数，价格，位置条件对房源item进行筛选。条件筛选功能应用到了多条件精准查询，基本原理也是对房源数据列表通过filter进行遍历，对每个遍历到的item取到人数，价格，位置这些属性，与条件进行比较，再对比较结果进行短路判断，如果都返回true的才返回到filter新数组内（短路判断时将高淘汰率的条件（如位置）放在判断逻辑前端，快速跳过不符合项）。

### **（3）useActionState**的尝试使用

在全部房源页面的代码中，存在搜索框、人数、价格、位置等多个表单元素，需要通过**useState**设置**多个状态变量**来保存并操作这些表单的内容，比较繁琐。之后了解到react19新api `useActionState`的更新，可以更好地**控制表单的action状态**，无需多个状态变量，于是尝试使用在了项目内。

`const [state, action, isPending] = useActionState(fn, null)`

`useActionState`有两个参数，第一个是**处理表单提交内容的回调函数**，第二个是初始值。回调函数由两个参数**prevData**（之前的表单数据）和**formData**（现在的表单数据）。可以得到通过formData参数得到各个表单的内容，通过**formData.get('表单名')**就能得到相应表单的内容。在项目中我先得到各个表单的内容，再**传入筛选函数**（通过filter进行模糊查询和精准查询的函数），最终筛选后的数组**返回出去**。

`useActionState`有三个返回值，第一个返回值是执行回调函数后**返回的状态**，在项目中就是返回的**筛选后的新数组**。第二个就是返回值action函数，react19更新后form的action属性可以**绑定要执行的action函数**，绑定后表单就可以执行相应的函数（相当于给之前的onSubmit加上以后个handle什么什么)。第三个返回值是判断表单提交**状态的isPending**，为做到在action函数**执行时无法再次提交**，通过isPending判断**button按钮是否禁用**（添加disabled属性），如果函数中有异步网络请求，这个功能更加有用。

这几个表单元素都是提交后获得的，所以使用useActionState。

### （4）排序的实现

通过一个状态变量来保存是通过价格还是评分进行排序。然后向后端发送请求，过程中设置isPending状态变量处理请求状态，请求状态中渲染一个蒙层到页面上。不使用useActionState是因为希望一改变状态变量就请求，而useActionState是提交后才执行，所以不使用。

### （5）防抖函数

在搜索框输入时，会展示一个搜索建议的下拉表单，包含前五条根据当前搜索字符串匹配到的房源item的标题，通过onChange获取搜索字符串。为解决高频输入时的性能问题，通过防抖对函数进行包裹，只在最后一次触发后才执行，解决了问题。



### 问题1：为什么不通过后端实现

这个项目是和实验室后端的同学一同配合实现的，做到搜索和筛选功能呢时后端的同学已经出去实习了，没时间再做搜索和筛选的接口，所以退而求其次选择从前端实现。当然从后端实现肯定是更完美的方案，因为项目使用的是懒加载，所以数据列表中只有已经请求到的房源数据。将搜索字符串和条件都传到后端，再由后端从全部房源数据中进行筛选，肯定是更合适的。

### 问题2：**多条件筛选采用`filter`链式遍历，如何保证多条件组合查询的效率？**

1. **短路判断**：将高淘汰率的条件（如位置）放在判断逻辑前端，快速跳过不符合项
2. **条件变化监听**：仅当筛选条件变化时重新计算，避免重复执行。具体实现是通过回调函数的第一个参数prevData可以保存上一次的表单提交的内容，与本次进行对比，如果相同就直接返回上一次过滤后的数据即可。

### 问题3：**搜索建议如何实现？**

在输入框输入时，会触发搜索框的onChange事件，给事件绑定上了函数来设置状态变量并调用模糊查询，将前五条匹配到的房源标题渲染到下拉菜单里边。这个过程中使用了防抖函数来控制快速输入的情况。（不使用useActionState是因为不是提交而是实时改变，所以要用onChange）

### 问题4：**如何处理用户输入的特殊字符或SQL注入风险？**

1. **前端过滤**：对搜索输入进行清理（如移除`<script>`标签）

```
const cleanInput = input.replace(/[<>]/g, '') 
```

**2.使用CSP **

CSP 通过设置HTTP 响应头，**限制浏览器只能加载指定来源的资源**，从而防御 XSS 攻击和数据注入。主要防护能力包括：

- 阻止未经允许的内联脚本（`<script>`标签）
- 禁止加载外域恶意脚本
- 阻止未授权的资源加载（图片、字体等）
- 禁用危险的 `eval()` 等函数

### 问题5：如何控制下拉菜单的显隐

设置一个状态变量来控制，当光标位于搜索框时（通过onFocus）设置为true，点击到搜索框外部时（通过e.target.closest('盒子类名')得到点击的是哪个盒子）就设置为false，通过短路逻辑判断是否显示。

### 问题6：如果一个item里有多种类型房间怎么办

1、通过useSelector获取到数据列表

2、对数据列表进行map遍历，并对每个item通过filter对房间进行筛选，获得返回符合条件的房间的数组，并重新设置item对象，修改房间属性为新数组。

3、对数据列表进行一次filter遍历，将不符合条件的酒店item过滤出去（item.rooms.length需要大于0），并将过滤后的数据列表保存到redux中。

4、点击房源item时，通过过滤后的数据列表将房间信息传进去，保证只有符合条件的房间。

## 4、防抖与节流

### 一、防抖（Debounce）

- **防抖**：在事件被频繁触发时，只在 **最后一次触发** 后经过指定的等待时间才执行一次回调。依靠这个机制可以有效避免高频调用事件造成性能问题
- **常见场景**：输入框实时搜索、窗口 改变大小等。

------

实现防抖简单来讲就是将原函数进行包装，设置一个变量来存储定时器，并返回一个闭包函数，闭包函数里边里边是包着原函数的定时器以及判断逻辑。监听事件触发后会调用这个闭包函数，需要根据变量判断上一次的定时器是否还存在，如果依然存在就清除掉并给变量设置新的定时器。如果某一次达到事件间隔事件未被触发，定时器没有被清除，就执行定时器中的原函数。

- 如果问起怎么执行原函数：**注意 `this` 绑定**：如果原函数使用到了this，例如依赖对象的方法内的 `this.xxx`，为了保持原函数的调用上下文，我们使用 `fn.apply(this, args)`，同时能够实现立即执行。
- args指的是剩余参数，调用防抖函数时会传入参数，`args` 的作用就是**收集并传递**防抖函数被调用时的所有参数，保证原函数 `fn` 能拿到它们。

完整代码：

```js
function debounce(fn, delay) {
  let timerId = null;
  
  return function(...args) {
    // 如果已有定时器，先清除
    if (timerId) {
      clearTimeout(timerId);
    }
    
    // 设置新的定时器
    timerId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

```



------

### 二、节流（Throttle）

#### **核心思想**

**固定时间间隔内只允许函数执行一次**。无论事件触发多频繁，执行频率都会被严格控制。

**实现思路**：**时间戳版**：每次触发时，用当前时间减去上次执行时间，若超过间隔则执行。

​		**定时器版**：第一次触发立即执行，然后在定时器运行期间屏蔽后续触发；定时器到期后才允许再执行。

**实现步骤**：时间戳版：1、在节流函数中初始化状态变量， 记录上一次函数执行的时间戳

​					2、**返回闭包函数**，用于替代原函数绑定到事件上。该包装函数内部可访问并更新上面声明的状态变量。

​					3、在**包装函数内部实现核心逻辑**，先通过Date.now()获取当前时间戳；然后判断 当前时间戳减去上一次时间戳是否大于要求的事件间隔。若满足则执行原函数并更新上一次时间戳为当前时间戳。

‘定时器版：1、在节流函数中初始化状态变量， 记录上一次函数执行的定时器

​		    2、**返回闭包函数**，用于替代原函数绑定到事件上。该包装函数内部可访问并更新上面声明的状态变量。

​		    3、**在包装函数内部实现核心逻辑**，如果状态变量有定时器，代表还没有达到时间间隔，直接 `return`（忽略本次触发）。如果没有，就代表已经达到时间间隔，执行原函数，并给状态变量设置新的定时器。

**使用场景**：页面滚动scroll事件控制，拖拽事件等

#### **代码实现（时间戳版）**

```js
function throttle(func, interval) {
  let lastExecTime = 0; // 闭包保存上次执行时间
  return function(...args) {
    const now = Date.now();
    if (now - lastExecTime >= interval) { // 时间间隔外触发则执行
      func.apply(this, args);
      lastExecTime = now; // 更新时间戳
    }
  };
}
```



## 5、PictureBrowser组件

### 简单介绍：

在房源的详情页面中，封装了一个PictureBrowser这么一个图片浏览器组件来帮助用户更好地浏览房源图片。点击**显示更多照片**后，就可以进入到图片浏览器。右上角是一个**叉号**，点击就可关闭图片浏览器。图片浏览器**中央是一张房源图片**，**左右两边是箭头**，点击箭头图片就会**向前或向后切换一张**。切换时通过**第三方库 react-transition-group**对图片**传入传出动画效果**进行优化。图片下方是**indicator图片指示器**，按顺序展示当前图片与附近的六张图片（一共七张，都是略缩图），其他图片都用阴影覆盖。点击箭头后，图片指示器也**跟着切换图片**。当前图片位于房源图片列表**首或尾**时，图片指示器**按照顺序切换位置**，位于图片列表**中间**时，切换的图片**始终位于图片指示器中间**。而**点击图片指示器**中的图片，中央展示的图片就**切换到相应图片**，图片指示器的切换遵循之前同样的逻辑。由于逻辑较复杂，所以又封装了一个indicator组件来实现这一功能。图片浏览器中还有一个选择指示器显示与否的按钮。以上就是图片浏览器的大致功能。

### 问题1：如何通过react-transition-group优化动画效果

1、通过状态变量保存点击的是左箭头还是右箭头，点击箭头就会触发函数进行设置，并将新图片重新渲染上去

2、通过react-transition-group中的CSSTransition组件将图片包裹，设置单一盒子的动画效果。

内部属性：in来控制动画触发与否，key确保多个组件切换时都有唯一标识，classNames设置类名，timeout设置动画时长

动画的样式：根据CSSTransition属性确定的类名决定，直接在`类名-enter/类名-exit`设置开始动画效果，`类名-enter-active/类名-exit-active`设置结束的动画效果，结束样式中要包括transition设置过程，如transition: all 200ms ease，代表动画效果200ms，先慢后快后慢。

3、使用SwitchTransition标签处理两个组件之间切换的过程。通过mode属性来控制切换方式，"out-in": 当前组件先退出，新的组件再进入。"in-out": 新的组件先进入，当前组件再退出。子组件必须使用 CSSTransition 或 Transition，并确保 key 属性唯一。

### 问题2：React Transition Group（RTG）相比原生 CSS 或 JavaScript 动画方法，在 React 生态中有以下核心优势：

------

#### 1. **组件化生命周期管理**

RTG 提供 `Transition`、`CSSTransition`、`SwitchTransition` 等组件，**无缝集成 React 的生命周期**。

- 自动处理组件挂载（mount）和卸载（unmount）的时序问题。
- 原生方法需要手动用 `setTimeout` 或 `useEffect` 控制 DOM 元素的移除时机，容易导致动画未完成元素就被销毁的问题。

------

#### 2. **解决组件卸载动画难题**

原生 CSS 无法直接处理组件卸载时的动画（如元素消失的 `exit` 动画），因为 React 会立即移除 DOM 节点。

- RTG 通过**保留 DOM 节点直到动画完成**（如 `exiting` 状态结束后），确保退出动画能完整播放。

------

#### 3. **声明式 API 与状态驱动**

通过 `in` 属性控制动画状态（进入/退出），**状态变化自动触发动画流程**。

- 原生方法需要手动添加/移除 CSS 类或操作 DOM，代码冗余且易出错。
- 示例：通过 `in={isVisible}` 即可触发元素的进入/退出动画流程。

------

#### 4. **跨动画库兼容性**

RTG **不依赖具体动画实现**，可自由搭配 CSS、GSAP、Anime.js 或 React Spring。

- 原生 CSS 动画需硬编码 `@keyframes` 或类名，灵活性低。
- 示例：用 `CSSTransition` 直接绑定 CSS 类名，或用 `Transition` 结合 JS 动画库。

------

#### 5. **复杂场景简化**

- **路由切换动画**：通过 `SwitchTransition` 实现组件切换时的平滑过渡。
- **列表动画**：结合 `TransitionGroup` 管理动态列表项的增删动画，避免手动跟踪每个元素的 key 和状态。

### 问题3：**Indicator 的滚动策略如何实现**

滚动策略的核心是 **视口居中算法**

1、所有图片都放在一个盒子的内容中，盒子展示区宽度固定，改变的其实是盒子内容的位置，默认图片从第一个开始，盒子所以在最右边。

2、图片切换后，得到新图片的索引，从而获取到图片对应的宽度clientWidth和离左侧父盒子边缘距离offsetLeft。

3、获取到盒子显示区的长度和内容长度，通过**左侧距离+盒子本身宽度*0.5-显示宽度**计算出距离，得到要盒子要移动到的位置，从而使得当前图片居中

4、如果位于头部，计算出距离会小于零，这种情况就不移动盒子。同理如果位于尾部，计算出距离会超过盒子内容宽度，同样也不移动盒子

## 6、前端优化方法

### 1、路由懒加载

**传统问题**：所有路由组件打包到单一JS文件，导致首屏加载缓慢，

**作用**：通过路由懒加载将应用拆分为按路由分割的代码块，初始仅加载核心框架，仅在用户导航到对应路由时才会加载相应资源，可以减少初始加载体积，大幅提高首屏加载速度。

**如何使用**：在react中，通过lazy实现懒加载。用Lazy将一个导入组件的箭头函数包裹起来，用Suspense组件来处理路由导入过程中的加载过程，如果请求状态是pending就通过fallback属性来渲染加载过程中显示的内容，在我的项目中是在路由切换过程中显示一个白色透明蒙层。

**底层原理**：实现路由懒加载的底层原理主要依赖于**代码分割**与**动态加载**技术，其核心思路是把整个应用拆分为多个独立的代码块（chunk），只有在用户真正访问某个路由时才加载对应的代码，从而减小初始加载包的体积，加快首屏渲染速度。下面是具体的原理和步骤：

1. **代码分割**
    使用打包工具（如 Webpack、Rollup 等）将应用按路由或功能模块拆分成多个独立的代码块。这样每个路由对应的组件和依赖会被打包到单独的文件中。
2. **动态导入（Dynamic Import）**
    利用 JavaScript 的 `import()` 函数实现动态加载。例如，当用户导航到某个路由时，路由配置中会触发动态导入操作，返回一个 Promise，等待模块加载完成后再进行渲染。
3. **缓存机制**
    一旦动态加载成功，对应的代码块会被缓存（通常浏览器层面已经缓存该文件），避免重复请求，提高用户体验。

### 2、图片懒加载

**简单介绍**：

在全部房源页面里，存在大量带图片的房源item，如果直接加载所有图片，肯定会造成性能问题，给用户带来较差体验，所以采用图片懒加载的方式。

**实现过程**：

房源 Item 组件中，整体房源信息（如标题、价格和加入购物车按钮）直接渲染，而房源图片则交由 LazyImage 组件处理，从而实现按需加载图片，提高页面加载效率。

LazyImage 组件内部使用了 React 的 **hooks**（useState、useEffect 和 useRef）来管理**图片加载状态**。组件首先通过 **useRef** 获取图片 **DOM 元素**，并用 useState 管理图片**是否加载完成（isLoaded）**和图片**是否加载失败**（**hasError**）的状态。核心部分是利用 **Intersection Observer** API 监听图片元素是否**进入视口**。开始时为所有图片元素加上观察，当检测到图片元素的**可见度超过设定的阈值**（threshold 0.1）时（即进入视口），就会将图片的datasrc中的图片地址赋值到src中，从而加载图片，并结束观察。如果图片加载成功，触发img元素onLoaded事件，更新加载状态为true，让真正的图片得以显示；如果加载失败，则触犯onError事件，将错误状态置为 true，并展示相应的错误提示。

在图片加载未完成的期间，组件使用 **antd** 的 Skeleton.Image 显示**骨架屏**，作为占位效果，以提升用户体验。只有当图片加载成功时，真实的图片才会被展示，并且通过 CSS 样式设置为覆盖整个容器，同时保证了图片自适应布局。通过这种设计，不仅有效地降低了页面初始加载的压力，也能在加载过程中提供良好的视觉反馈和错误处理。

#### 使用**Intersection Observer** 的好处是什么？

- **作用**：监听目标元素与父容器（或视口）的**交叉状态变化**（如元素进入/离开视口）。
- **优势**：
  - **高性能**：异步回调，**避免频繁触发** `scroll` 事件。
  - **灵活**：可配置触发交叉的**阈值**（threshold），触发的**范围**和监听的根容器。
  - **自动管理**：**无需手动计算元素位置**。

**对比传统方案**

| **场景**         | **传统方案（scroll + getBoundingClientRect）** | **Intersection Observer**  |
| :--------------- | :--------------------------------------------- | :------------------------- |
| **性能影响**     | 频繁触发强制布局，导致性能抖动                 | 无强制布局，异步批量处理   |
| **代码复杂度**   | 需手动管理监听、防抖、计算逻辑                 | 声明式 API，自动管理       |
| **精确度**       | 依赖手动计算，可能误差                         | 浏览器原生计算，精确到像素 |
| **动态内容支持** | 需手动跟踪新增元素                             | 自动观察新注册元素         |

#### Intersection Observer的底层原理是什么？

Intersection Observer 的底层原理主要依赖于浏览器的渲染与布局机制，通过异步检测目标元素与观察容器（通常是视口）之间的交叉情况来工作。当页面发生滚动、窗口尺寸变化或其他布局更新时，浏览器会重新计算各个目标元素与根容器之间的交叉区域，然后将这些计算结果与预先设定的阈值进行比较。当某个目标元素的交叉比例超过（或低于）阈值时，浏览器就会生成对应的 IntersectionObserverEntry 对象，并异步调用注册的回调函数。

这种机制的好处在于，浏览器可以批量处理多元素的可见性变化，从而避免频繁监听滚动事件带来的性能问题，实现高效、低开销的可见性检测。

### 3、react.memo

**React.memo 的好处**
`React.memo` 是 React 提供的高阶组件（HOC），主要用于优化函数组件的渲染性能。它的核心优势是可以**避免不必要的重新渲染**

当父组件更新时，即使子组件的 `props` 未变化，默认情况下子组件也会重新渲染。使用 `React.memo` 后，子组件会**浅层比较新旧 `props`**，仅当 `props` 变化时才会重新渲染。

如果`props`是一个对象，即使内容一样，但由于每次传过来的都是一个新对象，引用不同，子组件也会重新渲染。解决方法就是给memo添加一个shallowEqual，这样如果引用不同，会再对内部属性方法进行比较，如果相同就不用重新渲染

### 4、虚拟列表+懒加载

在上边

### 5、防抖与节流

在上边



## 7、axios二次封装

#### 为什么要对axios进行二次封装？

对 Axios 的二次封装主要是为了**统一管理网络请求逻辑**，通过拦截器**全局处理错误提示**、**Token 鉴权**、**处理参数格式**等，减少重复代码；同时规范数据响应结构（如自动提取嵌套数据），**简化api（如get，post）调用方式**（如统一设置参数，统一返回 `[err, data]` 格式），并支持扩展缓存、重试等定制功能，最终提升代码复用性、维护性及项目协作效率。

#### 项目中进行了哪些封装？

创建一个axios示例，将基础路由和请求超时时间抽离出来，如果以后要修改方便修改。

**1、对get和post这些api进行了封装**

以get为例，封装了一个新的get函数来获取各项房源数据，里边调用axios.get(url, params)方法，参数是请求路径url和和要查询的查询参数params。在then中处理请求结果，通过res.data获取到数据。获取成功就用resolve返回数据。请求失败通过catch接到，用rejected返回一个error。

post情况也类似，调用axios.post方法，传入请求数据与URL，在then中处理数据并返回，在catch中处理错误并返回

**2、对请求拦截器进行了封装**

在第一个项目中，只是封装了一些公共请求头。在第二个项目中，存在登录功能，所以在请求拦截器中通过getItem获取用户的token ，如果有token就设置到请求头的Authorization。请求拦截器是通过`axios.interceptors.request.use`，对config赋值实现。

**3、对响应拦截器进行了封装**

在第一个项目中，没有登录功能，所以仅通过响应拦截器封装了处理网络请求错误显示的错误信息，如400是'错误的请求'，404是'请求错误,未找到该资源'，500是'服务器端出错'，502是网络错误。并通过message(error)弹出错误信息。在第二个项目中封装了对用户token过期或失效进行处理，当返回结果为401时说明token过期或失效，重新刷新token（通过存储的有更长有效期的refreshToken，将其post到服务器端，正常情况下会返回新token）。如果成功获取新token就使用新token重新请求，如果还是失败就弹出错误信息、清除token并跳转至登录页面。

4、对各个接口进行进一步封装，调用上边的get函数，将请求的url传进去，在外部使用相应数据请求时直接调用即可。



## 8、登录与注册的实现

项目2中登录通过token方式实现。

通过状态变量设置显示登录还是注册

**注册的实现**：首先设计了注册的用户名，密码与重复输入密码的表单。点击注册按钮后先进行前端检查，如果密码符合规则且两次输入密码相同，就触发注册请求，将用户名和密码通过post传进去，返回一个响应，如果成功调用就登录函数，失败就弹出注册失败。

**登录的实现**：

1、首先在设计了登录的用户名和密码表单，点击登录按钮会触发登录请求，将用户名和密码传进去，如果登录成功就把用户名放到redux中存起来，并跳转到首页，失败就弹出登录失败。

2、触发登录请求，会通过post方法将用户名和密码传到服务器，如果成功就获取响应中的token和refreshToken放到localStorage中存起来（通过setItem）,并返回一个true。失败就返回一个false

3、在请求拦截器中，会将token放进请求头Authorization中。在响应拦截器中，会对响应结果进行处理，如果token过期或失效就通过refreshToken重新获取一个新token存起来，通过新token重新进行请求。如果还是失败就弹出错误信息，清除token并跳转至登录页面。

4、首页中设置了登出按钮，点击后就可以触发登出函数，清除token并跳转至登录页面。

5、通过设置一个高阶组件来实现路由守卫，在高阶组件中对token的有效性和是否过期进行验证（通过jwtDecode对token进行解析），如果验证通过就跳转到响应的页面，如果不通过就回到登录页面。通过状态变量来保存用户token，并通过context传递。

### 问题1：都有哪些登录方式，都有什么特点和优势？

#### 一、**Session-Cookie 认证**

#### **原理**

- 服务端生成会话（Session）并存储（如内存、数据库、Redis），客户端通过 Cookie 保存 Session ID。
- **流程**：
  1. 用户提交用户名密码。
  2. 服务端验证后生成 Session 并返回 Session ID。
  3. 客户端通过 Cookie 存储 Session ID。
  4. 后续请求自动携带 Cookie，服务端校验 Session ID。

#### **特点**

- **优点**：
  - 简单易实现，适合传统 Web 应用。
  - 服务端可主动控制会话（如强制退出、实时更新权限）。
- **缺点**：
  - 服务端需存储会话数据，扩展性差（分布式场景需共享 Session）。
  - 依赖 Cookie，跨域场景需额外配置。

#### **适用场景**

- 传统服务端渲染的 Web 应用（如 PHP、Ruby on Rails）。

------

#### 二、**OAuth 2.0 / 第三方登录**

#### **原理**

- 用户通过第三方平台（如微信、Google、GitHub）授权登录。
- **流程**：
  1. 前端跳转至第三方登录页面。
  2. 用户授权后，第三方返回授权码（Code）。
  3. 前端将 Code 传给后端，后端换取用户信息。
  4. 后端生成自有 Token 或 Session 返回前端。

#### **特点**

- **优点**：
  - 用户无需注册新账号，提升转化率。
  - 依赖第三方平台的用户体系，减少密码管理成本。
- **缺点**：
  - 实现复杂，需处理多种第三方协议。
  - 依赖第三方服务稳定性。

#### **适用场景**

- 需要快速接入第三方账号登录的应用（如社交平台、工具类应用）

### 问题2：token方式的优势和缺点是什么？

**三、Token 认证的优势**

| 优势               | 说明                                                        |
| :----------------- | :---------------------------------------------------------- |
| **无状态**         | 服务端无需存储会话信息，适合微服务、分布式架构。            |
| **跨域支持**       | 可轻松实现跨域认证（CORS），适合前后端分离项目。            |
| **多端兼容**       | 适用于 Web、移动端（App）、IoT 设备等多种客户端。           |
| **灵活的权限控制** | Token 可携带用户角色、权限信息，实现细粒度访问控制。        |
| **易于扩展**       | 可通过添加自定义字段（如设备 ID、Token 版本）支持复杂场景。 |

------

**四、Token** **认证的缺点与挑战**

| 缺点               | 解决方案                                                     |
| :----------------- | :----------------------------------------------------------- |
| **Token 泄露风险** | 使用 HTTPS、短期 Token、Refresh Token 轮换、绑定 IP/设备信息。 |
| **无法主动失效**   | 使用 Token 黑名单、短期有效期 + 刷新机制、或改用不透明 Token。 |
| **存储安全性**     | 优先使用 `HttpOnly Cookie`，避免 LocalStorage（防 XSS）。    |
| **Token 膨胀**     | 避免在 Token 中存储过多数据，敏感信息由服务端动态查询。      |

### **问题三**：Token 认证 vs Session-Cookie 认证

| 对比项           | Token 认证                     | Session-Cookie 认证         |
| :--------------- | :----------------------------- | :-------------------------- |
| **状态管理**     | 无状态，适合分布式系统         | 有状态，服务端存储 Session  |
| **跨域支持**     | 天然支持（通过 Header 传递）   | 需配置 CORS 和 Cookie 域    |
| **移动端友好性** | 更友好（无需处理 Cookie）      | 需处理 Cookie               |
| **注销机制**     | 依赖黑名单或短期 Token         | 服务端直接删除 Session 即可 |
| **适用场景**     | 前后端分离、API 优先、多端应用 | 传统服务端渲染 Web 应用     |

### **问题4：前端该用 LocalStorage 还是 Cookie 存 Token？**

- **优点：**
  - 存储容量较大，适合存放较多或较大的数据。
  - 操作简单，通过 JavaScript API 直接读写，不需要每次请求都自动携带，便于在客户端灵活控制。
- **缺点：**
  - 数据完全暴露给前端脚本，无法设置 HttpOnly，容易受到 XSS 攻击。
  - 需要手动将 token 附加到 HTTP 请求头中，增加了实现复杂度。
  - 数据不会自动随请求发送，跨域时需额外处理。

**Cookie 存储 Token**

- **优点：**
  - 浏览器会自动在每个请求中附带 Cookie，便于服务器端识别用户会话。
  - 可以设置 HttpOnly 属性，防止 JavaScript 访问，从而降低 XSS 风险。
  - 配置 SameSite 和 Secure 属性后，可在一定程度上防范 CSRF 等攻击。
- **缺点：**
  - 存储容量有限（通常约 4KB），不适合存放大量数据。
  - 自动随请求发送，可能会带来不必要的流量开销。
  - 如果配置不当（例如未设置 SameSite 或 Secure），依然存在安全隐患。

## 9、style-components

**1、简单介绍**

styled-components 是一种流行的 CSS-in-JS 库，主要用于 React 应用中。它通过使用 ES6 的模板字符串（tagged template literals）让开发者可以在 JavaScript 文件中直接编写 CSS，然后将这些样式与具体的 React 组件绑定，从而达到组件化、模块化的样式管理效果。

**主要特点**

- **样式与组件紧密耦合**：样式定义在组件内，使得样式的作用域自动被限定在组件内，避免了全局样式冲突。
- **动态样式支持**：可以根据组件的 props 或 state 动态生成样式，满足复杂场景的需求。
- **主题支持**：提供 ThemeProvider，可以轻松实现全局主题切换，统一管理应用风格。
- **易于维护**：由于样式和逻辑在同一文件中管理，组件的可读性和可维护性较高。

**优点与适用场景**

- **提高复用性与封装性**：每个组件自带样式，方便复用和迁移。
- **简化开发流程**：不用再维护单独的 CSS 文件，减少样式冲突问题。
- **适用于大型 React 应用**：当应用组件化程度高时，styled-components 能够更好地管理复杂的样式体系。

### 1、通过参数实现动态样式

styled-components 利用 ES6 模板字符串的特性，可以在样式中嵌入 JavaScript 表达式。这样，你就可以根据组件的 props 动态计算出对应的 CSS 属性值。

**实现方式：**

- **插值**
   在模板字符串中使用插值，接收组件的 props 作为参数，然后返回一个 CSS 值，要以一个$开头。
   例如，根据一个 `primary` 属性来设置按钮的背景色，通过props.primary 判断那种样式：

  ```js
  import styled from 'styled-components';
  
  const Button = styled.button`
    background-color: ${props => props.primary ? 'blue' : 'gray'};
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
  `;
  ```

  在使用时，只需给组件传递相应的 props，如这里传primary：

  ```js
  <Button primary>主按钮</Button>
  <Button>普通按钮</Button>
  ```

  ### 2、整体将参数插入样式

  通过ThemeProvider将一个主题对象注入到整个组件树中。所有使用 styled-components 定义的组件都可以通过 `props.theme` 访问到这个主题对象，从而实现全局主题的统一管理和动态切换。

  **定义主题对象**
   首先定义一个包含全局样式变量（如颜色、字体、间距等）的主题对象：

  ```js
  // theme.js
  export const theme = {
    primaryColor: 'blue',
    secondaryColor: 'gray',
    fontSize: '16px',
  };
  ```

  **使用 ThemeProvider 包裹组件树**
   在应用的根组件中使用 `ThemeProvider` 将主题对象传递下去：

  ```js
  import React from 'react';
  import { ThemeProvider } from 'styled-components';
  import { theme } from './theme';
  import App from './App';
  
  const Root = () => (
    <ThemeProvider theme={theme}>
      <App />
    </ThemeProvider>
  );
  
  export default Root;
  ```

  **在 styled-components 中使用主题变量**
   组件中可以通过 `props.theme` 直接访问主题变量：

  ```js
  const Title = styled.h1`
    color: ${props => props.theme.primaryColor};
    font-size: ${props => props.theme.fontSize};
  `;
  ```

### 3、混入 Mixin 功能

**实现方式：**
 styled-components 通过内置的 `css` 辅助函数来实现 mixin。你可以把常用的样式封装成一个可重用的样式块，然后在多个组件中引入。这样可以避免样式代码重复，提高可维护性。

## 10、redux-toolkit

### 什么是 Redux？它的主要特点是什么？

**Redux** 是一个用于管理应用状态的 JavaScript 库，通常与 React 一起使用。它提供了一种集中管理应用状态的方式，使得状态管理更加可预测和可维护。

**主要特点**：

- **单一数据源**：整个应用的状态存储在一个单一的 store 中，确保了状态的一致性。
- **状态不可变**：状态是不可变的，每次状态变化时，都会生成一个新的状态对象。
- **reducer**：通过reducer来处理状态变化，使得状态变化可预测。
- **中间件支持**：支持中间件，可以扩展 Redux 的功能，如异步操作、日志记录等。
- **开发者工具**：提供了强大的开发者工具，可以调试、回溯和重放状态变化。

### **一、为什么需要 Redux Toolkit？**

#### **传统 Redux 的痛点**

1. **繁琐的样板代码**：需手动编写 action types、action creators、reducers。
2. **配置复杂**：需自行集成中间件（如 Thunk、Logger）、DevTools。
3. **不可变更新易错**：手动使用 `...` 或 `Object.assign` 更新状态，容易出错。
4. **异步处理麻烦**：需依赖额外库（如 Redux-Saga、Redux-Observable）。

#### **Redux Toolkit 的优势**

- **简化代码**：内置 `createSlice` 自动生成 action 和 reducer。
- **开箱即用**：预置 `@reduxjs/toolkit` 包含 Immer、Thunk、DevTools。
- **类型安全**：完美支持 TypeScript。
- **高效开发**：减少 80% 的 Redux 代码量。

### **二、核心 API 与功能**

#### **1. `configureStore`：创建 Store**

替代 `createStore`，自动集成 Thunk、DevTools 和中间件。

```js
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './reducers';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
  devTools: process.env.NODE_ENV !== 'production'
});
```

#### **2. `createSlice`：定义 Slice**

自动生成 action types 和 action creators，简化 reducer 编写。

```js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: 0,
  reducers: {
    increment: (state) => state + 1,
    decrement: (state) => state - 1,
    addBy: (state, action) => state + action.payload
  }
});

export const { increment, decrement, addBy } = counterSlice.actions;
export default counterSlice.reducer;
```

#### **3. `createAsyncThunk`：处理异步操作**

简化异步逻辑（如 API 请求），自动生成 pending/fulfilled/rejected 状态。

```js
import { createAsyncThunk } from '@reduxjs/toolkit';
import api from './api';

export const fetchUser = createAsyncThunk(
  'user/fetchUser',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await api.get(`/users/${userId}`);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);
```

#### 4、**集成 React**

使用 `Provider` 包裹应用，并通过 `useSelector`/`useDispatch` 访问状态。

```js
// store.ts
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// App.tsx
import { Provider } from 'react-redux';
import { store } from './app/store';

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}

// Counter.tsx
import { useDispatch, useSelector } from 'react-redux';
import { increment } from './counterSlice';
import type { RootState } from '../app/store';

function Counter() {
  const count = useSelector((state: RootState) => state.counter);
  const dispatch = useDispatch();

  return (
    <button onClick={() => dispatch(increment())}>Count: {count}</button>
  );
}
```

#### **5、`useDispatch`：派发 Action**

**作用**

**获取 Redux Store 的 `dispatch` 函数**，用于触发 Action 以更新 Store 中的状态。

**使用场景**

当组件需要触发状态变更时（如用户点击按钮、提交表单、发起异步请求等）。

**代码示例**

```js
import { useDispatch } from 'react-redux';
import { increment } from './counterSlice'; // 导入 Action Creator

function CounterButton() {
  const dispatch = useDispatch();

  return (
    <button onClick={() => dispatch(increment())}>
      Increment Counter
    </button>
  );
}
```

**关键特性**

1. **直接派发 Action**：
   可以派发同步 Action（如 `dispatch(increment())`）或异步 Action（如 `dispatch(fetchData())`）。
2. **无需手动订阅 Store**：
   React-Redux 自动处理与 Store 的连接。

------

#### **6、`useSelector`：获取 Store 状态**

**作用**

**从 Redux Store 中提取需要的状态值**，并订阅该状态的更新。当状态变化时，组件会自动重新渲染。

**使用场景**

当组件需要读取 Store 中的状态时（如显示计数器值、用户信息等）。

**代码示例**

```js
import { useSelector } from 'react-redux';

function CounterDisplay() {
  const count = useSelector((state) => state.counter.value);

  return <div>Current Count: {count}</div>;
}
```

**关键特性**

1. **选择器函数**：
   接受一个函数 `(state) => selectedValue`，返回需要的状态片段。
2. ****严格相等****：
   默认使用严格相等（`===`）比较前后状态值。**如果返回值是对象或数组，需确保引用稳定**，否则会导致不必要的重新渲染。
3. **性能优化**：
   - **使用记忆化选择器**（如 `createSelector`）避免重复计算。
   - **按需提取状态**：避免返回整个 Store 的根状态。

**`shallowEqual` 的作用**

- **默认行为问题**：
  `useSelector` 默认使用 `===` 比较前后两次选择器返回的值。如果返回的是新对象（如 `{ a: 1, b: 2 }`），即使内容相同，引用不同也会触发重新渲染。
- **`shallowEqual` 的优化**：
  比较对象或数组的第一层属性/元素的值，若所有值相同，则判定为“未变化”，跳过重新渲染。

如果对reducer状态值有计算，可以使用**`createSelector`** 

**createSelector作用**

- **缓存输入和输出**：记录上一次的输入参数和计算结果。
- **参数未变化时直接返回缓存结果**：跳过重复计算。
- **参数变化时重新计算**：更新缓存。

## 11、react的模块化与组件化

React 的 **模块化** 通过拆分代码逻辑（如工具函数、API 服务）实现功能复用和高效维护，而 **组件化** 将界面拆分为独立、可复用的 UI 单元（如按钮、表单），通过状态隔离和组合模式提升开发效率。二者结合形成了高内聚低耦合的架构，优势在于**逻辑复用性高**（如自定义 Hook）、**协作便捷**（并行开发）、**维护性强**（修改独立模块不影响整体），同时支持动态加载优化性能，适用于从简单页面到复杂应用的灵活构建，是 React 高效开发的核心设计理念。

## 12、数据路由

##### 一、核心 API 作用

1. **`createBrowserRouter`**
   创建一个基于 HTML5 History API 的路由实例，支持数据加载、路由嵌套等特性。
   - 参数：路由配置数组（定义路径、组件、数据加载逻辑等）。
   - 返回：路由对象（传递给 `RouterProvider`）。
2. **`RouterProvider`**
   将路由实例注入 React 应用，替代传统的 `<BrowserRouter>` 包裹方式。
   - 参数：`router`（由 `createBrowserRouter` 创建的路由对象）。

##### 二、用法

**定义路由表**

```
// src/routes.js
import { createBrowserRouter } from "react-router-dom";
import Home from "./pages/Home";
import Login from "./pages/Login";
import ErrorPage from "./pages/ErrorPage";

// 定义路由配置
const router = createBrowserRouter([
  {
    path: "/",
    element: <Home />,       // 直接渲染组件
    errorElement: <ErrorPage />, // 全局错误边界
  },
  {
    path: "/login",
    element: <Login />,
    // 可添加数据加载或 Action
    loader: () => fetchUserData(), // 预加载数据
  },
  {
    path: "/user/:userId",
    element: <UserProfile />,
    loader: ({ params }) => fetchUser(params.userId), // 动态参数加载
  },
]);

export default router;
```

 **注入路由到应用**

```
// src/main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import { RouterProvider } from "react-router-dom";
import router from "./routes";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
```

##### 三、高级功能实现

1. **数据加载（Data Loading）**

通过 `loader` 函数预加载路由所需数据：

以下是一个典型的数据加载流程：

1. **用户触发导航**（如点击链接 `/user/123`）。
2. React Router **挂起当前 UI**，显示 `Suspense` 的 `fallback`（若有）。
3. **执行目标路由的 `loader` 函数**，获取数据。
4. **数据加载完成后**，渲染目标路由的组件，并将数据通过 `useLoaderData` 传递给组件。
5. 若 `loader` **加载失败**，渲染 `errorElement` 组件。

在项目中未使用，因为希望从redux中通过createAsyncThunk获取各项数据。

```
// 路由配置
{
  path: "/posts",
  element: <PostsPage />,
  loader: async () => {
    const posts = await fetch("/api/posts").then(res => res.json());
    return posts; // 数据会传递给组件
  },
}

// 组件中获取数据
import { useLoaderData } from "react-router-dom";

function PostsPage() {
  const posts = useLoaderData(); // 直接获取 loader 返回的数据
  return (
    <div>
      {posts.map(post => <div key={post.id}>{post.title}</div>)}
    </div>
  );
}
```

2. **错误边界（Error Boundary）**

通过 `errorElement` 定义错误处理组件：

```
{
  path: "/dashboard",
  element: <Dashboard />,
  errorElement: <ErrorPage />, // 捕获子路由错误
  children: [
    { path: "profile", element: <Profile /> },
    { path: "settings", element: <Settings /> },
  ],
}
```

## 13、echarts实现统计

- 使用 `ReactECharts` 组件包裹 ECharts 实例
- 通过其中的`option` 属性配置相应的统计图

1、对于收入支出数据通过柱状图进行统计。Xaxis属性配置月份，Yaxis属性配置值。series属性对数据进行遍历分别配置pir上收入和支出数据，type是bar。

2、对于分类数据通过饼状图进行统计，series属性中的data配置数据，type为pie

## 14、localStorage

### cookie/sessionStorage/localStorage 的区别

> 参考答案：
>
> cookie、sessionStorage、localStorage 都是保存本地数据的方式
>
> 其中，cookie 兼容性较好，所有浏览器均支持。浏览器针对 cookie 会有一些默认行为，比如当响应头中出现`set-cookie`字段时，浏览器会自动保存 cookie 的值；再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得 cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为，给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然 cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式
>
> HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据，后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据、读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。
> cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M，而 sessionStorage 和 localStorage 则没有限制
> cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与 domain 关联

### 前端该用 LocalStorage 还是 Cookie 存 Token？**

- **优点：**
  - 存储容量较大，适合存放较多或较大的数据。
  - 操作简单，通过 JavaScript API 直接读写，不需要每次请求都自动携带，便于在客户端灵活控制。
- **缺点：**
  - 数据完全暴露给前端脚本，无法设置 HttpOnly，容易受到 XSS 攻击。
  - 需要手动将 token 附加到 HTTP 请求头中，增加了实现复杂度。
  - 数据不会自动随请求发送，跨域时需额外处理。

**Cookie 存储 Token**

- **优点：**
  - 浏览器会自动在每个请求中附带 Cookie，便于服务器端识别用户会话。
  - 可以设置 HttpOnly 属性，防止 JavaScript 访问，从而降低 XSS 风险。
  - 配置 SameSite 和 Secure 属性后，可在一定程度上防范 CSRF 等攻击。
- **缺点：**
  - 存储容量有限（通常约 4KB），不适合存放大量数据。
  - 自动随请求发送，可能会带来不必要的流量开销。
  - 如果配置不当（例如未设置 SameSite 或 Secure），依然存在安全隐患。

## 15、移动端适配

通过媒体查询结合rem与flex的方式，实现了移动端适配。

1、flex布局：用来设置较大的元素布局，如控制一行中显示几列房源item。

2、rem布局：用来设置较小的元素布局，如房源item中的文字大小，边距等。首先给根元素html设置字体大小，其余元素的设置为几倍的rem。rem的优势：每个元素父元素文字大小可能不一致， 但是整个页面只有一个html，这样一来可以很好来控制整个页面的元素大小。

3、通过媒体查询，实现在不同页面改变根元素字体大小，从而改变元素大小。通过min-width，max-width来控制断点。

### 问题1：响应式布局如何实现切换栏数

1、通过flex-wrap，确保元素可切换

2、默认是一行显示五列，简写形式是flex: 1, 0, 20%

其中第一个参数为flex-grow，定义子元素在容器有**剩余空间**时如何分配剩余空间。值为1说明在页面中占一份。flex-grow的值代表全部子元素加起来宽度占到几份。由于20%*5=100，已占满，所以不会再起作用。如果是flex: 1，是flex: 1, 1, 0。初始宽度为0.通过flex-grow等于1所以将剩余空间占满。同时flex-shrink为1所以可以收缩。

第二个参数为flex-shrink定义子元素在容器**空间不足**时如何收缩。值为0，元素禁止收缩。

第三个参数为flex-basis定义子元素在分配剩余空间前的初始大小。值为20%，说明初始大小为20%，20%*5=100，正好占满。

3、当页面宽度逐渐减小时，通过max-width设置范围，当减小到程度flex-basis就换位25%变成4列，并以此类推变为三列两列一列。

### 问题2：都有哪些响应式布局方案，优缺点都是什么

| **布局方法**       | **优点**                                                     | **缺点**                                                     |
| :----------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Flexbox**        | 1. 灵活的对齐和空间分配 2. 一维布局简单直观 3. 代码简洁，支持响应式 | 1. 二维复杂布局能力有限 2. 旧版浏览器（如 IE10-）需前缀      |
| **CSS Grid**       | 1. 强大的二维布局能力 2. 简化复杂网格结构 3. 支持现代浏览器无缝响应 | 1. 旧版浏览器兼容性差（如 IE11 部分支持） 2. 学习曲线较陡    |
| **流式布局**       | 1. 基于百分比自适应屏幕 2. 实现简单，无需复杂计算            | 1. 内容可能拉伸失真 2. 嵌套元素百分比计算复杂                |
| **Rem 布局**       | 1. 基于根字体大小适配多屏 2. 结合媒体查询实现精细控制        | 1. 需工具转换像素单位（如 PostCSS） 2. 动态调整根字体可能影响性能 |
| **Viewport 单位**  | 1. 直接基于视口尺寸（vw/vh） 2. 天然响应式，减少媒体查询使用 | 1. 部分浏览器支持不全（如 vmin/vmax） 2. 小屏幕内容可能过小  |
| **Bootstrap 栅格** | 1. 快速搭建响应式布局 2. 预设断点，社区支持完善 3. 跨浏览器一致性 | 1. 冗余代码增加体积 2. 定制性受限 3. 依赖框架更新            |
| **媒体查询**       | 1. 精准控制不同断点样式 2. 高度定制化，适配任意设备          | 1. 维护多断点时代码臃肿 2. 无法覆盖所有设备尺寸              |
| **混合布局**       | 1. 结合多种方法优势（如 Grid + Flex） 2. 灵活应对复杂场景    | 1. 代码复杂度高 2. 需开发者深入理解各方法特性                |

### 问题3：使用rem与flex布局的好处是什么

rem：普通em是根据父元素规定的字体大小确定的，对于不同的元素父元素可能不同，设置的字体大小可能也不同，也就会导致em设置较混乱。而rem只根据根元素html设置，所以各个子元素中的rem都按照同一套标准设置，较为统一，更改时也只需要更改html中的字体大小即可，方便控制。

flex: 空间分配很灵活方便，很多时候只需要配置一个flex: 1即可。构建自适应布局也很简单，如两栏布局，一栏设置固定宽度，另一栏直接设置flex: 1就可以占满剩余部分。

## 16、如何实现点击链接跳转

1、酒店中的每种房源都几个a链接来代表对应的平台

2、以携程为例，所有酒店的详情页面的协议，域名，路由hotel/detail都是相同的，只有查询参数不同。查询参数是hotelId和adult，从后端获取到相应的参数后，通过模板字符串放到href的链接中，就可以实现链接跳转。



## 17、项目AI简介

------

AI助手是一种多agent协作构建的ai

### 1. 架构与模块划分

项目主要分为以下三大模块，每个模块对应若干个 Agent（智能体）：

1. **用户信息处理模块**
   - **作用**：对用户输入（包括需求描述、标准等）进行结构化、标准化处理，提取关键信息，方便后续推理和检索。
   - **模型选型**：采用 ERNIE Functions-8K-0321 —— 该模型在**结构化输出能力**和**输出格式稳定性**方面表现优异，能够保证批量信息抽取时的准确性和一致性。
2. **推理模块**（双 Agent 协作架构）
   - **推理 Agent**
     - **模型选型**：DeepSeek-R1-Distill-Qwen-14B —— 推理能力较强、推理过程可解释性高，能够针对症状信息给出详细的病因分析。
   - **专科 Agent**
     - **模型选型**：DISC-MedLLM —— 专门针对房源推荐对话场景微调过的大模型，擅长根据用户需求给出“贴合实际”的建议。
   - **协作方式**：
     1. 用户信息处理模块提取到的结构化症状数据，先由“推理 Agent”进行初步的需求分析；
     2. 再将推理结果交给“专科 Agent”，结合知识库给出更合理，更符合实际的建议。

------

### 3. 多 Agent 协作链路的搭建

1. **统一使用百度千帆 SDK**（不主动讲）

   - 因为现有市面上的多 Agent 框架（如 Camel、AutoAgent 等）并不原生支持百度千帆 SDK，所以开发团队借鉴了它们的设计规范（尤其是 Camel 的链式调用逻辑）。
   - 最终搭建了包括：
     - **模型初始化调用**：统一通过千帆 SDK API 装载不同的大模型；
     - **记忆存储**：保存对话上下文、用户偏好等辅助信息；
     - **双 Agent 协作链路**：在一个业务流程里，先调用一个 Agent，获取中间结果后传给下一个 Agent；
     - **RAG（Retrieval-Augmented Generation）工具调用**：结合本地知识库和在线搜索插件，实现“问答+检索融合”的效果。

2. **RAG 工具具体实现**

   - **本地知识库**：使用 Camel 库搭建，内容来源于团队爬取的房源数据。

   - **数据处理**：

     ​	对数据进行归纳总结

   - **检索流程**：前端发起问题时，后端先根据用户输入的向量化信息在本地知识库中查找相关答案；如未命中或命中置信度较低，则进一步调用百度搜索插件，获取最新在线信息；最后将“本地检索结果 + 在线检索结果”综合传给对应模型，让模型生成最终回答。



# 计网篇

## HTTP协议

### HTTP协议的优点和缺点

**定义**：HTTP 是超文本传输协议，定义了客户端和服务端之间交换报文的方式和格式，默认端口号为80端口。使用 TCP 作为传输层协议，保证数据交换的可靠性。

**优点**：

- 简单快速
- 无连接
- 无状态：无通信过程的上下文信息，这样后续处理前面的信息需要重传
- 灵活：允许任意类型的数据对象

**缺点**：

- 无状态：HTTP不会保留关于客户的任何信息
- 明文传输：报文是文本形式，会暴露给外界，不安全
- 不安全

### HTTP请求报文

**请求行   请求头   空行   请求体**

- **请求行**：请求方法、URL字段、HTTP协议版本字段，用空格分离
- **请求头：**请求头关键词/值组成
- **请求体：**post put 等请求携带的数据

### HTTP响应报文

**相应行   响应头   空行   响应体**

- **相应行**：网络协议版本、状态码、状态码原因   如 HTTP/1.1 200 OK 
- **响应头**：响应首部字段
- **响应体**：服务器响应的数据

### 常见的HTTP请求方法

- GET：获取数据；
- POST：提交数据；
- PUT：更新数据；
- DELETE：删除数据；
- HEAD：获取报文首部；
- OPTIONS：询问支持的请求方法，检查访问权限，用来跨域请求；
- CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；
- TRACE：回显收到的请求，用于测试或诊断。

### 常见的HTTP请求头和响应头

**请求头：**

- Accept:浏览器能够处理的内容类型
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookie：当前页面设置的任何Cookie
- Host：发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

**响应头：**

- Date：表示消息发送的时间，时间的描述格式由rfc822定义
- server:服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache-Control：控制HTTP缓存
- content-type:表示后面的文档属于什么MIME类型

### GET 和 POST 请求的区别

| 特性               | GET 请求                         | POST 请求                                    |
| ------------------ | -------------------------------- | -------------------------------------------- |
| 数据传输方式       | 在 URL 中传递                    | 在请求体中传递                               |
| 主要用途           | 获取数据                         | 提交数据、改变服务器状态                     |
| URL 长度限制       | 有（受浏览器限制，约 2048 字符） | 无（理论上无大小限制，实际受限于服务器配置） |
| 安全性             | 相对不安全（数据可见）           | 相对安全（数据不可见，但需要结合 HTTPS）     |
| 可缓存性           | 可以被缓存                       | 默认不缓存                                   |
| 是否改变服务器数据 | 否                               | 是                                           |
| 书签和共享         | 可以（因为数据在 URL 中）        | 无法（因为数据在请求体中）                   |

### POST 和 PUT 区别

POST：专注于创建数据

PUT：专注于更新数据

### HTTP1.0 HTTP1.1 HTTP2 三者区别

| 特性             | HTTP/1.0                                                     | HTTP/1.1                                                     | HTTP/2                                                       |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **TCP连接**      | 默认**无连接**（需要手动配置 `Connection: keep-alive` 实现`close` 关闭） | 默认**持久连接**（通过 `Connection: close` 关闭              | 持久**连接** + **多路复用**                                  |
| **数据传输格式** | 文本                                                         | 文本                                                         | 二进制                                                       |
| **并发请求**     | 不支持                                                       | 部分支持（**管线化**：第一个请求未响应前可发送后去请求）     | 支持**多路复用**（同一个TCP并发处理多个请求和响应）          |
| **缓存控制**     | 基本支持（缓存控制主要依赖于响应头中的 `Expires` 字段）      | 先进的缓存控制（通过 `Cache-Control` 响应头来控制缓存策略）  | 先进的缓存控制（通过 `Cache-Control` 响应头来控制缓存策略）  |
| **虚拟主机支持** | 不支持                                                       | 支持（多域名共享同一IP： host 字段）                         | 支持（多域名共享同一IP： host 字段）                         |
| **头部压缩**     | 不支持                                                       | 不支持                                                       | 支持（HPACK算法压缩：如去重）                                |
| **服务器推送**   | 不支持                                                       | 不支持                                                       | 支持（服务器客户端请求前主动推送资源，如请求html，推送相关css，js） |
| **典型用途**     | 静态网站请求                                                 | 动态内容和静态内容混合                                       | 高性能的现代应用                                             |
| **资源请求**     | 返回整个对象                                                 | 支持**断点续传**，且**允许只请求资源中某一部分**（range 头域） |                                                              |

**断点续传：**

在**传输中断后从中断的位置继续传输**，而不必从头开始

**工作原理**：

1. **文件分块**：将文件划分为多个小块，每块都有一个唯一的标识符和位置。
2. **记录传输状态**：在传输过程中，客户端和服务器会**记录已经成功传输的文件部分**，**以及剩余需要传输的部分**。
3. **继续传输**：当传输中断时，客户端可以向服务器**请求从上次中断的地方继续传输**，服务器根据客户端的请求和记录的数据从指定位置开始继续传输数据。

使用场景：大文件上传

### HTTP和HTTPS的区别

**HTTP + SSL/TLS 加密**：HTTPS 是在 HTTP 的基础上加入了 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）加密协议，确保通信数据的机密性、完整性和真实性。

**安全性**：

- **数据加密**：传输的数据被加密，第三方无法窃取通信内容。
- **数据完整性**：保证数据在传输过程中不会被篡改。
- **身份验证**：通过证书确认服务器的身份，防止中间人攻击。

**端口**：

- HTTP 使用 **80 端口**
- HTTPS 使用 **443 端口**

**性能**：HTTPS 需要额外的 SSL/TLS 握手过程，会增加一些开销，但随着硬件的进步和 HTTP/2 的引入，这种开销已经大大降低。

### HTTP3.0

**定义：**基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。

- 流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。
- 集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。
- 多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。
- 快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。

### URL组成部分

例如：**[www.aspxfans.com:8080/news/index.…](https://link.juejin.cn/?target=http%3A%2F%2Fwww.aspxfans.com%3A8080%2Fnews%2Findex.asp%3FboardID%3D5%26ID%3D24618%26page%3D1%23name)**

- 协议部分
- 域名部分
- 端口部分
- 虚拟列表部分
- 文件名部分：最后一个 / 到 ？开始
- 锚部分：# 开始到最后
- 参数部分：参数之间由 & 分隔

### 缓存相关的HTTP请求头

强缓存：

- Expires
- Cache-Control

协商缓存：

- Etag、If-None-Match
- Last-Modified、If-Modified-Since

## HTTPS协议

### 什么是HTTPS协议

**定义**：超文本传输安全协议（HTTPS），是 HTTP 的加密版。通过 SSL/TLS 协议对数据进行加密，确保客户端和服务器之间传输数据时安全的，防止被窃听篡改或冒充。

**优点**：

- 验证服务器身份
- 数据安全
- 增加了中间人攻击的成本

**缺点**：

- 加密和解密消耗服务器资源
- SSL 证书是收费的
- TLS 握手费时，增加页面加载时长
- SSL 证书需要绑定 IP，不能使用同一个 IP 绑定多个域名

### HTTPS工作原理

**访问网站的过程：**

- 浏览器发送 HTTPS 请求
- 服务器返回证书，浏览器验证有效性
- 通过 TLS 握手建立连接
- 建立连接后使用绘画密钥进行加密通信

### HTTPS 如何确保数据传输的安全性

HTTPS 通过**使用 TLS/SSL 协议对数据进行加密**，防止被窃听和篡改

**TLS 使用对称加密和非对称加密相结合**的方式保证数据完整，同时通过**数字证书验证服务的身份**来防止中间人攻击

**流程：**

- **数字证书验：证服务器身份，确保服务器的合法性**
- **TLS 握手：然后使用非对称加密（使用证书中的服务器公钥发送预主密钥，服务器使用私钥解密）生成主密钥，最终生成会话密钥**
- **最后使用对称加密进行数据交换**

### TLS/SSL工作原理

TLS 是 SSL 改进后的版本，有更强大安全性、更好的加密算法支持

**定义：** **安全传输层协议**，是在 TCP 和 HTTP 之间的一层安全协议

**TLS握手过程（协商安全参数、验证身份、建立安全密钥，确保数据传输的安全性）：**

- 客户端：发送支持的**加密算法列表和随机数**
- 服务器：**选择加密算法**，返回**服务器的证书和另外随机数**
- 客户端：**验证证书**真实性，生成**预主密钥**，并**用服务器的公钥加密**给服务器
- 服务器：使用私钥**解密预主密钥**，**生成主密钥**
- 客户端和服务器**根据主密钥生成会话密钥**，用于后续数据加密

**依赖三类基本算法：散列函数 hash、对称加密、非对称加密**

- 基于散列函数**验证信息完整新**
- 对称加密采用**协商的密钥进行数据加密**
- 非对称加密**实现身份认证和密钥协商**

**对称加密和非对称加密：**

- **对称加密：**使用相同密钥加密和解密，速度快，但分发不安全；**用于加密真实传输数据**
- **非对称加密：**使用公钥和私钥加密和解密，速度慢，但安全；**用于安全交换密钥**
- 公钥和私钥：公钥是公开的，私钥是保密的。公钥和私钥加密的数据只能使用对应的私钥和公钥解密。

### 什么是数字证书

数字证书是 CA 签发的电子邮件，用于验证服务器的身份

CA 是受信任的第三方机构，确保客户端连接到的服务器是合法的

## HTTP 状态码

| **类别** | **原因**                        | **描述**                   |
| -------- | ------------------------------- | -------------------------- |
| 1xx      | Informational(信息性状态码)     | 接受的请求正在处理         |
| 2xx      | Success(成功状态码)             | 请求正常处理完毕           |
| 3xx      | Redirection(重定向状态码)       | 需要进行附加操作一完成请求 |
| 4xx      | Client Error (客户端错误状态码) | 服务器无法处理请求         |
| 5xx      | Server Error(服务器错误状态码)  | 服务器处理请求出错         |

### 2xx   成功

- **200  OK**      请求正常处理完毕
- **204 No Content**      正常处理，**没有返回内容**（响应体无主体）
- **206 Partial Content**      **客户端进行了范围请求**（响应报文中有 Content-Range 指定范围的实体内容）

### 3xx   重定向

- **301 Moved Permanently**      **永久重定向**

  请求的资源已经分配了新的 URL，在响应头的 Location 首部字段中指出

  搜索引擎会在新网址上抓取内容

  使用场景：更新域名

- **302 Found**      **临时重定向**

  （本次）能使用新的 URL 访问资源

  使用场景：做活动，未登录的用户中心重定向到登录页面，404页面重新定到首页

- **303 See Other**      

  和 302 有相似的功能，但 303 明确表示客户端要采用 GET 的方式获取资源

**注意：当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做**

- **304 Not Modified**      **浏览器缓存相关**

  告诉客户端有缓存，直接使用缓存中的数据

- **307 Temporary Redirect**   **临时重定向**

  和 302 相同含义，但307遵循浏览器标准，不会从 POST 变成 GET

### 4xx   客户端错误状态码

- **400 Bad Request**      

  **请求报文语法错误**，浏览器会像200 OK 一样对待这个状态码

- **401 Unauthorized**

  发送的**请求要有 HTTP 认证的认证信息**，当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。

  - 401.1 - 登录失败。
  - 401.2 - 服务器配置导致登录失败。
  - 401.3 - 由于 ACL 对资源的限制而未获得授权。
  - 401.4 - 筛选器授权失败。
  - 401.5 - ISAPI/CGI 应用程序授权失败。
  - 401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。

- **403 Forbidden**

  **请求被服务器拒绝了**

  - 403.1 - 执行访问被禁止。
  - 403.2 - 读访问被禁止。
  - 403.3 - 写访问被禁止。
  - 403.4 - 要求 SSL。
  - 403.5 - 要求 SSL 128。
  - 403.6 - IP 地址被拒绝。
  - 403.7 - 要求客户端证书。
  - 403.8 - 站点访问被拒绝。
  - 403.9 - 用户数过多。
  - 403.10 - 配置无效。
  - 403.11 - 密码更改。
  - 403.12 - 拒绝访问映射表。
  - 403.13 - 客户端证书被吊销。
  - 403.14 - 拒绝目录列表。
  - 403.15 - 超出客户端访问许可。
  - 403.16 - 客户端证书不受信任或无效。
  - 403.17 - 客户端证书已过期或尚未生效
  - 403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。
  - 403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。
  - 403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。

- **404 Not Found**   **服务器无法找到请求的资源**

  - 404.0 -（无） – 没有找到文件或目录。
  - 404.1 - 无法在所请求的端口上访问 Web 站点。
  - 404.2 - Web 服务扩展锁定策略阻止本请求。
  - 404.3 - MIME 映射策略阻止本请求。

- **405 Method Not Allowed**   **服务器禁止使用此方法**

  客户端可以通过 OPTIONS 方法查看允许的访问方法

  `Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE`

### 5xx   服务器错误状态码

- **500 Internal Server Error**   **服务器端发生错误**，可能是 bug 或某些临时故障
- **502 Bad Gateway**   **网关或代理服务器出错与上有服务器通信出错**
  - 502.1 - CGI （通用网关接口）应用程序超时。
  - 502.2 - CGI （通用网关接口）应用程序出错。
- **503 Service Unavailable**   **服务器处于超负荷或停机维护状态**
- **504 Gateway Timeout**   **网关和代理服务器等待上有服务器超时**

## DNS

### 什么是DNS

DNS 是域名系统，可以将域转换为计算机可以理解的 IP 地址

### DNS工作步骤

- **DNS 递归查询：**客户端向本地 DNS 解析器发送查询请求
- **本地 DNS 解析器查询根服务器：**如果本地缓存没有，向根服务器请求
- **根服务器回应：**根服务器返回顶级域名（.com、.net）服务器地址
- **查询顶级域名服务器：**本地 DNS 解析器向 TLD 服务器请求域名信息
- **TLD 服务器回应：**提供域名的权威 DNS 服务器地址
- **查询权威 DNS 服务器：**本地 DNS 服务器向权威 DNS 服务器请求最终 IP地址
- **权威 DNS 服务器回应：**返回 IP 地址，**本地 DNS 服务器将结果缓存，并发给客户端**

### 什么是递归查询和迭代查询

- **递归查询：**本地 DNS 解析器代替客户端完成整个查询过程（从根服务器到权威服务器）   **向本地 DNS 服务器请求的方式**
- **迭代查询：**在每一步中，DNS 解析器只会提供下一步应该查询的服务器地址，解析器根据这些提示进行查询   **本地 DNS 服务器向域名服务器请求的过程**

## 网络模型

### 七层网络（OSI）

**通信特点：对等通信（源和目的端对等层通信）**

**（1）应用层**   为应用提供服务

最靠近用户的一层，**为用户提供应用接口和网络服务**

HTTP   HTTPS   FTP   SMTP

**（2）表示层**    数据格式转换、数据加密

**用于应用层数据的编码和转换**，确保应用层之间发送的数据可被互相识别

**（3）会话层**   建立、管理、维护会话

负责建立、管理、终止表示层通信，保证长时间文件传输不被打断

**（4）传输层**   建立、管理、维护端到端的连接

**负责端到端的传输，保证数据的完整性和可靠性**，建立、管理、终止传输连接，检查错误

TCP传输控制协议   UDP用户数据报协议   SCTP（流控制传输协议）

**（5）网络层**   数据包路由选择和转发

**提供 IP 地址，处理数据包的路由和转发**，以及流量控制

Router路由   IP互联网协议  ICMP互联网控制报文协议

**（6）数据链路层**   提供介质访问和链路管理

**将网络层的 IP 数据封装成帧**，一对一和一对多的数据传输

Switch交换机   Wi-Fi无线局域网

**（7）物理层**   

负责网络设备之间的物理连接和传输介质，如电缆类型、连接器、信号类型

网线   光纤

### TCP/IP五层协议

**应用层：**为应用进程提供服务

**传输层：**两台主机中提供通信服务，源端口和目标端口

**网络层：**选择合适的路由在两台主机间传递，源IP和目标IP

**数据链路层：**将网络层的 IP 数据封装成帧，并在链路的两个相邻节点间传送

**物理层：**保证数据的传输物理媒介

## TCP和UDP

TCP 和 UDP 都是传输层协议

### TCP

**定义：**TCP 是传输控制协议。是一种面向连接的、可靠的、基于字节流的传输层通信协议。

**特点：**

- **面向连接**

  **发送数据之前必须在两端建立连接**，连接方法为三次握手

- **仅支持单向传播**

  每条 TCP 传输连接只能有两个端点，**只能进行点对点的数据传输**

- **面向字节流**

  不保留报文边界的情况下，**以字节流方式进行传输**

- **可靠传输**

  TCP 的**段编号和确认号可以判断丢包和误码**

- **提供拥塞控制**

  当网络出现拥挤，TCP **能够减小向网络注入数据的速率和数量**，缓解阻塞

- **全双工通信**

  客户端和服务器什么时候都能通信，不需要客户端发送新的请求

**应用场景：**

**效率要求相对低，但准确性要求高的场景**

例如：文件传输、接收邮件

**三次握手和四次挥手：**

- 三次握手
  - 客户端发送 SYN（同步标志）和一个初始序列号（x）
  - 服务器发送 SYN 、确认标志（ACK=x+1）、服务器初始序列号（y），表示同意建立连接
  - 客户端发送ACK（y+1），双方建立连接
- 四次挥手
  - 客户端发送终止标志（FIN）
  - 服务器发送确认标志（ACK）并进入等待关闭状态
  - 服务器发送（FIN），并进入确认关闭状态
  - 客户端发送 ACK，确认关闭

**为什么需要三次握手和四次挥手：**

- 三次握手：确保双方都有能力发送和接收数据，通过三次握手协商初始序列号，并同步双方发送和接受能力，**确保连接的可靠性**
- 四次挥手：因为 TCP 是全双工的。双方确认都没有数据发送才能安全断开连接

**TCP的重传机制：**

TCP 在发送一个数据之后，没有在规定时间内收到发送数据的 ACK 确定报文，就会重新传送（**一定时间内没有完成则放弃并重新发送**）

**TCP的阻塞控制机制（四种机制）：**

- **慢启动：**在开始的时候不发送大量数据，**先测试网络阻塞程度**，由小到大增加**阻塞窗口**的大小
- **拥塞避免：** **将拥塞窗口控制为按线性增长**，是网络不容易阻塞
- **快速重传：**接收到收到一个失序报文段就会发送一个重复确认，**当连续发送三个重复确认就立即重传**，不用等到计时器到期
- **快速恢复：**连续收到三个重复确认时，**把慢启动门限减半**

### UDP

**定义：**用户数据报协议，是一种面向连接、简单的传输层协议。**直接将数据报发送给接收方，不保证数据的到达、顺序或完整性，不进行流量控制和错误检测**

**特点：**

- **无连接**

  在传输数据前**不需要建立连接**

- **不可靠**

  **不保证数据的可靠性**，数据可能丢失、重复、无序到达

- **低开销**

  **不进行错误修复、重传、流量控制等操作**，开销小，数据传输快

- **面向数据报文**

  使用**数据报文进行传输**

- **有单播，多播，广播功能**

  支持一对一，一对多，多对一，多对多的方式。

**使用场景：**

- 在线游戏
- 实时应用（短视频软件，网络电视，网络通话）

## WebSocket

**基本概念：**一个可以在单个 TCP 连接上进行**持久、双向连接**的**实时**通信通道

**特点：**全双工通信（建立连接后双方可以互发消息），低开销，实时性，有状态（长连接），跨平台（独立于平台和语言的协议），安全（加密协议）

**工作步骤：**

- **握手阶段：**客户端发送请求到服务器，表明希望建立 WebSocket 连接。请求头包含特定字段，如 `Upgrade: websocket` 和 `Connection: Upgrade`。
- **服务器响应：**如果服务器支持，返回 101 确认**升级协议（握手成功后）**，HTTP 协议升级为 WebSocket 协议
- **数据传输阶段：**自由发送和接受数据，不需要额外的 HTTP 请求
- **关闭阶段：**由任意一方关闭

**使用场景：**

- 实时聊天应用
- 实时数据推送（股票，体育赛事）
- 协同编辑（多用户同时编辑文档）

**WebSocket和http的区别**

| **特性**         | **HTTP**                              | **WebSocket**                  |
| ---------------- | ------------------------------------- | ------------------------------ |
| **通信**         | 单向通信                              | 双向实时通信                   |
| **连接方式**     | 无状态、短连接                        | 持久连接                       |
| **数据传输效率** | 低效（每次请求/响应需传输完整头信息） | 高效（轻量级数据帧，低延迟）   |
| **使用场景**     | 页面加载、API 请求、文件下载等        | 在线聊天、实时数据更新、游戏等 |

## 输入一个url，浏览器会做哪些事情

- **URL 解析：**提取协议、主机、端口、路径
- **DNS 解析：**查找域名的 IP 地址
- **建立 TCP 连接：**三次握手
- **发送 HTTP 请求：**通过 TCP 连接将请求发送给目标浏览器
- **服务器处理请求**
- **接收 HTTP 响应**
- **渲染页面：**解析 HTML   解析 CSS   执行 js     构建渲染树   布局和绘制

# 浏览器篇

## 进程与线程

**定义：**

- 进程：**正在运行的程序（微信、QQ）**，资源分配的最小单元
- 线程：任务调度和执行的基本单位

**区别：**

- **通信：**线程共享同一进程资源，进程通信需要辅助进程间通信
- **开销：**进程创建和回收开销大，因为会分配独立内存和资源。线程开销小，因为共享进程的资源
- **崩溃：**一个线程崩溃会导致所在进程崩溃，但是不会影响到其他进程
- **回收内存：**一个进程关闭之后，系统会回收进程的内存

**进程之间通信方式：**

- **管道：**
  - 匿名管道：单向通信机制，适合父子进程通信。一端写入，一端读取
  - 命名管道：双向通信机制，无关系进程通信。
- **消息队列：**
  - 可以支持一个进程以消息的形式给另一个进程发送数据
  - 发送的数据具有优先级，可以按照优先级对消息进行读取
  - 支持复杂的数据格式和结构，支持多种操作（读写、清空等）
- **共享内存：**
  - 允许进程直接访问相同的内存区域
  - 适合大量数据快速传输
- **内存映射文件：**
  - 将文件映射到内存，实现多个进程对文件的并行访问
  - 适合共享大数据文件

**僵尸内存：**

子进程结束后，父进程有没有释放子进程占用的资源，等待父进程读取

**孤儿进程：**

父进程终止，但子进程还在继续运行，会被 init 进程接管并正常运行

### 如何实现多标签页通信（跨页面通信）

- `localStorage` + `storage`事件   **数据量小**

  所有标签页共享同一个 localstorage 空间，另一个标签页通过 storage 事件监听

- `BroadcastChannel`   **实时通信且浏览器支持**

  同源多个浏览器上下文通信（标签页，iframe，web worker）

  **实现步骤：**

  1. 每个标签页创建一个`BroadcastChannel`对象并订阅相同的频道名称。
  2. 标签页之间通过`postMessage`发送消息，其他订阅该频道的标签页可以接收到消息。

- WebSockets   **跨域或双向实时通信**

  WebSocket是一种持久的双向通信协议，允许客户端和服务器之间实时交换数据，服务器中作为中介传递数据

  **实现步骤：**

  1. 在服务器上配置WebSocket或SSE。
  2. 各标签页连接到同一个WebSocket服务器，实现通信。

### 浏览器的多进程

- **Browser 进程**：浏览器的**主进程**，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。
- **GPU 进程**：用于 **3D 绘制**等，最多一个。
- **第三方插件进程**：每种类型的插件对应一个进程
- **浏览器渲染进程**（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。
- **网络进程：**加载网络资源

### 渲染进程（浏览器内核）

- **GUI 渲染线程**：渲染浏览器界面，回流重绘会执行
- **JavaScript 引擎线程**：处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码
- **事件触发线程**：控制事件循环，把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。
- **定时触发器线程**：setInterval 与 setTimeout 所在线程
- **异步 http 请求线程**：XMLHttpRequest 连接后新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

**GUI 渲染线程与 JavaScript 引擎线程是互斥的**，GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞，此时需要requestAnimationframe

### requestAnimationframe

把动画相关的 js 分成小的任务块，每一帧只执行一个任务快，GUI 线程通常每秒60帧进行一次更新页面，此方法会在每一帧开始之前调用回调函数，保证 js 动画更新，避免页面阻塞。

### 单线程的 JavaScript

所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。

## 协程（Coroutine）

协程是一种用户态的轻量级线程，由程序员显式控制其执行流程。协程可以在执行过程中暂停和恢复，适合用于异步编程和非阻塞I/O操作。

**关键点**：

1. **用户态控制**：协程的调度由程序员控制，而不是操作系统。协程可以在执行过程中暂停和恢复，而不需要进行上下文切换。
2. **轻量级**：协程的创建和销毁开销非常小，适合用于高并发的场景。
3. **非阻塞I/O**：协程适合用于异步编程和非阻塞I/O操作，可以避免线程切换的开销。
4. **协作式调度**：协程通过协作式调度（Cooperative Scheduling）进行任务切换，而不是抢占式调度（Preemptive Scheduling）。

**示例**：

- 在异步编程框架（如Python的asyncio）中，协程用于处理异步I/O操作。
- 在高并发的网络服务器中，协程可以用于处理大量的客户端连接，提高系统的吞吐量。

## 浏览器缓存机制（本地缓存）

- 浏览器缓存是提升网页性能的核心机制，通过减少重复请求和网络传输，显著加快页面加载速度。缓存机制分为两个层级：**强缓存**和**协商缓存**，二者协同工作形成高效的缓存策略。

### 浏览器缓存机制及使用过程详解

#### 一、首次请求资源（无缓存）

1. **用户访问网页**：浏览器解析 HTML 时发现需要加载资源（如 CSS、JS、图片）
2. **发送完整请求**：浏览器向服务器发送标准 HTTP 请求
3. **服务器响应**：
   - 返回资源内容（状态码 200）
   - 在响应头中设置缓存策略：
     - `Cache-Control: max-age=3600`（资源有效期 1 小时）
     - `ETag: "abc123"`（资源指纹标识）
     - `Last-Modified: Wed, 21 Jun 2023 10:30:00 GMT`（最后修改时间）
4. **浏览器存储**：
   - 保存资源到内存缓存（Memory Cache）或磁盘缓存（Disk Cache）
   - 记录缓存策略和验证信息

#### 二、后续请求 - 强缓存阶段

1. **再次访问相同资源**：
   - 浏览器检查缓存策略
   - 计算`Cache-Control`有效期：当前时间 < (首次请求时间 + max-age)
2. **强缓存生效**：
   - 若资源在有效期内，浏览器直接使用本地缓存
   - **不发送任何网络请求**
   - 开发者工具显示：`200 OK (from disk cache)` 或 `200 OK (from memory cache)`
3. **缓存位置优先级**：
   - 小文件优先使用内存缓存（Memory Cache）
   - 大文件使用磁盘缓存（Disk Cache）

#### 三、强缓存失效 - 协商缓存阶段

1. **强缓存过期后**：
   - 浏览器准备网络请求
   - 添加缓存验证信息到请求头：
     - 若有 ETag：添加 `If-None-Match: "abc123"`
     - 若有 Last-Modified：添加 `If-Modified-Since: Wed, 21 Jun 2023 10:30:00 GMT`
2. **发送条件请求**：
   - 请求头包含验证信息
   - 服务器收到后检查资源状态
3. **服务器响应**：
   - **资源未修改**：返回 `304 Not Modified`（空响应体），浏览器使用本地缓存
   - **资源已修改**：返回 `200 OK` + 新资源内容，浏览器更新缓存
4. **网络消耗对比**：
   - 完整资源请求：传输整个文件（如 100KB）
   - 304 响应：仅传输响应头（约 0.5KB）

#### 四、缓存更新机制

1. **收到 304 响应**：
   - 浏览器更新缓存有效期
   - 继续使用现有缓存资源
2. **收到 200 响应**：
   - 替换旧缓存内容
   - 存储新的缓存策略
3. **资源更新策略**：
   - 文件名哈希：`style.abc123.css` → `style.def456.css`
   - HTML 引用更新，强制获取新资源

#### 五、用户行为影响

1. **地址栏输入 URL/页面跳转**：
   - 正常触发强缓存和协商缓存
2. **普通刷新（F5）**：
   - 跳过强缓存，直接进入协商缓存
3. **强制刷新（Ctrl+F5）**：
   - 忽略所有缓存，直接请求最新资源
   - 请求头添加 `Cache-Control: no-cache`

## 浏览器本地存储

### Cookie

- **定义：**大小只有 4kb，是一种纯文本文件，每次发起 HTTP 请求都会携带
- **特性：**
  - 一旦创建，名称无法修改
  - 无法跨域名，不同域名下 cookie 无法共享
  - 每个域名 cookie 不能超过 20 个，每个大小不能超过 4kb
  - 有安全问题，如果被拦截，可获取 session 的所有信息
- **使用场景：**统计页面点击次数；和session 结合使用，将 sessionID 储存到 cookie ，这样服务器就知道谁发起的请求
- **字段：**Name   Value   Size   Path   Domain可以访问cookie的域名   Expires

### SessionStorage

- **作用：**临时保存同一窗口的数据，刷新窗口不会删除
- **同源策略：**只有在同一浏览器的同一窗口下才能共享
- **使用场景：**游客登陆信息，临时浏览器记录信息，关闭网页后信息消除
- **API：**
  - `sessionStorage.setItem('key', 'value'); `  保存
  - `let data = sessionStorage.getItem('key');`   获取
  - `sessionStorage.removeItem('key');`   删除
  - `sessionStorage.clear();`   清空
  - `sessionStorage.key(index)`   获取索引

### LocalStorage

- **优点：**
  - 大小为 5MB，可以储存更多信息
  - 持久储存，不会随着页面关闭小时，除非主动清理
- **缺点：**
  - 浏览器隐私模式，无法读取 LocalStorage
  - 同源策略限制
- 使用场景：换肤功能的网站，用户浏览信息，不常变动的个人信息
- **API：**
  - `localStorage.setItem('key', 'value'); `  保存
  - `let data = localStorage.getItem('key');`   获取
  - `localStorage.removeItem('key');`   删除
  - `localStorage.clear();`   清空
  - `localStorage.key(index)`   获取索引

### IndexedDB

**特点：**

- **键值对储存：**数据以键值对形式储存
- **异步：**存储数据异步执行，防止大量数据读写拖慢网页表现
- **同源限制**
- **储存空间大：**不少于 250MB ，甚至没有上限
- **支持二进制储存：**可以存储字符串和二进制数据

### **三者区别**

| 特性         | `cookie`                    | `localStorage` | `sessionStorage`       |
| ------------ | --------------------------- | -------------- | ---------------------- |
| **大小**     | 约 4KB                      | 5-10MB         | 5-10MB                 |
| **存储时间** | 指定过期时间或会话结束      | 永久存储       | 关闭标签页或窗口后清除 |
| **访问范围** | 客户端和服务器              | 客户端         | 客户端                 |
| **安全性**   | 支持 `Secure` 和 `HttpOnly` | 与同源策略一致 | 与同源策略一致         |
| **适用场景** | 持久化少量数据              | 长期存储数据   | 临时存储数据           |

## 浏览器组成

浏览器分为两部分：shell 和 内核

- 外壳：菜单，工具栏。主要提供用户界面操作，设置参数等。调用内核来实现
- 内核：浏览器核心。显示内容的程序或模块

### 浏览器主要组成部分

- **用户界面**   地址栏，前进后退按钮，主窗口以外部分
- **浏览器引擎**   用户界面和渲染引擎传达指令
- **渲染引擎**   显示请求的内容。请求、解析、显示文件
- **网络层**   网络调用
- **UI 后端**   用于绘制基础组件（输入框、按钮、下拉菜单）和网页各种元素   
- **JS 解释器**   解析和执行 JS 代码
- **数据储存**   在硬盘上持久化储存数据，如 Cookie
- **安全模块**   防止攻击，HTTPS 加密、沙盒隔离、同源策略、隐私模式
- **插件和扩展模块**  允许用户安装额外功能和工具（广告拦截、密码管理）
- **GPU进程**   复杂图片处理使用 GPU 加速（Canvas）

### 对内核的理解

浏览器内核分为两部分：

- **渲染引擎：**在窗口显示请求的内容（html xml 图片）
- **JS引擎：**解析和执行 js 来实现页面动态效果。

js 引擎越来越独立，内核倾向于指渲染引擎

### 常见内核对比

- **Trident：** **IE 浏览器内核**。早期占有大量市场份额，但是 IE 内核和 W3C 标准脱节，以及大量 Bug 和安全问题没有解决，很多用户转向其他浏览器
- **Gecko：** **火狐内核**。功能强大，支持复杂页面效果。但是消耗资源多
- **Webkit：** **Safari 内核**。网页浏览速度快。但对网页代码的兼容性低，一些编写不标准的网页无法显示。
- **Blink：**谷歌开源内核，**Chrome，edge，Opera浏览器**核心内核。Webkit 分支而来。高性能，支持现代化标准，跨平台兼容（Windows，Linux，安卓，Mac）

## 浏览器渲染原理

### 浏览器渲染过程

- 解析请求的文档，创建 DOM 树
- 解析 CSS，生成 CSSOM 树
- 加载和执行 JS
- 根据 DOM 树和 CSSOM 树构建 render 树
- 根据渲染树进行布局（回流）
- 绘制：遍历渲染树将内容显示在屏幕上

为了快速呈现，浏览器解析一部分就显示一部分

### 回流重绘复合

- **回流：**浏览器重新计算元素位置和大小
  - 操作 DOM / 修改几何属性 / 改变窗口大小 / 读取某些属性（滚动距离）
- **重绘：**重新绘制元素外观
  - 修改 CSS
- **复合：**浏览器将不同图层合成在一起，生成最终屏幕图像的过程。浏览器会将页面分为多个图层，并使用 GPU 进行加速渲染，将图层合成为一个最终的页面显示
  - transform / opacity

### 浏览器渲染优化

- **针对 JS：**

  - JS 放在 body 最后
  - async 异步加载立即执行  defer 异步加载，DOM树解析好顺序执行

- **针对 CSS：**导入外部样式最好使用 link，CSS 少最好使用 style（GUI直接渲染）

- **针对DOM树，CSSOM树：**

  - 使用语义化标签
  - 减少 HTML，CSS层级

- **减少回流重绘：**

  - 尽量在最底层操作 DOM

  - 减少盒子不必要的大小改动

  - 将元素设置为 display：none，这种元素上DOM操作不会引发回流重回，操作结束再显示出来

  - 使用 transform 和 opacity，避免回流重绘，只会发生复合

  - **渲染队列**

    **浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**

## 浏览器安全

### XSS 攻击

**概念：**指**跨站脚本攻击**，攻击者**在网站注入恶意脚本**，在用户浏览器运行，窃取用户信息，调用网站接口执行攻击者操作

**攻击操作：**

- 获取页面的数据，如DOM、cookie、localStorage；
- DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
- 破坏页面结构；
- 流量劫持（将链接指向某网站）；

**攻击类型：**

- **储存型：**恶意脚本储存在服务器上，请求资源时传回（论坛发布，商品评论）
- **反射型：**诱导服务器返回恶意代码的 URL，服务器接收带有 XSS 的数据当作脚本运行（网页搜索，跳转）
- **DOM 型：**通过修改页面的 DOM 节点形成 XSS（ JS 自身的安全漏洞）

**如何防御：**

- **输入验证和过滤：**确保只接受复合预期格式和类型的输入，过滤潜在的危险字符（> < " ’ &）
- **输入编码和转义：**对所有不恶心的数据进行编码 （`<` 转换为 `<`，将 `>` 转换为 `>`），防止解释为 HTML 或者 JS
- **使用安全的库或框架：**React，Vue
- **内容安全策略（CSP）：**能够限制网页允许执行的内容来源，可以防止注入的脚本运行，限制脚本的来源，发送 `Content-Security-Policy` HTTP 头来配置 CSP，如`Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-scripts.com;`

### CSRF攻击

**概念：**指**跨站请求伪造攻击**，诱导进入第三方网站，该网站象被攻击网站发送跨域请求。**本质是利用用户在已登录状态下对目标网站的信任，诱导用户在不知情的情况下执行非预期的操作。。**

**攻击类型：**

- **GET 请求：**网站中的一个 img 标签构建一个请求，用户打开网站后自动发起请求
- **POST 请求：**构建一个表单然后隐藏，进入页面后自动提交表单
- **链接类型：**在 a 标签的 herf 属性构建一个请求，有道用户点击

**如何防御：**

- **对 Cookie 进行双重验证：**用户请求页面时，服务器生成 CSRF Token，并且通过 Cookie 和 AJAX 发送 Token 给客户端，客户端通过 Cookie 和请求参数同时发给服务器，服务器验证 Token 是否与 Cookie 的 Token 匹配。 
- **Cookie 设置 Samesite，限制不能被第三方使用**

### 网络劫持

- **DNS 劫持：**通过修改运营商的本地 DNS 记录，来引导用户跳转到其他服务器；（输入京东被强制跳转到淘宝）
- **HTTP 劫持：**由于 http明文传输，运营商会修改 http 响应的内容，如加广告（浏览器上一直有贪玩蓝月的广告）

## 浏览器同源策略

### 什么是同源策略

**定义：**所谓同源就是**协议、端口号、域名**必须一致，限制不同源之间资源交互的策略，一个重要的安全机制。

**限制：**

- 不同域不可访问 sessionStorage、localStorage 和 indexDB
- 不能操作不同域下 DOM
- 不同域之间无法发送 AJAX 跨域请求

**跨域请求类型：简单请求 和 复杂请求（预检请求）**

- **简单请求**

  满足以下条件

  - 请求方法方法是 `GET`、`POST` 或 `HEAD`。
  - 请求**头部仅包含浏览器自动设置的字段**（如 `Accept`、`Accept-Language`、`Content-Language`、`Content-Type` 等）。
  - 如果使用了 `Content-Type` 头部，则其值仅限于 `text/plain`、`multipart/form-data` 或 `application/x-www-form-urlencoded`。

- **预检请求**

  如果不符合简单请求，则在**实际请求前自动发送一个 OPTIONS 请求，询问服务器是否允许实际请求**，服务器响应后再绝地给是否发送实际请求

### 如何解决跨域问题

- **CORS**

  **定义：**资源跨域共享（CORS），服务器在响应头中设置特定 HTTP 头，告知浏览器允许的跨域请求

  - **Access-Control-Allow-Origin**：源
  - **Access-Control-Allow-Methods**：方法
  - **Access-Control-Allow-Headers**：头
  - **Access-Control-Allow-Credentials**：凭据（如 cookies）。

- **JSONP**

  **定义：**只适用于 GET 请求，通过创建 script 标签发送请求。

  **原理：**利用 sctipt 标签没有跨域限制，在 script 标签 src 属性发送 GET 请求，服务器通过回调函数把数据传给浏览器

  **具体实现：**

  ```
  function handleResponse(data) {
    console.log(data);
  }
  // 动态插入 script 标签
  const script = document.createElement('script');
  script.src = 'http://example.com/api?callback=handleResponse';
  document.body.appendChild(script);
  ```

- **WebSocket**

  WebSocket 是一种双向通信协议，建立在单个 TCP 连接上的持久连接，不受同源策略的限制。可以用于需要跨域的实时数据传输。

  - WebSocket 通过HTTP协议握手 ，但数据传输使用 WebSocket
  - 握手成功后通信直接通过 TCP 连接进行，不受 HTTP 同源策略约束

- **代理服务器**

  使用代理服务器将跨域请求转发到目标服务器

## 浏览器事件机制

### 什么是事件

用户触发的交互动作（文档加载，窗口滚动），这些事件包含了事件发生的相关信息和操作（ event 属性 / event 方法）

**事件模型：**

- **DOM事件模型：**按照一定顺序在页面传播。捕获、目标、冒泡三个阶段。
  - **事件委托：**利用冒泡机制，在父元素绑定程序来处理子元素事件
- **IE事件模型：**
  - 注册事件：`element.attachEvent('onclick', handler)`
  - 没有捕获，只有冒泡

### 事件循环

**定义**：事件循环是**管理异步操作的机制**，可以让 JS 在单线程中执行异步代码而不阻塞主线程

**核心部分**：

- **执行栈：**每当一个函数被调用，就会被推入执行栈，执行结束弹出
- **任务队列：**储存待处理的异步任务（定时器回调、网络请求）
- **事件循环：**不断检查执行栈和任务队列。执行栈为空，则把任务队列中任务取出放进执行栈

**工作流程：在主线程空闲时，将任务队列的任务取出执行，循环操作**

- **执行执行栈同步代码：**函数调用，函数声明，算术操作
- **处理微任务：**比宏任务优先级更高的任务，在当前宏任务执行结束后立即执行，在下一个宏任务执行之前清空微任务队列       `Promise` 的回调、`MutationObserver` 等
- **处理宏任务：**需要在主线程上排队等待的任务      整个 JS 代码，定时器，交互事件，IO操作
- **更新 UI**
- **进行下一轮**

### **事件流**

- **捕获阶段**：**事件由父元素传递到子元素**的过程叫做事件捕获（true）。
- **目标阶段**：在目标节点上触发，称为“目标阶段”
- **冒泡阶段**：**事件由子元素传递到父元素**的过程叫做冒泡（false）。

### 事件委托（事件代理）

**定义**：把子元素的响应事件委托给父元素，让父元素担当事件监听的职务。

**原理**：**事件冒泡**。

**e.target 和 e.currentTarget**

- target 是**触发事件的元素** （ <li>）

- currentTarget 是**绑定事件的元素**  （<ul>）

**使用场景**：在ul上使用事件委托绑定所有li

```
<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  ......
  <li>item n</li>
</ul>
```

**优点**：

- 可以大量节省内存占用，减少事件注册。

**注意事项**：如果同一个dom绑定了两个点事件，一个是捕获，一个是冒泡，那么点击之后会触发两次事件，**先捕获，后冒泡**

**不会冒泡的事件有哪些**

- **`focus`**：获得焦点
- **`blur`**：失去焦点
- **`focusin`**：与 `focus` 类似，但会在元素或其父元素上触发（冒泡），因此这个事件是特例。
- **`focusout`**：与 `blur` 类似，但会在元素或其父元素上触发（冒泡），因此这个事件是特例。
- **`load`**：当图像、音频、视频或其他资源加载完成时触发。例如，在 `img` 元素上触发的 `load` 事件不会冒泡。
- **`unload`**：当页面即将被导航离开时触发。这通常用于执行清理工作，也不会冒泡。
- **`stop`**：通常与 `media` 元素相关，例如 `audio` 或 `video` 元素。这是在媒体播放停止时触发的事件。
- **`readystatechange`**：当 `document` 的 `readyState` 改变时触发。这通常在页面加载时使用。
- **`scroll`**：当元素滚动时触发。这个事件在某些浏览器中可能会冒泡，但在其他浏览器中通常不会冒泡。

### 阻止默认事件和阻止冒泡

- **event.stopPropagation()方法**

不让事件向 document 上蔓延，但是默认事件仍然会执行

- **event.preventDefault()方法**

阻止默认事件，链接则不会被打开，但是会发生冒泡到上一层元素；

- **return false**

同时阻止事件冒泡也会阻止默认事件，等于同时调用了 event.stopPropagation() 和 event.preventDefault()
