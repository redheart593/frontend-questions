# 面试准备

## 1、自我介绍

​	面试官您好，我是王本硕，来自西安邮电大学。我在大一加入了学校的一个软件实验室，了解各个方向后，结合兴趣选择了前端方向进行学习。我先学习了html，css和js，然后选择了React框架并学习了相关知识。学完React后，我与实验室同学合作，作为前端开发负责人，一起协作开发了宅宿甄选项目，项目参加过挑战者杯、互联网加等比赛，获得了不错的名次。本学期我在智学同行科技有限公司进行了一段为期三个月的实习，在其中我主要负责开发了健康助手和AI 辩论两个AI工具助手的页面以及若干功能模块。这段实习使我进一步磨练了自己的技术，熟悉了企业中实际开发项目的大致流程。我热爱前端开发，喜欢结合文档钻研问题，了解前端发展新动向。以上就是我的自我介绍，谢谢面试官。

## 2、实习介绍

#### 	项目背景

​	在这段实习里我参与的项目是一个整合多种 实用工具与助手的 Web 平台，项目最初以教育学习相关业务为主，比如搜题工具，单词助手等等。而随着生成式ai的发展，它在各种垂直细分领域的应用场景也在越来越多。我们的项目积极顺应时代潮流，在许多业务中也接入了AI，例如ai解题，ai翻译等，并围绕生成式AI发展了各种聊天助手、AI工具等新业务，为用户的生活学习工作全方位提供便利。这一部分便是我所参与到的，在其中我主要负责开发了两个AI工具助手的页面。分别是「健康助手」页面，通过对话式交互为用户解决医疗健康相关问题；以及「AI 辩论」页面，用户可以设置正方和反方的观点，交给ai进行辩论。需要我跟您详细介绍一下这两个页面的内容吗吗？

#### 	如果详细介绍

​	好的，首先是健康助手，在这个页面中，用户可以向AI咨询医疗健康相关问题，AI是通过**多agent**模式协作构建的，保证了专业性和严谨性。健康助手通过**对话式交互**，以**流式输出**结合**Markdown格式渲染**的形式快速为用户提供丰富的症状分析、就医指导及保健方案等。健康助手支持**多模态消息**传递，为用户提供了**图片上传**功能，以便于AI根据图片更仔细全面地判断病情，提出建议，上传的图片用户也可以点开进行浏览。健康助手记录着用户的所有**历史会话**，用户可以随时查看过往会话并依照原来话题和AI继续展开对话，也可以删除历史会话或修改会话标题。用户还可选择是否开启**联网搜索**与**本地知识库**，这两个功能都可以有效提升医疗助手的专业性和准确性。

​	接着是AI辩论，在这个页面中，用户可以**设置正方和反方的观点**，交给ai进行辩论，AI会根据不同的辩论角色和立场，模拟真实的辩论场景，提升用户的思辨能力和互动体验。辩论过程分为**立论、质询、驳论、自由辩论和总结**五个环节，正反方ai根据**本方观点与当前环节进行辩论**。AI辩论页面中同样具有**历史辩论列表**查看过往会话的功能。此外，AI输出内容中包含了“**思考过程**”部分，AI会先输出思考过程，思考过程结束后再输出正式回答部分。用户可展开查看思考过程，以便于理解AI的推理逻辑。以上就是我负责开发的两个AI工具助手的大致内容。



**对话式交互**：用户可以向健康助手随时咨询各类医疗健康相关问题，健康助手（AI医生）通过对话式交互的方式，依托AI先进的自然语言处理技术，能够理解用户的提问并给出专业、个性化的解答。在交互过程中，系统采用了**流式输出**机制，AI医生的回复会以“边生成边输出”的打字机模式实时展现，极大提升了用户的沉浸感和等待体验。所有回复内容均支持**Markdown格式**渲染，不仅可以清晰地展示文本，还能美观地呈现列表、表格等丰富内容，便于用户阅读和理解。用户与健康助手的每一次对话，都是通过**WebSocket**实现的实时双向通信，保证了消息的即时性和互动的流畅性。此外还设置了**心跳检测机制**，定时向服务器发送心跳包，确保WebSocket连接的稳定与可靠，避免因网络波动导致的对话中断。



**多模态消息**：健康助手不仅支持文本交流，还实现了多模态消息传递，为用户提供了便捷的图片上传功能。用户在咨询过程中，可以通过直接上传与病情相关的图片（比如体检报告、患处照片等），健康助手在收到图片后，会结合图片内容和用户的文字描述，进行更为精准的分析和建议。图片上传功能基于**AntDesign**的**Upload组件**实现，支持多张图片的批量选择与上传。上传的图片会自动展示在对话输入区上方，用户可以随时预览、删除或重新选择。此外在图片浏览方面，我之前在宅宿甄选项目中封装过一个**图片浏览器组件**用来展示房源图片，在开发本项目时我发现这两个需求大致相同，就在项目中复用了这个组件。用户只需点击任意一张已上传的图片，即可进入全屏浏览模式，支持图片的丝滑切换浏览。图片浏览器底部是**indicator图片指示器**，按顺序展示当前图片与前后六张图片的略缩图，方便用户对上传的所有图片进行详细查看。



**联网搜索和本地知识库**：**联网搜索**是指在用户提问时，AI大模型可以实时访问互联网，检索最新的医学信息、权威文献或相关健康资讯，辅助生成更准确、时效性更强的答案。**本地知识库**是指AI大模型在回答用户问题时，可以调用内置的医学知识库、常见问答、疾病库等本地数据资源。适用于常见疾病、标准诊疗流程、健康科普等内容，保证答案的权威性和一致性。这两个功能在前端的实现方法大致相同，

- 在输入框下方的工具栏区域，有”联网搜索“和“本地知识库”按钮，用户可以手动开启或关闭。

- 其状态由变量控制，点击按钮会切换其值（true/false）。

- 发送消息时，会将 useLocalRag: isUseLocalRag.value 作为参数一同发送给后端，告知AI是否需要联网搜索或参考本地知识库。



**历史会话列表**：是用来展示用户以往的所有对话（会话）记录，方便用户随时回顾、切换、管理历史对话

- 主要实现在左侧侧边栏（.sideMenu）中，有一个“历史对话”区域。
- 会话列表通过 chatList 变量存储，页面加载时会从后端接口获取历史会话数据并渲染出来。

- 每个会话项会显示标题（chat.title），如果没有标题则显示“新对话”。

- 每个会话项右侧有下拉菜单，支持重命名、导出、删除等操作。
- 用户点击左侧历史会话列表中的某一项，可以切换到该会话，查看和继续之前的对话内容。
- 历史会话列表和历史会话的数据都是使用的是二次封装的**axios**进行前后端数据交流的。



**AI辩论**：辩论过程分为**立论、质询、驳论、自由辩论和总结**五个环节。简单来讲，在立论环节双方陈述本方观点和支持的论据，质询环节双方会针对对方的立论漏洞进行攻击，驳论环节回应对方的质疑，自由辩论环节针对核心争议点展开攻防，最后的结论环节进行总结陈词。核心是用状态变量和轮次计数来管理辩论流程，每次发言后自动判断是否切换发言方或推进到下一个阶段，保证辩论流程的有序进行。用户和AI的发言通过输入框和WebSocket/HTTP接口实时交互，整个过程自动流转，界面与流程状态实时联动，带来流畅的辩论体验。



**思考过程**：AIDebate模块的“输出思考过程”功能，是通过前后端协作实现的：后端在每轮辩论中，先通过WebSocket推送AI的推理链（思考过程），再推送正式观点内容，前端将每条消息的思考过程（thinkContent）与观点内容（content）结构化存储，并通过自定义消息组件分开展示，通过折叠面板形式展现推理链，既保证了AI推理的透明可见，也不影响主内容的阅读体验，实现了多轮辩论中AI思考过程的完整输出和友好展示。



​	在这段实习里我参与的项目是一个整合多种 AI 工具与助手的 Web 平台，致力于借助ai解决各种用户需求，为用户的生活学习工作提供便利。在项目中我主要负责开发了「健康助手」和「AI 辩论」两个页面，以及首页的导航气泡。我分别来介绍一下。首先是健康助手，在这个页面中，用户可以咨询医疗健康相关问题，健康助手通过**对话式交互**，以**流式输出**外加**markdown格式渲染**的方式，快速为用户提供丰富的症状分析、就医指导及保健方案等。用户与健康助手的对话是通过**WebSocket**实现的实时双向通信，并通过**心跳检测**保证连接稳定性。而历史记录等数据使用的是二次封装的**axios**进行前后端数据交流，并通过**本地存储localstorage**保存了用户token和对话id。健康助手支持**多模态消息**传递，为用户提供了图片上传功能，借助了**AntDesign**的**update组件**。用户可以将图片上传到对话中，以便于健康助手根据图片进一步判断病情。图片浏览复用了我在宅宿甄选项目中封装的**图片浏览器组件**，用户可以点开对所有上传图片进行浏览。用户还可选择是否开启**联网搜索**与**本地知识库**，结合互联网和本地知识库，可以有效提升医疗助手的专业性和准确性。另一个页面是ai辩论，在这个页面中用户可以设置正方和反方的观点，交给ai进行辩论。辩论过程分为立论、质询、驳论、自由辩论和总结五个环节，正反方ai根据本方观点与当前环节进行辩论。AI回复内容中包含了“**思考过程**”部分，用户可展开查看，以便于理解AI的推理逻辑。此外我还负责开发了首页的导航气泡，鼠标悬浮导航气泡，会在上方弹出两个圆形按钮，点击后分别前往设置和个人中心。点击导航气泡，会弹出一个对话框，框内是用**iframe**嵌入的通过**dify**搭建的智能体。这个智能体可以对用户的问题进行基本的回答，如果有和问题匹配的相应ai工具或助手，会输出相应链接文字让用户跳转到该页面，进一步解决用户需求。

## 3、项目介绍

​	（1）宅宿甄选·酒店民宿甄选平台

​	宅宿甄选平台致力于解决旅游或商务出行人士的住宿选择问题。项目集成了多家住宿平台优质酒店民宿资源，在项目首页中用户可以选择目的城市，然后通过热门、低价、高分等模块向用户展示该城市的优质房源。用户在首页点击更多房源链接，就可以跳转到全部房源页面。这个页面通过**虚拟滚动列表+懒加载**方式向用户推荐目的城市的海量房源，借助**多条件精准查询**为用户提供条件筛选功能，依靠**模糊查询**结合**防抖函数**给用户提供搜索功能，并尝试使用了**React19新API useActionState**优化表单提交过程。还拥有对价格和评分的排序功能。在全部房源页面点击任意一个房源，就可以进入该房源的详情页面。页面中集成了该房源在多家住宿平台的详细信息，如图片、价格、评分、热门评论等。在具体页面中，项目封装了**PictureBrowser**组件，为用户提供了沉浸浏览房源图片的功能。用户如果有心仪的酒店，就可以点击链接跳转到合适的平台进行购买。项目中使用了**路由懒加载**、**图片懒加载**、**React.memo**等方式进行性能优化，大幅提升首屏加载速度。项目使用**axios**进行前后端数据交互，并对axios进行了**二次封装**。未来项目希望结合**媒体查询与rem和Flex布局**实现**响应式布局**。

​	（2）记一笔·简易记账平台

​	记一笔记账平台是我结合React课程实现的一个简易记账平台。用户登陆平台后，可在首页选择日期（通过**AntDesign** 中的 **DatePicker 组件**）查看自己的过往账单，也可在记账页面根据消费类别记录新的收入或支出，还通过**Echarts**实现了一个统计页面，收入支出数据与账单分类数据进行展示。项目还提供了账单收藏功能，通过localStorage进行保存。项目使用了**React-Router6** 的**数据路由**进行路由配置，实现了路由集中式配置与管理。

# 实习

## 1、websocket通信

### （1）简单介绍

​	WebSocket 主要用于健康助手和ai辩论页面的前后端实时通信，实现“打字机”式的AI回复体验。WebSocket 是一种全双工（full-duplex）通信的协议，与传统 HTTP 通信的「客户端发起请求、服务器返回响应、连接断开」的模式不同，WebSocket 在建立连接后可保持通道长连接，客户端和服务器能够彼此主动发送消息，直到其中一方主动关闭。相比传统的HTTP轮询，WebSocket能实现双向通信，解决了 HTTP 长轮询（Long Polling）、轮询（Polling）等方案存在的时延高、资源浪费（需要不断创建/销毁连接）等问题，极大提升了对话流畅度和交互体验，适合实时性要求较高的应用（如即时聊天、在线协作、实时推送等）。在本项目中websocket的连接建立、消息接收与发送、连接中断、心跳机检测和错误重连等机制都有所实现。



### （2）websocket连接建立的大致过程（理论）

​	客户端会先通过一次普通的 HTTP 请求告知服务器“我想把这条连接升级到 WebSocket”，并附带一个用于安全校验的随机值；服务器收到后进行验证并以特殊回应表示同意升级，此时原本的 TCP 连接就从 HTTP 切换到 WebSocket，随后双方即可在同一条持久化连接上进行双向实时通信。 



### （3）项目中websocket的全过程



#### 1、建立连接

​	当进行一个新对话或切换到历史对话时，就会建立一个新的websocket连接，过程是：

- 关闭已有连接并清空心跳机制，防止资源泄漏和重复连接。如果是新消息没有会话id就生成一个

- new websocket初始化一个新的websocket连接（通过ref保存 ref.current来注册事件监听），其中地址是参数化拼接的，包括基础URL，用户id、会话id、角色id、模型id等参数，保证每个连接的唯一性和安全性。

- 注册open message close error事件监听器，为后续消息收发和异常处理做准备

- 当打开新对话或切换到历史对话都会触发**open事件**，如果是新对话，通过send向后端发送一条“初始化对话”的消息，后端会在数据库中为该用户新建一条会话记录（ChatItem），并一个**对话已创建**的消息。并建立新的心跳机制

  (初始化消息如果问起详情)包括

  - type: "chat"：表示这是一次聊天消息（但content为空，属于初始化）。

  - content: ""：内容为空，说明不是用户主动输入，而是系统初始化。

  - 其它如 chatId、roleId、modelId等，都是会话的元信息。

  - imageUrls: []：没有图片。

  - useNetwork、useLocalRag：是否联网、是否用本地知识库。



#### 2、如果问起上边这些id如何获取

基础URL通过getURL函数获取，window.location.hostname得到网站的url

用户id通过getSession函数获取，会从localStorage找有没有session，如果没有就通过定义好的**randString**方法生成一个（问起的话，生成方法就是从0-9和a-z中随机通过for循环结合Math.random随机取值获得一个session）

会话id是如果是历史会话则已经存在，直接拼接；如果是新对话则不存在，通过uuid库的方法重新生成一个

角色id和模型id都是确定好的，因为在这两个页面中的角色和模型都是固定的。



#### 3、websocket接收消息

**消息的接收通过监听message事件进行处理**，返回的**event**点**data**里存在消息type用来区分消息类型，根据type判断不同的返回的消息类型并进行不同的处理。（心跳检测、用户输入、AI回复分阶段等）。分阶段推送消息分片，实现ai回复的流式输出。

- 如果类型是心跳检测就直接跳过消息处理，

- 如果类型是用户输入代表后端将用户输入发送回来进行回显，前端存储消息数组是**chatData**，给chatData追加一个新消息对象，包括id 类型prompt 和用户输入内容content，随后渲染到页面上。不过回显后来不再使用了，改为用户点击发送后直接从前端将新的消息对象追加到chatData数组中。这是因为回显操作虽能保证前后端数据一致，但当前后端通信出现问题时，前端用户收不到后端返回的回显，连自己输入的内容都无法出现再页面上。改为从前端直接追加，当出现网络问题时至少能显示出用户的输入，体验好一些。

- 如果类型是对话已创建，就通过get获取由新对话的历史会话列表，链接由用户id和角色id决定。这里未进行更改，因为历史会话列表希望追求前后端一致性，所以等接收到后端返回的对话已创建的消息后再对chatData进行更新并渲染。

  剩下的是ai回复的输出部分，与ai输出有关的有**start**、**chat**、**end**三种类型。前端存储消息数组**chatData**，当类型为**start**时，代表AI 开始输出，往chatData中push一个**新的消息对象**准备**接收输出内容**，对象包括新消息的**id**（后端传过来的）、**内容**（空字符串）和消息**类型**（reply），并禁用发送按钮和重新生成按钮，启用停止生成按钮。当类型为**chat**时，代表AI正在**输出内容的分片**，将这个内容分片**追加**到当前消息对象（通过id确定）的内容里并重新渲染到页面上。当类型为end时，代表这个消息的结束，启用发送按钮和重新生成按钮，禁用停止生成按钮。



#### 4、websocket发送消息

​	发送消息会触发sendMessage函数，先判断ai是否正在回答或发送内容是否为空（prompt.value.trim.length）。如果没问题，一是将用户输入的内容作为新的消息对象push到chatData中，包括id（前端randString生成的），类型prompt，用户输入内容content，以及已上传图片的URL。二是通过send事件将消息对象发送给后端，里边包含（用户输入的内容，消息类型，会话id模型id和角色id，上传图片的URL，是否使用联网搜索和数据库等）。



#### 5、关闭连接

​	当退出登录，关闭页面，切换对话等操作都会关闭连接，通过触发close事件实现。并将心跳检测清空。



#### 6、错误重连

​	当连接发生错误时会触发error事件，前端会尝试进行重连。具体的过程是，先再外部确定好最大重连次数5次，重连间隔时间3秒；并定义连接次数。每次创建websocket连接时，在open事件触发时都会重置连接次数。如果发生错误时，达到重连间隔时间就会重新调用连接函数，并将重连次数+1。到最后如果重连次数超过最大重连连接次数就不再继续尝试，触发close事件关闭websocket连接，并给用户弹出错误信息。

```js
let socket = null;
let reconnectTimer = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_INTERVAL = 3000; // 3秒

function connect() {
  // ...参数拼接略
  socket = new WebSocket(wsUrl);

  socket.addEventListener("open", () => {
    console.log("WebSocket连接已打开");
    reconnectAttempts = 0; // 重置重连次数
    // 启动心跳、注册消息监听等
  });

  socket.addEventListener("message", onMessage);

  socket.addEventListener("close", () => {
    // 这里一般不自动重连，除非你想支持“意外断开”场景
    // 可以根据业务需求判断是否需要重连
  });

  socket.addEventListener("error", (error) => {
    console.error("WebSocket连接错误:", error);
    // 避免多次重连
    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
      reconnectAttempts++;
      reconnectTimer = setTimeout(() => {
        console.log(`WebSocket重连第${reconnectAttempts}次...`);
        connect();
      }, RECONNECT_INTERVAL);
    } else {
      console.error("WebSocket重连失败，已达最大次数");
      // 可以提示用户“网络异常，请刷新页面”
    }
  });
}
```



#### 7、心跳检测

​	在项目中，每30秒通过send发送一条{ type: "heartbeat", content: "ping" }的消息到后端，并记录一个“等待回应”的状态。后端接收到后，也会返回一个心跳检测的消息{ type: "heartbeat", content: "pong" }代表心跳检测，前端清除“等待回应”状态。如果下次发送心跳包时，上一次的回应还没收到，即仍然处于等待回应状态，就认为连接异常，可以主动关闭WebSocket并触发重连。

​	在连接成功时启动心跳检测，定时发送心跳消息。在连接断开或发生错误时停止心跳检测。

```js
let socket = null;
let heartbeatInterval = null;   // 心跳定时器
let waitingHeartbeat = false;   // 是否在等待心跳回应
const HEARTBEAT_INTERVAL = 30000; // 30秒发送一次心跳

function connect() {
  socket = new WebSocket("ws://yourserver/ws");

  socket.addEventListener("open", () => {
    console.log("WebSocket已连接");
    startHeartbeat();
  });

  socket.addEventListener("message", (event) => {
    const data = JSON.parse(event.data);
    if (data.type === "heartbeat") {
      // 收到心跳回应
      waitingHeartbeat = false;
      // 你可以在这里做一些连接状态的UI提示
    } else {
      // 处理其他类型消息
    }
  });

  socket.addEventListener("close", () => {
    stopHeartbeat();
  });

  socket.addEventListener("error", (error) => {
    stopHeartbeat();
  });
}

function startHeartbeat() {
  stopHeartbeat(); // 防止重复定时
  heartbeatInterval = setInterval(() => {
    if (waitingHeartbeat) {
      // 上一次心跳还没回应，说明连接异常
      socket.close(); // 触发close事件，自动重连
      return;
    }
    // 发送心跳包
    waitingHeartbeat = true;
    socket.send(JSON.stringify({ type: "heartbeat", content: "ping" }));
  }, HEARTBEAT_INTERVAL);
}

function stopHeartbeat() {
  clearInterval(heartbeatInterval);
  waitingHeartbeat = false;
}

// 启动连接
connect();
```

**为何选择前端发ping后端发pong？**

​	1、**客户端主导监测**：只要后端不返回 `pong`，前端就能立即做出重连判断，能够恢复连接。主导权掌握在自己手里。

​	2、项目规范，在之前的项目中有使用到心跳检测都是前端发ping后端发pong

**如何通过后端发ping而前端发pong**

**流程示例**

1. **后端** 每隔固定时间（比如 30 秒）主动向所有已连接的 WebSocket 客户端广播一条心跳消息：

   ```json
   { "type": "heartbeat", "content": "ping" }
   ```

2. **前端** 一旦收到这条 `{ type: "heartbeat", content: "ping" }`，马上返回：

   ```json
   { "type: "heartbeat", "content": "pong" }
   ```

3. **后端** 在发送 `ping` 后，给自己打个“已发送心跳，还在等待 pong”标记；如果在下次期望收到 pong 的时限（比如 5 秒内）没收到前端回来的 `pong`，就默认客户端掉线／断网，直接把 WebSocket 关掉或标记为“失效”，并决定要不要在后端层面进行重连或通知上游逻辑。



### （4）自定义的消息格式是怎样的?

发送消息格式

```json
socket.current.send(
    JSON.stringify({
      type: "chat",	// 消息类型
      content: content,	// 消息内容
      chatId: curChatInfo.value.chatId,	// 会话id
      roleId: roleId.value,	// 使用的角色id
      modelId: modelId.value,	// 使用的模型id
      imageUrls: imageUrls, // 图片URL数组
      useNetwork: isUseNetwork.value,	// 是否使用联网搜索
      useLocalRag: isUseLocalRag.value,	// 是否使用本地知识库
    })
  );
```

返回消息格式

```
type	// 消息类型
text	// 消息内容
chatId	// 消息id
roleId	// 使用的角色id
modelId	// 使用的模型id
```

### （5）轮询、长轮询和websocket的对比

#### 1. 基本原理

**1.1 轮询（Polling）**

- **原理**：客户端以固定的时间间隔（如每隔 1 秒或 5 秒）向服务器发送一次 HTTP 请求，询问服务器是否有新数据。如果服务器有新数据，则在响应中返回；否则返回空或状态标示客户端继续下一次轮询。
- **连接方式**：一个独立的短链接（HTTP 请求-响应）完成一次查询后即断开，下次查询时重新建立连接。

**1.2 长轮询（Long Polling）**

- **原理**：客户端向服务器发起一次 HTTP 请求，如果服务器端暂时没有新数据则保持此请求（不立即返回），直到有新数据可用时才返回响应；客户端收到数据后立即发起下一次长轮询请求，如此循环。相当于“服务端先等数据准备好再回复，客户端收到后马上重连”。
- **连接方式**：与轮询类似，依旧是一次请求对应一次响应，但服务器可以“延迟”响应以减少空回应。每次响应后，客户端重新开启新的连接。

**1.3 WebSocket**

- **原理**：基于 HTTP/1.1 的一次“握手”升级（Upgrade）请求，将连接从 HTTP 协议切换到 WebSocket 协议；握手完成后，客户端与服务器之间建立起一个**持久双向**的 TCP 连接，双方可随时互发消息，无需再次建立 HTTP 请求。
- **连接方式**：一次握手后创建长连接，后续在同一连接上双向通信。

#### 2. 优缺点对比

**3.1 连接建立与开销**

- **轮询**：每次轮询都是一个完整的 HTTP 请求/响应周期（包括 TCP 建立三次握手、TLS 握手（若使用 HTTPS）、请求报头 + 响应报头等）。如果轮询间隔设置得很短（如 1 秒），会产生非常大的网络开销和服务器压力。
- **长轮询**：客户端发出一次请求后，如果服务器暂时没有可用数据，便“挂起”此请求并保持连接一段时间（通常服务端会设置超时时间，如 30 秒）。当出现新数据时立即响应，否则在超时后返回“没有数据”，然后客户端再发起新请求。这样能大大减少“空回应”的次数，但在数据空闲期仍会维持一定数量的长连接。
- **WebSocket**：通过一次 HTTP 握手，将连接升级为 WebSocket。之后无需多次握手，客户端与服务器之间在同一 TCP 连接中互发数据。省去了每次都建立连接和关闭连接的开销，只需传输很少的 WebSocket 报头，即可实现低开销的双向通信。

**3.2 实时性与延迟**

- **轮询**：实时性最差。假设轮询间隔为 5 秒，服务器在第 1 秒左右产生一条新消息，客户端要等到第 5 秒才能下一次请求拿到数据。平均延迟约为 `轮询间隔 / 2`。
- **长轮询**：实时性较好。服务器一有新消息就立即返回响应，客户端马上收到并处理，响应时间仅受网络往返的影响。缺点是客户端收到一次响应后，要重新发起新的 HTTP 请求才能继续“保持等待”状态，这中间会有极短暂的延迟（毫秒级）。
- **WebSocket**：实时性最好。客户端与服务器在同一连接里，任一方随时都能“推送”消息，网络往返延迟几乎与纯 TCP 消息传输相同，没有额外的重连耗时。

**3.3 服务器资源和并发**

- **轮询**：短连接模式，每次请求都创建、处理、关闭连接。若并发用户数高、轮询间隔短，将导致服务器频繁创建/销毁连接，造成 CPU 与内存压力，网络带宽浪费也很严重。
- **长轮询**：每个活跃客户端至少会有一个“挂起”的 HTTP 连接，即使在长时间没有新消息期间也占用一个 TCP 连接。相比轮询，减少了空回应次数，但当用户量极大时也可能出现大量长连接，需要服务器以“异步非阻塞”或“事件驱动”的方式进行优化，防止线程/进程数爆炸。
- **WebSocket**：与长轮询类似，保持着持久 TCP 连接。不同的是，不仅能接收数据，也能主动向客户端推送。服务器需要维护这些持久连接的状态（如每个连接对应的会话、心跳检测等），如果使用不当（如线程模型不合理），并发量大时同样会出现瓶颈。但由于协议层面更加轻量（没有 HTTP 报头的开销），整体吞吐通常更高，更适合持续双向通信。

### （6）webSocket和sse对比

#### 1. 通信方向

- **WebSocket**：双向（full‑duplex），客户端和服务端可以随时相互推送消息，无需重新建立连接。
- **SSE（Server‑Sent Events）**：单向，只能从服务端向客户端推送数据，客户端若要发送消息，必须另起 HTTP 请求（如 POST）。

#### 2. 延迟与效率

- **WebSocket**：一次握手后保持 TCP 连接，消息帧头开销小，适合高频、低延迟交互。
- **SSE**：基于 HTTP 长连接，消息以文本流方式输送，每条消息带有一定格式开销，且在 HTTP/2 下可能受“队头阻塞”影响。 

#### 3. 实现复杂度

- **SSE**：客户端原生支持 `EventSource`，自动重连简单易用；服务端实现也较轻量。
- **WebSocket**：需处理握手、心跳、断线重连等逻辑，实现复杂度略高。

#### 4、为什么在项目中前端和后端之间使用webSocket，而后端和大模型端使用sse，这样的好处是什么

1. **端到端低延迟的流式体验**
   - 后端直接对接大模型的 `text/event-stream`，一有新 token 就马上拿到并透传，不用等完整响应。
   - WebSocket 长连接在前端随时可推，实现“用户输入 → 模型输出”几乎无缝的流水线感。
2. **职责分离，协议各司其职**
   - **SSE**（`text/event-stream`）天然适合后端与模型 API 这种“服务端→服务端”单向、高并发的流式推送，简单可靠。
   - **WebSocket** 则更擅长“服务端←→客户端”双向交互，不仅可以推送模型消息，也可实时接收前端的控制指令（比如取消、修改参数、心跳等）。
3. **更灵活的错误处理与重连策略**
   - 后端与模型 API 之间发生错误时，可以在这一层做重试等错误处理，和前端的 WebSocket 断线重连逻辑互不干扰。
   - 前端也只需关心 WebSocket 的生命周期和重连策略，屏蔽了模型 API 端的细节。
4. **安全与认证边界清晰**
   - 后端统一管理对大模型 API 的访问密钥、限额、审计日志等，避免将敏感凭证泄露到前端。
   - 前端只需与后端建立 WebSocke，简化客户端安全设计。
5. **可观测性与监控**
   - 在后端切面可以对 SSE 流量（如每秒 token 数、平均延迟）做精细监控。
   - WebSocket 连接数、带宽、RTT 也可独立监控，从而快速定位是模型 API 侧瓶颈还是客户端网络问题。
6. **演进路径灵活**
   - 日后若要支持其它流式源（自研模型、不同云厂商），只需要在后端适配新的 SSE 接口，前端无感知。

### （7）如果两个用户之间通过websocket进行聊天，中间有服务器，大致描述一下这个过程应该如何实现

​	用户A（浏览器） ⇄ WebSocket ⇄ 服务器 ⇄ WebSocket ⇄ 用户B（浏览器）

​	实现步骤（概述）

#### 1️⃣ 客户端连接 WebSocket 服务器

用户A 和 用户B 都通过 WebSocket 建立连接，new一个WebSocket，链接是服务器：

```
const socket = new WebSocket('ws://your-server.com');
```

当连接建立后，可以open事件监听连接状态：

```
socket.onopen = () => {
  console.log('Connected to server');
};
```

#### 2️⃣ 客户端发送消息

用户A 发出消息给用户B，通过send发送：

```
socket.send(JSON.stringify({
  type: 'chat',
  to: 'userB-id',
  from: 'userA-id',
  content: '你好！'
}));
```

#### 3️⃣ 服务器接收并转发消息

服务器通监听message事件，接收到用户A的消息后，查找用户B对应的 WebSocket 连接，然后将通过send消息转发过去。

伪代码如下（Node.js 示例）：

```
const clients = new Map(); // userId -> WebSocket

wsServer.on('connection', (socket) => {
  socket.on('message', (raw) => {
    const msg = JSON.parse(raw);
    const toUserSocket = clients.get(msg.to);
    if (toUserSocket) {
      toUserSocket.send(JSON.stringify({
        from: msg.from,
        content: msg.content
      }));
    }
  });
});
```

#### 4️⃣ 接收方收到消息并展示

用户B 的前端同样通过message事件监听 WebSocket 消息：

```
socket.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  displayMessage(msg.from, msg.content);
};
```

### （8）axios二次封装

#### 为什么要对axios进行二次封装？

对 Axios 的二次封装主要是为了**统一管理网络请求逻辑**，通过拦截器**全局处理错误提示**、**Token 鉴权**、**处理参数格式**等，减少重复代码；同时规范数据响应结构（如自动提取嵌套数据），**简化api（如get，post）调用方式**（如统一设置参数，统一返回 `[err, data]` 格式），并支持扩展缓存、重试等定制功能，最终提升代码复用性、维护性及项目协作效率。

#### 项目中进行了哪些封装？

**1. 基础配置**

- 动态获取后端 API 域名

设置 getBaseURL() 方法，根据当前前端页面的域名自动切换对应的后端 API 地址，方便在不同环境（如测试、生产）下自动适配。

- axios 全局配置

设置了请求超时时间、基础 URL、跨域携带 cookie、默认请求头（如 Content-Type、Authorization、Chat-Token 等）。

**2. 动态请求头处理**

- 设置 getDynamicHeaderData() 方法，动态获取用户的 token、sessionId 等信息，并在每次请求时自动加到请求头里，保证接口安全和用户身份校验。

**1、对get和post这些api进行了封装**

以get api为例，封装了一个新的get函数来获取各项数据，里边调用axios.get(url, params)方法，参数是请求路径url和和要查询的查询参数params。在then中处理请求结果，通过res.data获取到数据。获取成功就用resolve返回数据。请求失败通过catch接到，用rejected返回一个error。

post情况也类似，调用axios.post方法，传入请求数据与URL，在then中处理数据并返回，在catch中处理错误并返回

**2、对请求拦截器进行了封装**

请求拦截器是通过`axios.interceptors.request.use`，对config赋值实现，每次请求前调用getDynamicHeaderData()方法，自动添加动态请求头。

**3、对响应拦截器进行了封装**

对后端返回的数据进行统一处理，只有 code === 0（即请求成功）时才返回数据，否则抛出错误，方便前端统一处理异常。

## 2、流式输出

### （1）简单介绍

​	在健康助手和ai辩论页面，ai回答用户问题时都是通过流式输出进行回复的，可以让用户体验到ai边生成边输出的效果。所谓流式输出就是大模型在数据尚未全部准备好时，就将生成的部分内容分片不断推送给客户端，客户端接收到一段就立刻渲染，而无需等待服务端完整的输出结果。在我们这个项目中流式输出的实现，具体来讲就是后端与大模型 API 之间，采用**text/event-stream**这种sse服务端主动推送消息的通信形式，让大模型生成每段消息分片都马上返回给后端，后端逐步读取到这些消息分片，通过**websocket**实时推送给前端。前端监听websocket的message事件，每次接收到后端推送来的消息分片，就将其追加到当前 AI 回复的消息中，从而实现了用户能实时看到ai边生成边输出的效果。

### （2）详细讲讲如何接收到消息并渲染到页面上的

​	前端对websocket的message事件进行监听，返回的**event**点**data**里存在消息type，根据type判断不同的返回的消息类型并进行不同的处理。与流式输出有关的有**start**、**chat**、**end**三种类型。前端存储消息数组**chatData**，当类型为**start**时，代表AI 开始输出，往chatData中push一个**新的消息对象**准备**接收输出内容**，对象包括新消息的**id**（后端传过来的）、**内容**（空字符串）和消息**类型**（reply），并禁用发送按钮和重新生成按钮，启用停止生成按钮。当类型为**chat**时，代表AI正在**输出内容的分片**，将这个内容分片**追加**到当前消息对象（通过id确定）的内容里并重新渲染到页面上。当类型为end时，代表这个消息的结束，启用发送按钮和重新生成按钮，禁用停止生成按钮。

### （3）流式输出是否有做防抖或节流来控制渲染频率

​	并没有做防抖或节流。首先，防抖或节流目的是为了**控制高频的操作**以**减轻性能压力**。而对于流式输出，每个内容分片大概几十毫秒返回一次，相对来说渲染的**性能压力并没有那么大**，而且流式输出以**用户体验**优先，追求AI“打字”效果最好越快越流畅，所以并没有进行防抖或节流，每次返回消息分片都**立即渲染**到页面上。

### （4）如何处理流式输出的停止

​	在ai正在生成回复的时候，如果用户**点击停止按钮**，或者是**切换到其他会话**，都会**停止**当前进行的流式输出。具体来讲，项目通过状态变量来控制**是否正在渲染**，在**message**事件中对其进行判断，如果为false就直接结束事件，**不再执行**接下来的渲染过程。当点击停止按钮或切换其他对话时，就会调用**停止函数**，将状态变量设置为false，并向后端通过**webSocket.send**发送**停止生成**的信号，信号类型为stop并包含当前消息id，然后通过**webSocket.close**关闭通信。后端接收到停止生成信息后，立即发送给大模型服务器，让大模型停止继续生成。从而实现了流式输出的停止。

### （5）如何处理输出时的加载效果

​	当ai的最新消息在渲染时，右下角会出现一个**闪烁的小圆点**代表正在加载。这个小圆点通过css动画实现闪烁效果，在开始结束都是opacity: 0，50%（即中间时）是opacity: 1，动画持续时长是1秒，无限重复播放。通过状态变量控制小圆点的**显示**和**位置**，保证其只在**ai输出时**显示，且只在**最新的回复**中显示。

​	（如果详细问怎么实现）：当监听message时，如果event.data.type为start或chat，代表ai回复开始或在进行中，就将控制小圆点显示的状态变量设置为true并保存最新id，通过组间传递传到回复组件中，通过判断确定最新的消息，将小圆点动画渲染出来，从而实现了加载效果。

### （6）markdown格式的渲染

​	在项目中，健康助手的回复支持markdown格式的渲染，从而可以实现**丰富的内容展示**，尤其适合医学报告、结构化表格化建议等，让用户能够一目了然地了解健康助手回复的内容。项目中使用了`react-markdown` 库来实现 Markdown 格式的渲染，支持标题、段落、列表等元素，并通过`remark-gfm` 插件实现了表格的渲染。使用时，通过`react-markdown` 库引入ReactMarkdown标签，被标签包裹的内容就会通过被渲染成markdown格式，标签的属性中有remarkPlugins={[remarkGfm]}，从而将`remark-gfm` 插件加入以实现表格的渲染。



### （7）思考内容如何渲染到页面上

​	与正式回复内容的流程基本相同，思考过程同样被看做是一条对话消息。是根据start，end，think三种类型来判断，当类型为**start**时，代表AI 开始输出，往chatData中push一个**新的消息对象**准备**接收输出内容**。当类型为**think**时，代表AI正在**输出思考内容的分片**，将这个内容分片**追加**到当前消息对象（通过id确定）的思考内容里并重新渲染到页面上。当类型为end时，代表这个消息的结束，启用发送按钮和重新生成按钮，禁用停止生成按钮。

## 3、图片上传

### （1）如何实现的图片上传

**关键点解释**

#### 1、基本组件**`<Upload {...props}>`**

​	组件包含了很多属性和函数

- `name`：指定传给后端的图片参数名。
- `action`：上传地址，即后端接收上传请求的 URL。Upload 组件会把文件以 `multipart/form-data` 的形式 POST 到此地址。
- `headers`：因为后端需要鉴权（如 Bearer Token、Cookie 等）在这里统一设置请求头，这里直接调用request.js文件中设置好的**getDynamicHeaderData**函数动态设置请求头。
- maxCount： 设置最多上传图片数量，项目中为10张
- fileList = {picList} ：把 Upload 的“文件列表属性”与usestate picList数组 关联起来，属于受控模式。这样做可以在 `onChange` 里随时拿到当前所有上传进度、状态、后端返回信息等，并决定如何更新展示。
- `onChange(info)`：上传中、完成、失败都会调用这个函数，`info` 对象包含以下重要字段：
  - `info.file`：代表当前操作的文件对象（包含 `status`、`name`、`uid`、以及后端返回的 `response` 等）。
  - `info.fileList`：当前所有上传中文件的列表（数组）。
  - `info.event`：在上传过程中，如果开启了分片或流式，可以看到更详细的进度条事件。
- `info.file.status`：代表当前状态，可能的状态有
  - `"uploading"`：正在上传
  - `"done"`：上传完成并收到后端响应
  - `"error"`：上传出错
  - `"removed"`：文件被移除



**假如问为什么 “进行中” 会多次调用 `onChange`**

- `<Upload>` 底层其实是通过 `<input type="file" />` 选中文件后，使用 XHR（或 `fetch` + `FormData`）向后端上传文件。
- 浏览器在真正开始上传时，会不断触发 XHR 的 `upload.progress` 事件（每下载/上传一定字节就会发一次），以便前端更新进度条。
- Ant Design 的源码对这个 `progress` 事件做了监听，一旦收到新的进度，就会给当前那条 `file` 的 `percent` 字段“打上新值”，并且把更新后的 `file`（以及新的 `fileList`）传给你在 `onChange(info)` 中的 `info` 对象。
- 因此，当后端正在接收数据、浏览器不断上报进度时，`onChange` 会**随着每一次 XHR 进度事件**被调用一次，而且每次调用里的 `info.file.status` 都是 `'uploading'`，`info.file.percent` 则会逐步从 0 → 100。

简而言之，**“进行中”状态的 `onChange` 触发时机，就是每当浏览器报告上传进度时**。这个次数并不是固定的 “3 次” 或 “5 次”，而是取决于：

1. 你的网络带宽与后端处理速度。
2. 文件大小越大，越多字节被分批上传，浏览器就会触发更多次 `xhr.upload.progress`。
3. 浏览器和服务器之间的握手、分片策略也会影响进度事件触发的粒度。



最基本的用法，仅演示如何上传图片到后端（假设后端上传地址为 `/api/upload`）：

```jsx
import React from "react";
import { Upload, Button, message } from "antd";
import { UploadOutlined } from "@ant-design/icons";

export default function SimpleImageUpload() {
  const props = {
    name: "file",                           // 后端接收文件字段名，例如 req.file 或 req.files["file"]
    action: "/api/upload",                   // 文件上传的后端接口 URL
    headers: {
      authorization: "Bearer token_here",    // 如需鉴权，可在头部加 token；若无可省略
    },
    onChange(info) {
      // info.file.status: 上传状态：uploading | done | error | removed
      if (info.file.status === "uploading") {
        console.log("上传中：", info.file, info.fileList);
      }
      if (info.file.status === "done") {
        message.success(`${info.file.name} 上传成功`);
        // info.file.response: 后端返回的数据（假设后端返回 { url: "http://..." }）
        console.log("后端返回：", info.file.response);
      } else if (info.file.status === "error") {
        message.error(`${info.file.name} 上传失败`);
      }
    },
  };

  return (
    <Upload {...props}>
      <Button icon={<UploadOutlined />}>点击上传图片</Button>
    </Upload>
  );
}
```



#### 2、限制上传格式与大小

在项目中，需要校验用户只能上传指定图片类型（image下边的文件类型）且体积不能超过5MB。我们可以通过 `beforeUpload` 属性在前端先行拦截。	

**详细解释**

1. **`beforeUpload(file)`**
   - 会在文件发出网络请求之前被调用，参数 `file`为上传的文件。
   - 在函数中检查 `file.type`，来判断是否是图片类型文件（file.type.startsWith("image/")）、`file.size`，来检查图片是否小于5MB （file.size / 1024 / 1024 < 5）。
   - 如果返回 `false`，Upload 就会阻止该文件继续上传，并向用户进行提示。
   - 如果返回 `true`，则正常上传。
2. **`accept=".jpg,.jpeg,.png"`**
   - 只让用户在系统文件选择对话框中可见指定后缀的文件，但注意这只是前端“视觉”层面的过滤，让用户选择文件时只出现相关类型的文件，有可能被用户绕过，所以仍建议在 `beforeUpload` 中做二次校验。



#### 3、图片预览功能

用户选图进行上传，上传成功在输入框上方展示缩略图，上传失败显示错误的占位符，正在上传显示进度条。无论那种状态都附带叉号按钮可以将图片删除。核心在于：

1. 从后端获取到返回的文件对象，包括状态、URL、id和百分比，把它存到一个数组里（`picList`）；
2. 让 React 根据这个数组，动态地渲染出一排缩略图；
3. 每个缩略图外层用相对定位，里层是 `<img>`，右上角叠加一个 “×” 图标，点击时从数组里把对应项移除。

**详细说明**：

​	1、首先设置`picList`这个数组来存储每个上传文件的返回结果，数组的对象元素中包括状态status、URL（上传成功才有）、id和百分比percent（上传中才有）

​	2、在onchange事件对应的函数中，根据后端返回的不同的文件状态进行不同处理。

- `"uploading"`：代表正在上传中，通过find方法结合文件id在picList中找到那个文件对象，修改其百分比属性为新的file.percent；如果找不到相应文件代表这是新上传的图片，就给数组追加一个新的对象。
- "done"： 上传成功，后端返回结果中包括图片的URL,在picurls数组中找到相应文件对象并将图片URL和成功状态加进去
- "error"：上传失败，给用户弹出错误，并将失败状态赋值给数组中相应文件对象

​	3、对整个picList进行渲染，也分成三种状态对不同的文件进行渲染。

- `"uploading"`：结合antd库的Progress进度条组件，给Percent属性传入文件对象的百分比属性值，从而实现进度条加载效果。
- "done"： 将URL设置为img图片的src地址，显示缩略图
- "error"：显示一个错误的占位图标



#### **4、上传图片浏览**

​	用户可以对所有成功上传图片进行全屏浏览，我在做自己项目时封装过一个图片浏览器组件，这里需求相同，我就复用了之前封装的组件。给picList数组通过filter根据状态过滤出所有上传成功的图片，传入图片浏览器组件即可。



### （2）如果不使用antd，如何实现文件或图片上传功能？

​	可以使用input表单，表单类型为file，用户点击表单后就可以选择文件。再构造FormData，将用户选择的文件通过append添加到里边。最后把‘formData通过post发送到相应的后端接口，即可实现文件或图片上传。

#### **什么是FormData**

**定义**：`FormData` 是浏览器内置的一个构造函数（Web API），专门用来以 `multipart/form-data` 的格式组织键值对（key/value），其中 value 可以是简单的字符串，也可以是 `File`、`Blob` 等二进制对象。

**作用**：它会自动为你拼装出符合 HTTP “多部分表单”标准的请求体，包括自动生成 boundary（分隔符）并在请求头中加上正确的 `Content-Type: multipart/form-data; boundary=…`。开发者只需把字段（和文件）一一追加进去，最后把整个 `FormData` 对象当作请求体发送即可。



#### **什么是content-type**

**`Content-Type`** 实体头部用于指示资源的MIME类型 media type 比较常用的有数据接口`application/json`，文本`text/css`，图片`image/jpeg`

在请求中 (如`POST`或 `PUT`)，客户端告诉服务器实际发送的数据类型



#### **什么是multipart/form-data**

`multipart/form-data` 是一种在 HTTP 请求中传输“表单数据+文件”时常用的编码格式，主要用于实现文件上传功能。

1. **作用场景**
    当你在网页里有一个带文件输入（`<input type="file">`）的表单，并且要把文本字段和二进制文件（如图片、视频）一起发送到服务器时，就需要用 `multipart/form-data`。相比普通的 `application/x-www-form-urlencoded`（只能传文本），它能把文件分片并打包，让服务器正常解析。

2. **分段边界（boundary）**
    请求头里multipart/form-data后边会出现boundary

   ```
   Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAbCdEf123456
   ```

   `boundary`（分界符）是浏览器随机生成的一段字符串，用来把整个请求体分成若干“段”。每一段对应一个表单字段（可以是普通文本，也可以是文件），每遇到一个 `boundary`，就表示新一段内容开始。浏览器和服务器通过这个分隔符，就能把整块二进制数据拆成若干个独立的字段。

3. **请求体结构**

   - **普通字段**：
      每段最上面有一行 `Content-Disposition: form-data; name="字段名"`，紧接着空一行，然后放字段值。
   - **文件字段**：
      除了 `Content-Disposition` 里有 `filename="文件名"`，还会额外有一行 `Content-Type: 文件MIME类型`（如 `image/jpeg`、`application/pdf`），然后空一行后直接跟文件的二进制内容。

4. **优点**

   - 可以同时上传文本和一个或多个文件。
   - 浏览器自动处理边界，无需开发者手动拼接，只需把字段或文件 `append` 到 `FormData`，然后用 `fetch` 或 `XMLHttpRequest` 发送即可。
   - 后端框架（如 Node.js 的 multer、PHP 的 $_FILES、Java 的 MultipartResolver 等）都能自动识别 `multipart/form-data` 并提取各段数据。

5. **与其他编码的区别**

   - **`application/x-www-form-urlencoded`**：只能发送文本字段，所有数据都会被 URL 编码（例如把空格变成 `+`、把特殊字符变成 `%**`）。
   - **`text/plain`**：将表单内容按纯文本方式发送，根本不常用于文件上传。
   - **`multipart/form-data`**：把每个字段或文件都当成一段，用边界分隔，既能传文本又能传二进制，适合文件上传。



### （3）如何实现大文件上传

​	当大文件上传时，如果直接通过普通文件上传的模式，通过FormData包装上传，很容易上传失败，重新上传又从头开始，非常浪费时间。就算上传成功，下次上传同样的文件又要重新上传，对用户体验也是比较差。
​	为解决这些问题，可以通过秒传+分片上传+断点续传实现大文件上传。

我讲一下**整体思路**

1. 秒传 **计算文件指纹（或者叫Hash值）**
   - 用于“秒传”场景：先在前端对整个文件做一个唯一指纹（如果问：可以通过MD5结合webWorker实现）。
   - 指纹一旦计算出来，向后端查询该指纹是否已存在。如果后端已有该指纹且对应的文件完整可用，则说明后端已经上传过了这个文件，则告知前端可以“秒传”跳过，直接标记上传成功。
2. **分片切片（Chunk）+ 断点续传**
   1. `Blob`它表示原始数据，也是二进制数据，同时提供数据截取的方法`slice`，而 `File`是`Blob`的子类继承了`slice`方法，所以可以利用`slice`方法将大文件分割成若干份文件分片，每个块都有固定大小（比如 1 MB、2 MB、5 MB，或业务可配置），将分片存储起来并设置索引。
   2. 前端先与后端协商、获取哪些块已经上传。
   3. 仅上传未完成的块，并实时记录已成功上传的分片索引。中途若因为网络断开等原因导致上传失败，再次上传时仅需从上次中断处继续上传剩余的块。
3. **并发上传与进度控制**
   - 对每个分片进行并发上传，可以显著提升整体上传速度。
   - 需要对并发数做限流（比如同时上传 3~5 个分片），避免压垮网络或服务器。
   - 在界面上实时展示进度（已上传字节 / 总字节），并兼顾分片重试逻辑。
4. **断点续传状态存储**
   - 例如在前端使用 `localStorage` 临时记录上传进度（已成功上传的分片索引、已完成大小等）。
   - 这样即便页面刷新、浏览器崩溃，也能读取之前的状态，避免重头上传。



如果问：

**为什么要用 Web Worker？**
 浏览器中，主线程（UI 线程）同时负责渲染界面、响应用户操作、执行 JavaScript 等。如果直接在主线程里对一个很大的 `File` 对象做哈希（比如用 SparkMD5 一次性读完整个文件），这段计算会持续几秒甚至更长时间，页面会卡死，用户体验很差。
 Web Worker 相当于一个独立的 JavaScript 线程，它和主线程之间只能通过 `postMessage` 发送消息，互不干扰。我们可以把文件分片后的哈希计算逻辑放到 Worker 里，让主线程保持流畅。

**总体流程**

- 主线程负责把 `File` 对象按固定大小（例如 2 MB）切成若干分片。
- 主线程通过 `FileReader.readAsArrayBuffer` 依次将每个分片读成 `ArrayBuffer`，然后通过 `worker.postMessage` 把这一段二进制数据传给 Worker。
- 在 Worker 里（独立线程），使用增量哈希库（比如 SparkMD5）对每个收到的 `ArrayBuffer` 调用 `.append()`，一直循环累加。
- 当所有分片都发给 Worker 之后，主线程再发一个特殊的“hash 完成”信号，Worker 调用 `.end()` 得到最终的 hash 值，然后通过 `postMessage` 把最终结果回传给主线程。
- 主线程拿到这个最终 hash 后，就可以去调用后端“检查是否已存在”接口。



**并发上传大致思路**

1、设置每个上传批次的分片个数

1. 每次从 所有分片中选出对应的分片，组成一个批次
2. 用 `对批次进行遍历.map(uploadChunk)` 生成该批次的 `Promise` 数组
3. 调用 `await Promise.allSettled(batchPromises)`将所有Promise都上传，等待这批分片都“settle”（无论成功或失败）
4. 本批结束后，把指针往后移 `MAX_CONCURRENCY`，开始下一批
5. 最终，当所有批次都完成，再调用「合并接口」，让后端将所有上传的分片合并起来，形成最终的大文件

## 4、历史会话

### （1）如何获取的历史会话列表数据？

​	在项目的websocket连接中监听的Message事件，返回的**event**点**data**里存在消息type，根据type判断不同的返回的消息类型并进行不同的处理。在打开页面后，会返回一个conversation_created的类型消息，这个消息代表已创建的历史会话。前端得到这个消息后，就向后端通过get获取历史会话列表，拿到后存储起来渲染到页面上。

### （2）如何实现历史对话的切换？

​	在项目中，每个对话都有其对应的独一无二的会话id，通过会话id就可以判断是哪一段对话。切换历史对话时，会触发changeChat函数，将这一历史对话的id传进去。

在函数中

1、如果当前有正在进行的会话，先关闭掉websocket连接，清空心跳检测。然后清空存储当前多轮对话的chatData数组并重置当前对话信息，将其中的id改为历史会话的id

2、通过get将历史会话id传到后端，获取到对应历史会话的多轮消息，将这些新获取到的消息遍历存入chatData数组中，成为当前对话消息

3、将历史会话渲染到页面上，调用函数重新建立webSocket连接

在切换到历史对话后，用户可以接着就之前的话题进行问答。因为AI具有上下文记忆的功能（大模型端本身具有的功能，如果没有这个功能，可以由后端在向大模型发送用户消息时，带上之前几条的历史对话），所以可以无缝衔接，继续讨论之前的问题。



## 5、项目AI简介

------

健康助手是一种多agent协作构建的ai

### 1. 架构与模块划分

项目主要分为以下三大模块，每个模块对应若干个 Agent（智能体）：

1. **用户信息处理模块**
   - **作用**：对用户输入（包括病史描述、症状等）进行结构化、标准化处理，提取关键信息，方便后续推理和检索。
   - **模型选型**：采用 ERNIE Functions-8K-0321 —— 该模型在**结构化输出能力**和**输出格式稳定性**方面表现优异，能够保证批量信息抽取时的准确性和一致性。
2. **诊断推理模块**（双 Agent 协作架构）
   - **推理 Agent**
     - **模型选型**：DeepSeek-R1-Distill-Qwen-14B —— 推理能力较强、推理过程可解释性高，能够针对症状信息给出详细的病因分析。
   - **专科 Agent**
     - **模型选型**：DISC-MedLLM —— 专门针对医疗健康对话场景微调过的大模型，擅长根据患者需求给出“贴合实际”的专家建议。
   - **协作方式**：
     1. 用户信息处理模块提取到的结构化症状数据，先由“推理 Agent”进行初步的病症分析；
     2. 再将推理结果交给“专科 Agent”，结合专业医学知识给出更深入、更具可操作性的诊疗建议。
3. **治疗规划模块**（双 Agent 协作架构）
   - **治疗规划 Agent & 检查 Agent**
     - **模型选型**：都采用 ERNIE-4.0-8K —— 该模型自动对接百度搜索插件，能够实时检索最新医学指南、文献和诊疗规范，保证给出的治疗方案**准确且具有时效性**。
   - **协作方式**：
     1. 先由“治疗规划 Agent” 根据诊断结果和用户需求，制定初步的治疗思路（包括药物、检查、风险提示等）；
     2. 再由“检查 Agent”通过百度搜索插件实时查证或补充最新的检查流程、检查指标、费用估算等信息。

------

### 3. 多 Agent 协作链路的搭建

1. **统一使用百度千帆 SDK**（不主动讲）
   - 因为现有市面上的多 Agent 框架（如 Camel、AutoAgent 等）并不原生支持百度千帆 SDK，所以开发团队借鉴了它们的设计规范（尤其是 Camel 的链式调用逻辑）。
   - 最终搭建了包括：
     - **模型初始化调用**：统一通过千帆 SDK API 装载不同的大模型；
     - **记忆存储**：保存对话上下文、用户偏好等辅助信息；
     - **双 Agent 协作链路**：在一个业务流程里，先调用一个 Agent，获取中间结果后传给下一个 Agent；
     - **RAG（Retrieval-Augmented Generation）工具调用**：结合本地知识库和在线搜索插件，实现“问答+检索融合”的效果。
2. **RAG 工具具体实现**
   - **本地知识库**：使用 Camel 库搭建，内容来源于团队爬取的医学 PDF（指南、论文、临床规范等）。
   - **数据处理**：
     - 用 Pandas 读取 PDF 提取后的文本，将换行、制表符、空格等转义字符清洗干净；
     - 对重要医学术语或章节标题进行分段索引，便于后续检索。
   - **检索流程**：前端发起问题时，后端先根据用户输入的向量化信息在本地知识库中查找相关答案；如未命中或命中置信度较低，则进一步调用百度搜索插件，获取最新在线信息；最后将“本地检索结果 + 在线检索结果”综合传给对应模型，让模型生成最终回答。



## 6、ai辩论

### 1、前端发起辩论请求

- 用户在前端输入辩论主题、正方观点、反方观点，点击“开始辩论”。

- 前端将这些信息（包括主题、正反方观点、辩论ID等）通过 WebSocket 发送给后端。

------

### 2. 后端生成辩论内容

- 后端收到请求后，自动推进辩论流程，根据设定的辩论阶段（如立论、质询、驳论等），让AI分别以正方和反方的身份生成观点和发言。

- 每一轮、每一阶段，后端都会生成当前角色（正方/反方）的发言内容，并标记轮次和角色。

------

### 3. 前端接收并渲染

- 前端通过 WebSocket 实时接收后端推送的每一条消息。

- 每条消息都包含：

- 角色（正方/反方，speakerA/speakerB）

- 内容（观点、发言、思考过程等）

- 轮次（第几轮、第几阶段）

- 前端根据这些信息，将消息渲染到对应的角色和轮次位置，实现辩论流程的可视化推进。

------

### 4. 整体效果

- 用户只需设置主题和观点，后续流程全自动推进。

- 前端只负责收集输入、发送请求、接收消息、按角色和轮次渲染，无需关心AI如何生成内容。

- 整个辩论过程对用户来说是“所见即所得”的。



### 后端如何实现的这一过程

**并不是分开调用两个大模型**

- 不是分别调用两个大模型，而是同一个大模型，轮流以不同角色身份发言。

- 后端会在每一轮，先以正方身份组织 prompt，发送给大模型，得到正方发言；再以反方身份组织 prompt，发送给大模型，得到反方发言。

- 每次请求时，都会带上当前角色的身份、观点、历史发言等上下文，确保大模型能“扮演”好当前角色。

**代码流程**

1.前端发起辩论请求，带上主题、正反方观点等。

2.后端收到请求，进入辩论流程推进逻辑。

3.每一轮：

- 先组装正方的 prompt（包含主题、正方观点、历史发言等），发送给大模型，得到正方发言。

- 再组装反方的 prompt（包含主题、反方观点、历史发言等），发送给大模型，得到反方发言。

- 每次请求都带有 role 字段，告诉大模型“你现在是正方/反方”。

4.后端将每一轮的发言和角色信息推送给前端，前端按角色和轮次渲染。



## 7、白屏问题

白屏通常指的是页面加载过程中，由于各种原因导致用户在一段时间内看到一个空白页面，无法看到预期的内容。

### （1）出现白屏的原因

几种主要的原因：

1、资源加载失败页面依赖的关键资源(CSS、JS、图片等)加载失败,导致页面无法正常渲染。

2、资源加载延迟(或阻塞)，导致页面长时间等待资源加载完成。出现空白。

3、 代码执行中出现未被捕捉的错误，例如JavaScript执行错误，Promise错误等等。导致页面功能无法正常工作，出现空白。

4、浏览器兼容问题 不同的浏览器对于前端技术的支持程度不同，如果我们使用了浏览器不支持的语法或者CSS类型，可能导致某些浏览器无法正常显示页面。

### （2）如何排查白屏原因

#### 1、打开开发者工具（Console/Network）观察

**Console（控制台）报错**

- 通常首要打开控制台，看看有没有语法错误（`SyntaxError`）、找不到模块（`404` 或 `Module not found`）、运行时异常（`ReferenceError`、`TypeError` 等）。
- 如果出现报错，很可能是 JS 执行到某一行出错，导致后续的渲染流程直接中断，让页面显示白屏。

**Network（网络）请求**

- 查看 HTML、JS、CSS、图片等资源的请求状态。
- 如果核心的 `index.html`、`bundle.js`、`main.css` 加载失败（HTTP 404/500），页面肯定无法渲染。
- 注意检查 MIME 类型、CORS、域名配置、路径前缀（尤其是 SPA 部署在子目录时容易出错）。

**在代码中**

- 可以在代码中在一些关键的节点通过colsole.log输出一些关键的变量、参数、对象、数组等，判断流程是否成功
- 可以在react中的使用 Error Boundary，以便在渲染阶段出错时展示兜底 UI，并在 Console 打日志展示错误，避免直接白屏。
- 在关键的节点可以通过debugger添加调试节点，方便在开发者工具中进行调试

### （2）如何监测页面白屏

​	在代码中可以通过一些自动化方案，通过性能监测埋点，对白屏情况进行检测。

**方案一：检测根节点是否渲染+onerror监听**

原理很简单，DOM 一般挂载在一个根节点之下（比如 `<div id="app"></div>` ），发生白屏后通常是根节点下所有 DOM 被卸载。该方案就是通过监听全局的 `onerror` 事件，在异常发生时去检测根节点下是否挂载 DOM，若无则证明白屏。

这种方案，简单直接，直接检测根节点是否渲染完成即可。适用于SPA。SPA页面主要内容通过根节点下的组件渲染,所以监测根节点渲染情况可以判断SPA页面主要内容是否正常渲染。

**方案二：Mutation Observer 监听 DOM 变化**

实现方法：

- 在页面最早能执行的脚本里（比如放在 `<head>` 中的轻量埋点脚本），先定义一个 `MutationObserver` 实例。
- 同时在脚本里启动一个定时器（例如 `setTimeout`，5 秒或 10 秒为阈值）。
- 如果在阈值时间内，Observer 回调从未“认为页面已渲染”（即关键容器依旧空空如也），就可以判定为“疑似白屏”，然后在定时器到点时执行上报逻辑。
- 在回调和定时器中分别调用不同上报方法：
  - **正常渲染**：`reportRendered()` 上报首屏渲染成功的时间点、页面路径等。
  - **疑似白屏**：`reportWhiteScreen()` 上报白屏事件，包括 URL、UserAgent、网络类型、时间戳等。

收到埋点后，后端监控系统可以统计白屏率，并结合 `window.onerror`、资源加载失败等其他埋点进行分析。



一点小问题

同时如果用户长时间未操作DOM，Mutation Observer 监听到一定时间内没有 DOM 变化，就可能会误判为页面白屏。

实际应用中，可以通过一些手段来增加 DOM 的变化，从而避免误判。比如，在页面初始化时，可以在页面中插入一些隐藏的元素，然后定时更新这些元素的样式或内容，从而让 Mutation Observer 监听到 DOM 的变化。另外，一些自动化的数据推送、广告展示等行为也会引起 DOM 的变化，这些行为也可以被 Mutation Observer 监听到，从而避免误判。



**方案三：关键点采样对比**

所谓关键点采样就是在我们的屏幕中，随机取几个固定的点，利用document.elementsFromPoint（x,y）该函数返还在特定坐标点下的 HTML 元素数组。

在获取页面宽高之后，在页面垂直/交叉位置确定多个采样点，通过 [elementFromPoint](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDocument%2FelementFromPoint) 方法获取采样点的元素，然后判断采样点冒泡元素集合的第一个元素是否为容器元素（如标签为body）、加载态元素（例如骨架屏或有loading类名的元素），当存在一定比例（例如超过80%）的采样点元素为容器元素或加载态元素时则可以判定为白屏。



### 白屏优化

**1. 优化 HTML 结构**

- **减少 HTML 文件大小**：压缩 HTML 文件，移除不必要的空格、注释和冗余代码。
- **使用语义化标签**：使用语义化标签（如 `<header>`、`<footer>`、`<article>` 等），提高页面结构的可读性和可维护性。

**2. 优化 CSS**

- **内联关键 CSS**：将关键路径的 CSS 内联到 HTML 文件中，减少首次渲染时的网络请求。
- **使用 CSS 预处理器**：使用 Sass、Less 等 CSS 预处理器，减少重复代码，提高 CSS 的可维护性。
- **压缩 CSS 文件**：压缩 CSS 文件，减少文件大小，加快加载速度。

**3. 优化 JavaScript**

- **异步加载 JavaScript**：使用 `async` 或 `defer` 属性异步加载 JavaScript 文件，避免阻塞页面渲染。

  ```
  <script src="script.js" async></script>
  <script src="script.js" defer></script>
  ```

- **延迟加载非关键 JavaScript**：将非关键的 JavaScript 延迟加载，优先加载关键内容。

  ```
  <script src="non-critical.js" defer></script>
  ```

- **按需加载路由**：将每个页面路由组件，拆成单独的一个个 chunk 文件，这样 main.js 文件体积降低，在首屏加载时，不会再加载其他页面的资源，从而提升首屏渲染速度。

- **减少 JavaScript 文件大小**：压缩 JavaScript 文件，移除不必要的空格、注释和冗余代码。

**4. 优化图片**

- **使用适当的图片格式**：根据图片内容选择合适的格式（如 JPEG、PNG、WebP 等），减少图片文件大小。

- **压缩图片**：使用图片压缩工具（如 ImageOptim、TinyPNG 等）压缩图片，减少文件大小。

- **延迟加载图片**：使用懒加载技术，延迟加载页面中的图片，优先加载关键内容。

  ```
  <img src="placeholder.jpg" data-src="image.jpg" alt="Image">
  ```

**5. 优化网络请求**

- **减少 HTTP 请求**：合并 CSS 和 JavaScript 文件，减少页面加载时的 HTTP 请求数量。
- **使用 CDN**：使用内容分发网络（CDN）加速静态资源的加载。
- **启用 HTTP/2**：使用 HTTP/2 协议，提高页面加载速度。

**DNS 查询优化**

前端侧，可以通过在页面中加入 **dns-prefetch**，在静态资源请求之前对域名进行解析，从而减少用户进入页面的等待时间。如下所示：

```ini
<meta http-equiv="x-dns-prefetch-control" content="on" />

<link rel="dns-prefetch" href="https://s.google.com/" >
```

其中第一行中的 x-dns-prefetch-control 表示开启 DNS 预解析功能，第二行 dns-prefetch 表示强制对 s.google.com 的域名做预解析。这样在 s.google.com 的资源请求开始前，DNS 解析完成，后续请求就不需要重复做解析了。

**通过骨架屏或loading进行优化**

在未加载出来时展示骨架屏或loading，以提高用户体验

**借助webWorker**

Web Worker 相当于一个独立的 JavaScript 线程，它和主线程之间只能通过 `postMessage` 发送消息，互不干扰。我们可以把文件分片后的哈希计算逻辑放到 Worker 里，避免阻塞主线程加载，让主线程保持流畅。



## 8、项目中为什么不使用redux

### 1. 状态管理需求较简单

AI 对话页面的核心状态一般包括：

- 当前用户输入（input）

- 聊天记录（messages/history）

- 加载状态（如“正在生成回复”）

- 可能的错误提示

这些状态大多只在当前页面内使用，不需要在多个页面或组件间频繁共享。

------

### 2. 组件层级较浅，数据流简单

- 聊天页面通常结构简单，父组件（如 ChatPage）下有输入框、消息列表等子组件。

- 父组件用 useState 就能轻松管理所有状态，并通过 props 传递给子组件。

- 不存在跨页面、跨模块的数据同步问题。

------

### 3. 状态变化逻辑不复杂

- 聊天记录的增删改查、输入框内容的变化、loading 状态切换等，都是局部、同步、简单的状态变更。

- 不需要复杂的异步状态管理（如多个接口并发、全局 loading、复杂的业务流转等）。

------

### 4. 性能和开发效率考虑

- Redux 引入后会增加样板代码（actions、reducers、store 配置等），对于简单页面反而拖慢开发效率。

- 直接用 useState/useReducer/useContext，代码更简洁，维护成本更低。

------

### 5. 未来扩展性

- 如果后续项目变复杂，比如加入多页面、用户系统、全局主题、通知等，可以再考虑引入 Redux。

- 但对于单页面、单功能的对话应用，React 自带的状态管理能力完全足够。



## 9、实习中有遇到什么困难吗，最后是怎样解决的

​	有的，例如在实现图片上传功能时，除了借助AntDesign的upload组件实现了上传，还需要实现在输入框上方对上传图片的结果进行预览，以及浏览上传图片的功能。而这两个需求直接通过antd提供的方案难以完美实现。例如对图片上传结果进行预览，antd提供的照片墙方案较为简陋，形式上也不符合我们项目中输入框底部点击上传按钮，输入框上方展示图片的模式。所以考虑之后，我决定自己封装图片预览组件。我先和后端同事讨论，确定好返回的参数，包括状态、URL（成功返回）、id和进度（上传中返回），把所有返回结果存到一个数组（`picList`）；然后根据不同的状态渲染出一排不同结果的缩略图，成功渲染图片URL，失败是一个错误占位符，正在上传借助antd的progress组件与进度渲染出进度条；每个缩略图用定位在右上角叠加一个叉号图标，点击后就从数组里把对应项移除。此外，对于浏览上传图片功能，antd的方案仅能实现单个图片浏览，如果用户上传了多张图片，还需要退出重新点击另一张图片进行查看，用户体验较为麻烦。我在自己的宅宿甄选项目中曾经封装过图片浏览器组件，可以随意丝滑切换图片，底部还有图片指示器方便用户浏览。对比后我发现这两个项目图片浏览需求基本一致，于是我将自己的组件复用到了实习项目中，效果很不错。以上这就是我遇到的困难和解决的过程。



## 10、实习中有什么收获

​	在实习中，我首先了解到了参与到一个真实的企业项目开发的大致流程，有了实践的经验。也了解到了彼此间如何协作开发，进一步掌握了git的使用，并锻炼了我的沟通交流能力。参与到实际项目中的代码开发，也使我的技术进一步熟练。此外，我在项目中也学到许多之前没有用过的新知识新技术，并进行了实际应用，如webSocket的使用以及图片上传等功能的实现等等，拓宽了我的知识面。总的来讲收获很多。



## 11、项目的开发流程是怎样的？

​	开发流程的话，我实习的公司比较小，人也比较少，开发流程可能没有那么完整。我们项目使用的是阿里云的云效进行代码管理的。首先如果要开发一个新业务，需要开一个新的分支，在这个分支中进行开发。开发完之后，从本地验证没问题了，就发起合并请求。随后带我的老师会大致审阅一下我的代码有没有问题，看出来的问题就进行修改，没有的话就合并到dev分支中，并手动触发流水线，部署到测试网站上。在测试网站上我会和测试人员一起使用功能看看有无我没发现的问题，或者是生产环境与开发环境不同造成的问题，如果发现有问题就修改再重新测试。直到测试没问题后，代码就从dev分支合并到master分支中，触发对应的流水线部署上线。



## 12、有没有测试出现的问题，是如何修改的？

​	有的，有时会因为生产环境和开发环境不同造成问题。比如我在开发首页的导航助手悬浮球功能时，在本地实现很成功，但部署到测试网站中始终不显示。后来排查了很久发现是由于登录鉴权的问题。悬浮球只有在用户登录后才会显示，这需要登录鉴权来实现。项目在用户登录后会往localstorage中传递token，未登录时不存在token。所以我通过getItem加if条件判断检测是本地存储中是否有token这一项，有就显示，没有就不显示，从而实现登录鉴权。但生产环境和开发环境中，后端返回的token名称不一致，我在代码中if对比的是开发环境的token名称，在生产环境中没有这一项，所以不会显示。修改很简单，把对比的token名改成生产环境的token名就可以。



其他问题比如：在实现切换历史会话功能时，一开始只考虑到静态时的操作，未考虑到AI正在输出时点击切换的问题。自己测试时发现AI正在输出时，由于上一个对话的webSocket未关闭，有时会出现消息串台的问题，在当前会话中输出另一会话的内容。所以马上进行了修改，给切换会话的函数最开始就加上关闭WebSocket和清楚心跳检测的代码，并在输出时加上判断会话id是否一致的条件，从而解决了问题。



## 13、项目中的技术选型是怎么确定的

​	基本的技术选型是根据项目统一的标准已经确定好的，比如使用react框架，使用antd库，使用wbsocket进行前后端通信等。当然也有一些技术栈是新添加进去的，比如使用react-markdown来渲染markdown格式的文本，这也是经过了和markdown-it，MDX等其他渲染方式比较后选择的。

**react-markdown的优势：**

**原生 React 组件化渲染**

- 直接把 Markdown 文本作为子节点传给 `<ReactMarkdown>`，输出结果就是标准的 React 元素，能够和你项目中其他组件无缝组合、复用、测试和样式化。

**内置安全过滤（防 XSS）**

- 默认会移除或转义潜在的危险 HTML（如 `<script>`），避免手写 innerHTML 时常见的跨站脚本攻击风险。

**丰富的插件生态**

- 可以套用大量现成插件：
- 插件机制让你无需从零实现这些功能，只需几行配置即可完成。

**轻量高效**

- 核心包小（gzip 后约 6 KB），只做 Markdown→React 的“管道”工作，不捆绑样式，也不强制你引入不必要的依赖。
- 渲染性能优秀，处理大型文档或频繁更新时不容易成为瓶颈。



**与markdown-it，MDX的对比**

**markdown‑it**

- **核心思路**：
  - 将 Markdown 文本解析成 HTML 字符串。
  - 使用 `dangerouslySetInnerHTML` 注入渲染结果。
- **相较于 react‑markdown 的不足**：
  1. **React 组件化**：输出是纯 HTML，无法生成可定制的 React 元素树，难以在 `<h1>`、`<code>` 等标签上挂载 React 组件或自定义 props。
  2. **安全性**：由于是直接通过html注入渲染结果，默认不做 XSS 过滤，可能会造成一定风险，还需要额外引入并配置诸如 DOMPurify；而 react‑markdown 默认即防 XSS。
  3. **测试与复用**：无法像 React 组件那样独立单元测试或复用渲染逻辑，样式隔离也更麻烦。

**MDX** (`@mdx-js/react`)

- **核心思路**：
  - 将 Markdown 当作 JSX 语法解析，能在 Markdown 文档中直接写入和渲染任意 React 组件。
  - 编译时（Babel/Webpack）把 `.mdx` 文件转成 React 组件，再在运行时使用。
- **相较于 react‑markdown 的不足**：
  1. **构建复杂度**：需要额外的编译工具链（Babel/Webpack/ESBuild 插件），不能直接在运行时把字符串渲染成元素。
  2. **运行时开销**：MDX 在客户端动态渲染时，包体积和启动成本较高；react‑markdown 只引入一个轻量的运行时库。
  3. **灵活性过剩**：项目中仅需普通 Markdown 渲染，MDX 的能力往往过剩且配置较繁琐。



**XSS 攻击**

**概念：**指**跨站脚本攻击**，攻击者**在网站注入恶意脚本**，在用户浏览器运行，窃取用户信息，调用网站接口执行攻击者操作

**攻击操作：**

- 获取页面的数据，如DOM、cookie、localStorage；
- DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
- 破坏页面结构；
- 流量劫持（将链接指向某网站）；

**攻击类型：**

- **储存型：**恶意脚本储存在服务器上，请求资源时传回（论坛发布，商品评论）
- **反射型：**诱导服务器返回恶意代码的 URL，服务器接收带有 XSS 的数据当作脚本运行（网页搜索，跳转）
- **DOM 型：**通过修改页面的 DOM 节点形成 XSS（ JS 自身的安全漏洞）

**如何防御：**

- **输入验证和过滤：**确保只接受复合预期格式和类型的输入，过滤潜在的危险字符（> < " ’ &）
- **输入编码和转义：**对所有不恶心的数据进行编码 （`<` 转换为 `<`，将 `>` 转换为 `>`），防止解释为 HTML 或者 JS
- **使用安全的库或框架：**React，Vue
- **内容安全策略（CSP）：**能够限制网页允许执行的内容来源，可以防止注入的脚本运行，限制脚本的来源，发送 `Content-Security-Policy` HTTP 头来配置 CSP，如``Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-scripts.com;``



## 14、项目中如何处理的跨域问题

在项目中通过在后端设置CORS，告知浏览器允许的跨域请求

包含：

- 允许来源：Access-Control-Allow-Origin 设置为请求头中的 Origin，即允许所有来源跨域访问。

- 允许的方法：Access-Control-Allow-Methods设置：POST, GET, OPTIONS, PUT, DELETE, UPDATE。

- 允许的请求头：Access-Control-Allow-Headers：如 Authorization、Content-Type、自定义的 Chat-Token、Admin-Authorization 等。

- 允许携带 Cookie：Access-Control-Allow-Credentials: true。



其他的处理跨域方式：

**JSONP**

- 原理: script标签的src不受到同源策略的限制。但是只能使用get请求。
- 后端返回一段js代码，代码的内容是一个前端定义好的函数的调用，把需要返回的内容传递进去。

**代理服务器**

**跨域是浏览器特有的，而服务器和服务器之间不存在跨域**。 前端请求同源服务器，同源服务器充当代理，转发请求至目标服务器，再将结果返回前端，就可实现跨域。

（如果问）可以用打包工具自带的服务器代理请求，解决跨域。也可以通过nginx配置一个代理服务器。

**WebSocket协议跨域**

WebSocket 是一种基于 TCP 协议的双向通信协议，它提供了一种浏览器和服务器之间实时、低延迟、高效率的全双工通信方式，同时允许跨域通讯。

浏览器在发送 WebSocket 请求时，会在请求头中携带 Origin 字段，用于告诉服务器该请求的来源。服务器在收到请求后，会根据 Origin 字段判断是否允许该跨域请求，如果允许，则在响应头中添加 Access-Control-Allow-Origin 字段，告诉浏览器该请求被允许访问。



# 项目

## **1、虚拟列表+懒加载**

### （1）简单介绍

在项目的全部房源页面中，会向用户展示目的城市的**海量房源**。如果一次性将这些房源全部渲染出来，可能会导致加载时间过长，房源dom元素过多导致页面卡顿等**性能问题**，所以考虑使用虚拟列表+懒加载实现。

一开始是单纯使用的懒加载，当用户滑动到**靠近列表底部**时，就重新向后端**请求新的数据**并**添加到列表**中再**重新渲染到页面**上。这样由于开始页面中的房源dom很少，所以能够大幅减少首屏加载时间。但如果用户一直向下滑，加到页面中的房源**dom会越来越多**，最后还是会降低性能，造成页面卡顿等等。

所以后来考虑使用虚拟列表+懒加载的方式，同样是接近列表底部请求，区别在于虚拟列表只渲染数据列表中**当前页面以及附近两页**的房源dom，不论列表中有多少数据，都只渲染**有限的一部分**，所以可以避免页面卡顿等性能问题。多渲染两页dom，可避免滑动过快还未渲染，出现白屏。

### （2）具体如何实现的虚拟列表

1、设置**开始索引**和**结束索引**，代表列表**开始渲染的位置**和**结束渲染的位置**。设置**预留两屏的item数**（容器可视高度除以item高度乘五（一行有五列）），然后通过**已划过距离scrollTop**除以单个房源item高度再乘五就是已划过的item数，再减去预留数，得到开始索引，默认是0（通过Math.max(0,上边的操作)）。通过已划过距离scrollTop加上可视区域高度offsetHeigh以单个房源item高度再乘五，再加上预留数，得到结束索引。

2、通过**slice截取到数据列表**中的从开始索引到结束从索引的部分，在页面中进行渲染。

3、还需要计算通过开始和结束索引计算**顶部块**和**底部块**（如果结束索引比列表还长就是0）的高度，用来**撑开进度条**

4、如果划到了靠近列表底部（总高度scrollHeight-已划过距离scrollTop-容器可视高度<距离阈值），就触发请求函数，重新向后端请求数据并加到列表后边

### （3）为什么使用节流函数，起到什么作用

滚轮滚动可能会触发多次滚动事件，造成不必要的性能消耗，快速滚动也可能造成白屏问题。所以考虑采用节流函数来减少滚动触发的次数。

一开始采用的是防抖函数，防抖函数的作用就是短时间内触发多次事件，只执行最后一次，可以有效减少滚动触发的次数。但是在实际操作时出现问题，如果快速滑动滑轮，会导致房源item未渲染出来，页面出现白屏。分析后发现是由于滚动时页面会向下划，但由于速度过快，未达到防抖函数要求的时间，所以防抖函数并未执行，页面未重新渲染，导致白屏问题。

随后改用节流函数，节流函数的作用是触发一次在短时间内就不再次触发，从而既有效减少了滚动触发的次数，由于每次都会成功执行节流函数，也实现了及时渲染，从而顺利解决了白屏问题。



### **（4）如何优化快速滚动时的白屏问题？**

**考察点**：性能优化经验
**解答**：

1. **节流渲染**：使用 **节流函数** 控制滚动事件触发频率。

2. **占位符**：图片未加载时用**骨架屏**填充，提高用户体验。

   骨架屏方案，通过isPending判断是否处于请求中，返回为pending就渲染骨架屏，请求结束就渲染请求到的图片

3. **加载符**：如果滑倒列表底部请求新数据还未返回，同样是通过pending来判断，渲染`加载中...`的盒子，请求结束就渲染新item

### （5）使用**Intersection Observer**

**Intersection Observer** 方案优势：

- 原生API，简化可视区域判断逻辑。
- 自动检测，减少手动计算误差。

**局限性**：

- 兼容性问题（部分旧浏览器不支持）。
- 大量元素监听时性能开销较大（需配合虚拟列表减少节点数量）。

**结论**：结合两者，用虚拟列表控制DOM数量，用Intersection Observer实现了图片懒加载细节。

### **（6） 如何处理动态高度的元素（如高度不固定的图片或文本）？**

**考察点**：复杂场景的解决方案
**解答**：
动态高度需实时测量并缓存，常用方案：

1. **预估高度+惰性测量**：初始用预估高度渲染，元素进入可视区域后测量实际高度，更新缓存并调整布局。
2. **位置缓存表**：维护一个 `positions` 数组记录每个元素的真实高度和偏移量，重新计算后续元素的位置。
3. **ResizeObserver API**：监听元素尺寸变化，动态更新缓存。

**优化**：对已测量的元素跳过重复计算，使用二分查找快速定位滚动位置。

### **（7）如果列表项包含复杂组件（如视频），需要注意什么？**

**考察点**：实际应用细节
**解答**：

1. **组件销毁**：离开可视区域时销毁视频播放器，释放内存。
2. **状态保存**：使用 `keep-alive` 或缓存组件状态（如播放进度）。
3. **懒加载分级**：先加载轻量内容（如缩略图），用户交互后再加载完整资源。
4. **性能监控**：确保单个复杂组件不影响整体滚动性能。

### **（8） 如何测试虚拟列表+懒加载的准确性和性能？**

**考察点**：质量保障意识
**解答**：
**准确性测试**：

- 快照比对：确保不同滚动位置渲染内容正确。
- 交叉验证：手动滚动到特定位置，检查渲染数据与预期一致。

**性能测试**：

- **Chrome DevTools**：通过Performance面板分析FPS、布局重绘（Layout Thrashing）。
- **内存占用**：Memory面板检查是否存在内存泄漏（如未销毁的DOM节点）。
- **大数据压测**：渲染10万条数据，监控滚动流畅度（FPS≥50）。

**自动化工具**：

- Puppeteer模拟滚动并截图对比。
- Lighthouse生成性能报告。

## 2、模糊查询 多条件精准查询 useActionState 排序 防抖函数

#### 简单介绍：

**（1）搜索功能**

在项目的全部房源页面中，有着搜索功能，可以在输入框中输入想要查询的字符串，点击搜索按钮后就可以匹配到标题中有相应字符串的房源渲染在页面上，这个过程通过模糊查询实现。在搜索框输入时还会有一个下拉菜单，可以根据输入值实时显示匹配到的前五条房源标题，也是应用到了模糊查询，同时还做了防抖处理，防止高频输入造成多次渲染的性能问题。

**（2）条件筛选功能**

在项目的全部房源页面中，有条件筛选功能，可以根据人数、价格、位置条件来筛选房源。通过多条件精准查询来实现这一功能。

### （1）模糊查询简单介绍

全部房源页面中有搜索功能，可以匹配并渲染出标题中有搜索字符串的房源item。搜索功能主要应用到了模糊查询。模糊查询的基本原理是对房源数据列表通过filter进行遍历，对每个遍历到的item取标题，通过includes判断标题中有没有要搜索的字符串，有返回的就是true，item添加到filter得到的新数组里边。搜索时还具有搜索建议功能，使用onChange根据表单的输入值，通过下拉菜单实时展示出通过模糊搜索匹配到前五条的房源标题。

### （2）多条件精准查询简单介绍

全部房源中页面中有筛选功能，可以按照人数，价格，位置条件对房源item进行筛选。条件筛选功能应用到了多条件精准查询，基本原理也是对房源数据列表通过filter进行遍历，对每个遍历到的item取到人数，价格，位置这些属性，与条件进行比较，再对比较结果进行短路判断，如果都返回true的才返回到filter新数组内（短路判断时将高淘汰率的条件（如位置）放在判断逻辑前端，快速跳过不符合项）。

### **（3）useActionState**的尝试使用

在全部房源页面的代码中，存在搜索框、人数、价格、位置等多个表单元素，需要通过**useState**设置**多个状态变量**来保存并操作这些表单的内容，比较繁琐。之后了解到react19新api `useActionState`的更新，可以更好地**控制表单的action状态**，无需多个状态变量，于是尝试使用在了项目内。

`const [state, action, isPending] = useActionState(fn, null)`

`useActionState`有两个参数，第一个是**处理表单提交内容的回调函数**，第二个是初始值。回调函数由两个参数**prevData**（之前的表单数据）和**formData**（现在的表单数据）。可以得到通过formData参数得到各个表单的内容，通过**formData.get('表单名')**就能得到相应表单的内容。在项目中我先得到各个表单的内容，再**传入筛选函数**（通过filter进行模糊查询和精准查询的函数），最终筛选后的数组**返回出去**。

`useActionState`有三个返回值，第一个返回值是执行回调函数后**返回的状态**，在项目中就是返回的**筛选后的新数组**。第二个就是返回值action函数，react19更新后form的action属性可以**绑定要执行的action函数**，绑定后表单就可以执行相应的函数（相当于给之前的onSubmit加上以后个handle什么什么)。第三个返回值是判断表单提交**状态的isPending**，为做到在action函数**执行时无法再次提交**，通过isPending判断**button按钮是否禁用**（添加disabled属性），如果函数中有异步网络请求，这个功能更加有用。

这几个表单元素都是提交后获得的，所以使用useActionState。

### （4）排序的实现

通过一个状态变量来保存是通过价格还是评分进行排序。然后向后端发送请求，过程中设置isPending状态变量处理请求状态，请求状态中渲染一个蒙层到页面上。不使用useActionState是因为希望一改变状态变量就请求，而useActionState是提交后才执行，所以不使用。

### （5）防抖函数

在搜索框输入时，会展示一个搜索建议的下拉表单，包含前五条根据当前搜索字符串匹配到的房源item的标题，通过onChange获取搜索字符串。为解决高频输入时的性能问题，通过防抖对函数进行包裹，只在最后一次触发后才执行，解决了问题。



### 问题1：为什么不通过后端实现

这个项目是和实验室后端的同学一同配合实现的，做到搜索和筛选功能呢时后端的同学已经出去实习了，没时间再做搜索和筛选的接口，所以退而求其次选择从前端实现。当然从后端实现肯定是更完美的方案，因为项目使用的是懒加载，所以数据列表中只有已经请求到的房源数据。将搜索字符串和条件都传到后端，再由后端从全部房源数据中进行筛选，肯定是更合适的。

### 问题2：**多条件筛选采用`filter`链式遍历，如何保证多条件组合查询的效率？**

1. **短路判断**：将高淘汰率的条件（如位置）放在判断逻辑前端，快速跳过不符合项
2. **条件变化监听**：仅当筛选条件变化时重新计算，避免重复执行。具体实现是通过回调函数的第一个参数prevData可以保存上一次的表单提交的内容，与本次进行对比，如果相同就直接返回上一次过滤后的数据即可。

### 问题3：**搜索建议如何实现？**

在输入框输入时，会触发搜索框的onChange事件，给事件绑定上了函数来设置状态变量并调用模糊查询，将前五条匹配到的房源标题渲染到下拉菜单里边。这个过程中使用了防抖函数来控制快速输入的情况。（不使用useActionState是因为不是提交而是实时改变，所以要用onChange）

### 问题4：**如何处理用户输入的特殊字符或SQL注入风险？**

1. **前端过滤**：对搜索输入进行清理（如移除`<script>`标签）

```
const cleanInput = input.replace(/[<>]/g, '') 
```

**2.使用CSP **

CSP 通过设置HTTP 响应头，**限制浏览器只能加载指定来源的资源**，从而防御 XSS 攻击和数据注入。主要防护能力包括：

- 阻止未经允许的内联脚本（`<script>`标签）
- 禁止加载外域恶意脚本
- 阻止未授权的资源加载（图片、字体等）
- 禁用危险的 `eval()` 等函数

### 问题5：如何控制下拉菜单的显隐

设置一个状态变量来控制，当光标位于搜索框时（通过onFocus）设置为true，点击到搜索框外部时（通过e.target.closest('盒子类名')得到点击的是哪个盒子）就设置为false，通过短路逻辑判断是否显示。

### 问题6：如果一个item里有多种类型房间怎么办

1、通过useSelector获取到数据列表

2、对数据列表进行map遍历，并对每个item通过filter对房间进行筛选，获得返回符合条件的房间的数组，并重新设置item对象，修改房间属性为新数组。

3、对数据列表进行一次filter遍历，将不符合条件的酒店item过滤出去（item.rooms.length需要大于0），并将过滤后的数据列表保存到redux中。

4、点击房源item时，通过过滤后的数据列表将房间信息传进去，保证只有符合条件的房间。

## 3、防抖与节流

### 一、防抖（Debounce）

- **防抖**：在事件被频繁触发时，只在 **最后一次触发** 后经过指定的等待时间才执行一次回调。依靠这个机制可以有效避免高频调用事件造成性能问题
- **常见场景**：输入框实时搜索、窗口 改变大小等。

------

实现防抖简单来讲就是将原函数进行包装，设置一个变量来存储定时器，并返回一个闭包函数，闭包函数里边里边是包着原函数的定时器以及判断逻辑。监听事件触发后会调用这个闭包函数，需要根据变量判断上一次的定时器是否还存在，如果依然存在就清除掉并给变量设置新的定时器。如果某一次达到事件间隔事件未被触发，定时器没有被清除，就执行定时器中的原函数。

- 如果问起怎么执行原函数：**注意 `this` 绑定**：如果原函数使用到了this，例如依赖对象的方法内的 `this.xxx`，为了保持原函数的调用上下文，我们使用 `fn.apply(this, args)`，同时能够实现立即执行。
- args指的是剩余参数，调用防抖函数时会传入参数，`args` 的作用就是**收集并传递**防抖函数被调用时的所有参数，保证原函数 `fn` 能拿到它们。

完整代码：

```js
function debounce(fn, delay) {
  let timerId = null;
  
  return function(...args) {
    // 如果已有定时器，先清除
    if (timerId) {
      clearTimeout(timerId);
    }
    
    // 设置新的定时器
    timerId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

```



------

### 二、节流（Throttle）

#### **核心思想**

**固定时间间隔内只允许函数执行一次**。无论事件触发多频繁，执行频率都会被严格控制。

**实现思路**：**时间戳版**：每次触发时，用当前时间减去上次执行时间，若超过间隔则执行。

​		**定时器版**：第一次触发立即执行，然后在定时器运行期间屏蔽后续触发；定时器到期后才允许再执行。

**实现步骤**：时间戳版：1、在节流函数中初始化状态变量， 记录上一次函数执行的时间戳

​					2、**返回闭包函数**，用于替代原函数绑定到事件上。该包装函数内部可访问并更新上面声明的状态变量。

​					3、在**包装函数内部实现核心逻辑**，先通过Date.now()获取当前时间戳；然后判断 当前时间戳减去上一次时间戳是否大于要求的事件间隔。若满足则执行原函数并更新上一次时间戳为当前时间戳。

‘定时器版：1、在节流函数中初始化状态变量， 记录上一次函数执行的定时器

​		    2、**返回闭包函数**，用于替代原函数绑定到事件上。该包装函数内部可访问并更新上面声明的状态变量。

​		    3、**在包装函数内部实现核心逻辑**，如果状态变量有定时器，代表还没有达到时间间隔，直接 `return`（忽略本次触发）。如果没有，就代表已经达到时间间隔，执行原函数，并给状态变量设置新的定时器。

**使用场景**：页面滚动scroll事件控制，拖拽事件等

#### **代码实现（时间戳版）**

```js
function throttle(func, interval) {
  let lastExecTime = 0; // 闭包保存上次执行时间
  return function(...args) {
    const now = Date.now();
    if (now - lastExecTime >= interval) { // 时间间隔外触发则执行
      func.apply(this, args);
      lastExecTime = now; // 更新时间戳
    }
  };
}
```



## 4、PictureBrowser组件

### 简单介绍：

在房源的详情页面中，封装了一个PictureBrowser这么一个图片浏览器组件来帮助用户更好地浏览房源图片。点击**显示更多照片**后，就可以进入到图片浏览器。右上角是一个**叉号**，点击就可关闭图片浏览器。图片浏览器**中央是一张房源图片**，**左右两边是箭头**，点击箭头图片就会**向前或向后切换一张**。切换时通过**第三方库 react-transition-group**对图片**传入传出动画效果**进行优化。图片下方是**indicator图片指示器**，按顺序展示当前图片与附近的六张图片（一共七张，都是略缩图），其他图片都用阴影覆盖。点击箭头后，图片指示器也**跟着切换图片**。当前图片位于房源图片列表**首或尾**时，图片指示器**按照顺序切换位置**，位于图片列表**中间**时，切换的图片**始终位于图片指示器中间**。而**点击图片指示器**中的图片，中央展示的图片就**切换到相应图片**，图片指示器的切换遵循之前同样的逻辑。由于逻辑较复杂，所以又封装了一个indicator组件来实现这一功能。图片浏览器中还有一个选择指示器显示与否的按钮。以上就是图片浏览器的大致功能。

### 问题1：如何通过react-transition-group优化动画效果

1、通过状态变量保存点击的是左箭头还是右箭头，点击箭头就会触发函数进行设置，并将新图片重新渲染上去

2、通过react-transition-group中的CSSTransition组件将图片包裹，设置单一盒子的动画效果。

内部属性：in来控制动画触发与否，key确保多个组件切换时都有唯一标识，classNames设置类名，timeout设置动画时长

动画的样式：根据CSSTransition属性确定的类名决定，直接在`类名-enter/类名-exit`设置开始动画效果，`类名-enter-active/类名-exit-active`设置结束的动画效果，结束样式中要包括transition设置过程，如transition: all 200ms ease，代表动画效果200ms，先慢后快后慢。

3、使用SwitchTransition标签处理两个组件之间切换的过程。通过mode属性来控制切换方式，"out-in": 当前组件先退出，新的组件再进入。"in-out": 新的组件先进入，当前组件再退出。子组件必须使用 CSSTransition 或 Transition，并确保 key 属性唯一。

### 问题2：React Transition Group（RTG）相比原生 CSS 或 JavaScript 动画方法，在 React 生态中有以下核心优势：

------

#### 1. **组件化生命周期管理**

RTG 提供 `Transition`、`CSSTransition`、`SwitchTransition` 等组件，**无缝集成 React 的生命周期**。

- 自动处理组件挂载（mount）和卸载（unmount）的时序问题。
- 原生方法需要手动用 `setTimeout` 或 `useEffect` 控制 DOM 元素的移除时机，容易导致动画未完成元素就被销毁的问题。

------

#### 2. **解决组件卸载动画难题**

原生 CSS 无法直接处理组件卸载时的动画（如元素消失的 `exit` 动画），因为 React 会立即移除 DOM 节点。

- RTG 通过**保留 DOM 节点直到动画完成**（如 `exiting` 状态结束后），确保退出动画能完整播放。

------

#### 3. **声明式 API 与状态驱动**

通过 `in` 属性控制动画状态（进入/退出），**状态变化自动触发动画流程**。

- 原生方法需要手动添加/移除 CSS 类或操作 DOM，代码冗余且易出错。
- 示例：通过 `in={isVisible}` 即可触发元素的进入/退出动画流程。

------

#### 4. **跨动画库兼容性**

RTG **不依赖具体动画实现**，可自由搭配 CSS、GSAP、Anime.js 或 React Spring。

- 原生 CSS 动画需硬编码 `@keyframes` 或类名，灵活性低。
- 示例：用 `CSSTransition` 直接绑定 CSS 类名，或用 `Transition` 结合 JS 动画库。

------

#### 5. **复杂场景简化**

- **路由切换动画**：通过 `SwitchTransition` 实现组件切换时的平滑过渡。
- **列表动画**：结合 `TransitionGroup` 管理动态列表项的增删动画，避免手动跟踪每个元素的 key 和状态。

### 问题3：**Indicator 的滚动策略如何实现**

滚动策略的核心是 **视口居中算法**

1、所有图片都放在一个盒子的内容中，盒子展示区宽度固定，改变的其实是盒子内容的位置，默认图片从第一个开始，盒子所以在最右边。

2、图片切换后，得到新图片的索引，从而获取到图片对应的宽度clientWidth和离左侧父盒子边缘距离offsetLeft。

3、获取到盒子显示区的长度和内容长度，通过**左侧距离+盒子本身宽度*0.5-显示宽度**计算出距离，得到要盒子要移动到的位置，从而使得当前图片居中

4、如果位于头部，计算出距离会小于零，这种情况就不移动盒子。同理如果位于尾部，计算出距离会超过盒子内容宽度，同样也不移动盒子

## 5、前端优化方法

### 1、路由懒加载

**传统问题**：所有路由组件打包到单一JS文件，导致首屏加载缓慢，

**作用**：通过路由懒加载将应用拆分为按路由分割的代码块，初始仅加载核心框架，仅在用户导航到对应路由时才会加载相应资源，可以减少初始加载体积，大幅提高首屏加载速度。

**如何使用**：在react中，通过lazy实现懒加载。用Lazy将一个导入组件的箭头函数包裹起来，用Suspense组件来处理路由导入过程中的加载过程，如果请求状态是pending就通过fallback属性来渲染加载过程中显示的内容，在我的项目中是在路由切换过程中显示一个白色透明蒙层。

**底层原理**：实现路由懒加载的底层原理主要依赖于**代码分割**与**动态加载**技术，其核心思路是把整个应用拆分为多个独立的代码块（chunk），只有在用户真正访问某个路由时才加载对应的代码，从而减小初始加载包的体积，加快首屏渲染速度。下面是具体的原理和步骤：

1. **代码分割**
    使用打包工具（如 Webpack、Rollup 等）将应用按路由或功能模块拆分成多个独立的代码块。这样每个路由对应的组件和依赖会被打包到单独的文件中。
2. **动态导入（Dynamic Import）**
    利用 JavaScript 的 `import()` 函数实现动态加载。例如，当用户导航到某个路由时，路由配置中会触发动态导入操作，返回一个 Promise，等待模块加载完成后再进行渲染。
3. **缓存机制**
    一旦动态加载成功，对应的代码块会被缓存（通常浏览器层面已经缓存该文件），避免重复请求，提高用户体验。

### 2、图片懒加载

**简单介绍**：

在全部房源页面里，存在大量带图片的房源item，如果直接加载所有图片，肯定会造成性能问题，给用户带来较差体验，所以采用图片懒加载的方式。

**实现过程**：

房源 Item 组件中，整体房源信息（如标题、价格和加入购物车按钮）直接渲染，而房源图片则交由 LazyImage 组件处理，从而实现按需加载图片，提高页面加载效率。

LazyImage 组件内部使用了 React 的 **hooks**（useState、useEffect 和 useRef）来管理**图片加载状态**。组件首先通过 **useRef** 获取图片 **DOM 元素**，并用 useState 管理图片**是否加载完成（isLoaded）**和图片**是否加载失败**（**hasError**）的状态。核心部分是利用 **Intersection Observer** API 监听图片元素是否**进入视口**。开始时为所有图片元素加上观察，当检测到图片元素的**可见度超过设定的阈值**（threshold 0.1）时（即进入视口），就会将图片的datasrc中的图片地址赋值到src中，从而加载图片，并结束观察。如果图片加载成功，触发img元素onLoaded事件，更新加载状态为true，让真正的图片得以显示；如果加载失败，则触犯onError事件，将错误状态置为 true，并展示相应的错误提示。

在图片加载未完成的期间，组件使用 **antd** 的 Skeleton.Image 显示**骨架屏**，作为占位效果，以提升用户体验。只有当图片加载成功时，真实的图片才会被展示，并且通过 CSS 样式设置为覆盖整个容器，同时保证了图片自适应布局。通过这种设计，不仅有效地降低了页面初始加载的压力，也能在加载过程中提供良好的视觉反馈和错误处理。

#### 使用**Intersection Observer** 的好处是什么？

- **作用**：监听目标元素与父容器（或视口）的**交叉状态变化**（如元素进入/离开视口）。
- **优势**：
  - **高性能**：异步回调，**避免频繁触发** `scroll` 事件。
  - **灵活**：可配置触发交叉的**阈值**（threshold），触发的**范围**和监听的根容器。
  - **自动管理**：**无需手动计算元素位置**。

**对比传统方案**

| **场景**         | **传统方案（scroll + getBoundingClientRect）** | **Intersection Observer**  |
| :--------------- | :--------------------------------------------- | :------------------------- |
| **性能影响**     | 频繁触发强制布局，导致性能抖动                 | 无强制布局，异步批量处理   |
| **代码复杂度**   | 需手动管理监听、防抖、计算逻辑                 | 声明式 API，自动管理       |
| **精确度**       | 依赖手动计算，可能误差                         | 浏览器原生计算，精确到像素 |
| **动态内容支持** | 需手动跟踪新增元素                             | 自动观察新注册元素         |

#### Intersection Observer的底层原理是什么？

Intersection Observer 的底层原理主要依赖于浏览器的渲染与布局机制，通过异步检测目标元素与观察容器（通常是视口）之间的交叉情况来工作。当页面发生滚动、窗口尺寸变化或其他布局更新时，浏览器会重新计算各个目标元素与根容器之间的交叉区域，然后将这些计算结果与预先设定的阈值进行比较。当某个目标元素的交叉比例超过（或低于）阈值时，浏览器就会生成对应的 IntersectionObserverEntry 对象，并异步调用注册的回调函数。

这种机制的好处在于，浏览器可以批量处理多元素的可见性变化，从而避免频繁监听滚动事件带来的性能问题，实现高效、低开销的可见性检测。

### 3、react.memo

**React.memo 的好处**
`React.memo` 是 React 提供的高阶组件（HOC），主要用于优化函数组件的渲染性能。它的核心优势是可以**避免不必要的重新渲染**

当父组件更新时，即使子组件的 `props` 未变化，默认情况下子组件也会重新渲染。使用 `React.memo` 后，子组件会**浅层比较新旧 `props`**，仅当 `props` 变化时才会重新渲染。

如果`props`是一个对象，即使内容一样，但由于每次传过来的都是一个新对象，引用不同，子组件也会重新渲染。解决方法就是给memo添加一个shallowEqual，这样如果引用不同，会再对内部属性方法进行比较，如果相同就不用重新渲染

### 4、虚拟列表+懒加载

在上边

### 5、防抖与节流

在上边



## 6、axios二次封装

#### 为什么要对axios进行二次封装？

对 Axios 的二次封装主要是为了**统一管理网络请求逻辑**，通过拦截器**全局处理错误提示**、**Token 鉴权**、**处理参数格式**等，减少重复代码；同时规范数据响应结构（如自动提取嵌套数据），**简化api（如get，post）调用方式**（如统一设置参数，统一返回 `[err, data]` 格式），并支持扩展缓存、重试等定制功能，最终提升代码复用性、维护性及项目协作效率。

#### 项目中进行了哪些封装？

创建一个axios示例，将基础路由和请求超时时间抽离出来，如果以后要修改方便修改。

**1、对get和post这些api进行了封装**

以get为例，封装了一个新的get函数来获取各项房源数据，里边调用axios.get(url, params)方法，参数是请求路径url和和要查询的查询参数params。在then中处理请求结果，通过res.data获取到数据。获取成功就用resolve返回数据。请求失败通过catch接到，用rejected返回一个error。

post情况也类似，调用axios.post方法，传入请求数据与URL，在then中处理数据并返回，在catch中处理错误并返回

**2、对请求拦截器进行了封装**

在第一个项目中，只是封装了一些公共请求头。在第二个项目中，存在登录功能，所以在请求拦截器中通过getItem获取用户的token ，如果有token就设置到请求头的Authorization。请求拦截器是通过`axios.interceptors.request.use`，对config赋值实现。

**3、对响应拦截器进行了封装**

在第一个项目中，没有登录功能，所以仅通过响应拦截器封装了处理网络请求错误显示的错误信息，如400是'错误的请求'，404是'请求错误,未找到该资源'，500是'服务器端出错'，502是网络错误。并通过message(error)弹出错误信息。在第二个项目中封装了对用户token过期或失效进行处理，当返回结果为401时说明token过期或失效，重新刷新token（通过存储的有更长有效期的refreshToken，将其post到服务器端，正常情况下会返回新token）。如果成功获取新token就使用新token重新请求，如果还是失败就弹出错误信息、清除token并跳转至登录页面。

4、对各个接口进行进一步封装，调用上边的get函数，将请求的url传进去，在外部使用相应数据请求时直接调用即可。



## 7、登录与注册的实现

项目2中登录通过token方式实现。

通过状态变量设置显示登录还是注册

**注册的实现**：首先设计了注册的用户名，密码与重复输入密码的表单。点击注册按钮后先进行前端检查，如果密码符合规则且两次输入密码相同，就触发注册请求，将用户名和密码通过post传进去，返回一个响应，如果成功调用就登录函数，失败就弹出注册失败。

**登录的实现**：

1、首先在设计了登录的用户名和密码表单，点击登录按钮会触发登录请求，将用户名和密码传进去，如果登录成功就把用户名放到redux中存起来，并跳转到首页，失败就弹出登录失败。

2、触发登录请求，会通过post方法将用户名和密码传到服务器，如果成功就获取响应中的token和refreshToken放到localStorage中存起来（通过setItem）,并返回一个true。失败就返回一个false

3、在请求拦截器中，会将token放进请求头Authorization中。在响应拦截器中，会对响应结果进行处理，如果token过期或失效就通过refreshToken重新获取一个新token存起来，通过新token重新进行请求。如果还是失败就弹出错误信息，清除token并跳转至登录页面。

4、首页中设置了登出按钮，点击后就可以触发登出函数，清除token并跳转至登录页面。

5、通过设置一个高阶组件来实现路由守卫，在高阶组件中对token的有效性和是否过期进行验证（通过jwtDecode对token进行解析），如果验证通过就跳转到响应的页面，如果不通过就回到登录页面。通过状态变量来保存用户token，并通过context传递。

### 问题1：都有哪些登录方式，都有什么特点和优势？

#### 一、**Session-Cookie 认证**

#### **原理**

- 服务端生成会话（Session）并存储（如内存、数据库、Redis），客户端通过 Cookie 保存 Session ID。
- **流程**：
  1. 用户提交用户名密码。
  2. 服务端验证后生成 Session 并返回 Session ID。
  3. 客户端通过 Cookie 存储 Session ID。
  4. 后续请求自动携带 Cookie，服务端校验 Session ID。

#### **特点**

- **优点**：
  - 简单易实现，适合传统 Web 应用。
  - 服务端可主动控制会话（如强制退出、实时更新权限）。
- **缺点**：
  - 服务端需存储会话数据，扩展性差（分布式场景需共享 Session）。
  - 依赖 Cookie，跨域场景需额外配置。

#### **适用场景**

- 传统服务端渲染的 Web 应用（如 PHP、Ruby on Rails）。

------

#### 二、**OAuth 2.0 / 第三方登录**

#### **原理**

- 用户通过第三方平台（如微信、Google、GitHub）授权登录。
- **流程**：
  1. 前端跳转至第三方登录页面。
  2. 用户授权后，第三方返回授权码（Code）。
  3. 前端将 Code 传给后端，后端换取用户信息。
  4. 后端生成自有 Token 或 Session 返回前端。

#### **特点**

- **优点**：
  - 用户无需注册新账号，提升转化率。
  - 依赖第三方平台的用户体系，减少密码管理成本。
- **缺点**：
  - 实现复杂，需处理多种第三方协议。
  - 依赖第三方服务稳定性。

#### **适用场景**

- 需要快速接入第三方账号登录的应用（如社交平台、工具类应用）

### 问题2：token方式的优势和缺点是什么？

**三、Token 认证的优势**

| 优势               | 说明                                                        |
| :----------------- | :---------------------------------------------------------- |
| **无状态**         | 服务端无需存储会话信息，适合微服务、分布式架构。            |
| **跨域支持**       | 可轻松实现跨域认证（CORS），适合前后端分离项目。            |
| **多端兼容**       | 适用于 Web、移动端（App）、IoT 设备等多种客户端。           |
| **灵活的权限控制** | Token 可携带用户角色、权限信息，实现细粒度访问控制。        |
| **易于扩展**       | 可通过添加自定义字段（如设备 ID、Token 版本）支持复杂场景。 |

------

**四、Token** **认证的缺点与挑战**

| 缺点               | 解决方案                                                     |
| :----------------- | :----------------------------------------------------------- |
| **Token 泄露风险** | 使用 HTTPS、短期 Token、Refresh Token 轮换、绑定 IP/设备信息。 |
| **无法主动失效**   | 使用 Token 黑名单、短期有效期 + 刷新机制、或改用不透明 Token。 |
| **存储安全性**     | 优先使用 `HttpOnly Cookie`，避免 LocalStorage（防 XSS）。    |
| **Token 膨胀**     | 避免在 Token 中存储过多数据，敏感信息由服务端动态查询。      |

### **问题三**：Token 认证 vs Session-Cookie 认证

| 对比项           | Token 认证                     | Session-Cookie 认证         |
| :--------------- | :----------------------------- | :-------------------------- |
| **状态管理**     | 无状态，适合分布式系统         | 有状态，服务端存储 Session  |
| **跨域支持**     | 天然支持（通过 Header 传递）   | 需配置 CORS 和 Cookie 域    |
| **移动端友好性** | 更友好（无需处理 Cookie）      | 需处理 Cookie               |
| **注销机制**     | 依赖黑名单或短期 Token         | 服务端直接删除 Session 即可 |
| **适用场景**     | 前后端分离、API 优先、多端应用 | 传统服务端渲染 Web 应用     |

### **问题4：前端该用 LocalStorage 还是 Cookie 存 Token？**

- **优点：**
  - 存储容量较大，适合存放较多或较大的数据。
  - 操作简单，通过 JavaScript API 直接读写，不需要每次请求都自动携带，便于在客户端灵活控制。
- **缺点：**
  - 数据完全暴露给前端脚本，无法设置 HttpOnly，容易受到 XSS 攻击。
  - 需要手动将 token 附加到 HTTP 请求头中，增加了实现复杂度。
  - 数据不会自动随请求发送，跨域时需额外处理。

**Cookie 存储 Token**

- **优点：**
  - 浏览器会自动在每个请求中附带 Cookie，便于服务器端识别用户会话。
  - 可以设置 HttpOnly 属性，防止 JavaScript 访问，从而降低 XSS 风险。
  - 配置 SameSite 和 Secure 属性后，可在一定程度上防范 CSRF 等攻击。
- **缺点：**
  - 存储容量有限（通常约 4KB），不适合存放大量数据。
  - 自动随请求发送，可能会带来不必要的流量开销。
  - 如果配置不当（例如未设置 SameSite 或 Secure），依然存在安全隐患。

## 8、style-components

**1、简单介绍**

styled-components 是一种流行的 CSS-in-JS 库，主要用于 React 应用中。它通过使用 ES6 的模板字符串（tagged template literals）让开发者可以在 JavaScript 文件中直接编写 CSS，然后将这些样式与具体的 React 组件绑定，从而达到组件化、模块化的样式管理效果。

**主要特点**

- **样式与组件紧密耦合**：样式定义在组件内，使得样式的作用域自动被限定在组件内，避免了全局样式冲突。
- **动态样式支持**：可以根据组件的 props 或 state 动态生成样式，满足复杂场景的需求。
- **主题支持**：提供 ThemeProvider，可以轻松实现全局主题切换，统一管理应用风格。
- **易于维护**：由于样式和逻辑在同一文件中管理，组件的可读性和可维护性较高。

**优点与适用场景**

- **提高复用性与封装性**：每个组件自带样式，方便复用和迁移。
- **简化开发流程**：不用再维护单独的 CSS 文件，减少样式冲突问题。
- **适用于大型 React 应用**：当应用组件化程度高时，styled-components 能够更好地管理复杂的样式体系。

### 1、通过参数实现动态样式

styled-components 利用 ES6 模板字符串的特性，可以在样式中嵌入 JavaScript 表达式。这样，你就可以根据组件的 props 动态计算出对应的 CSS 属性值。

**实现方式：**

- **插值**
   在模板字符串中使用插值，接收组件的 props 作为参数，然后返回一个 CSS 值，要以一个$开头。
   例如，根据一个 `primary` 属性来设置按钮的背景色，通过props.primary 判断那种样式：

  ```js
  import styled from 'styled-components';
  
  const Button = styled.button`
    background-color: ${props => props.primary ? 'blue' : 'gray'};
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
  `;
  ```

  在使用时，只需给组件传递相应的 props，如这里传primary：

  ```js
  <Button primary>主按钮</Button>
  <Button>普通按钮</Button>
  ```

  ### 2、整体将参数插入样式

  通过ThemeProvider将一个主题对象注入到整个组件树中。所有使用 styled-components 定义的组件都可以通过 `props.theme` 访问到这个主题对象，从而实现全局主题的统一管理和动态切换。

  **定义主题对象**
   首先定义一个包含全局样式变量（如颜色、字体、间距等）的主题对象：

  ```js
  // theme.js
  export const theme = {
    primaryColor: 'blue',
    secondaryColor: 'gray',
    fontSize: '16px',
  };
  ```

  **使用 ThemeProvider 包裹组件树**
   在应用的根组件中使用 `ThemeProvider` 将主题对象传递下去：

  ```js
  import React from 'react';
  import { ThemeProvider } from 'styled-components';
  import { theme } from './theme';
  import App from './App';
  
  const Root = () => (
    <ThemeProvider theme={theme}>
      <App />
    </ThemeProvider>
  );
  
  export default Root;
  ```

  **在 styled-components 中使用主题变量**
   组件中可以通过 `props.theme` 直接访问主题变量：

  ```js
  const Title = styled.h1`
    color: ${props => props.theme.primaryColor};
    font-size: ${props => props.theme.fontSize};
  `;
  ```

### 3、混入 Mixin 功能

**实现方式：**
 styled-components 通过内置的 `css` 辅助函数来实现 mixin。你可以把常用的样式封装成一个可重用的样式块，然后在多个组件中引入。这样可以避免样式代码重复，提高可维护性。

## 9、redux-toolkit

### 什么是 Redux？它的主要特点是什么？

**Redux** 是一个用于管理应用状态的 JavaScript 库，通常与 React 一起使用。它提供了一种集中管理应用状态的方式，使得状态管理更加可预测和可维护。

**主要特点**：

- **单一数据源**：整个应用的状态存储在一个单一的 store 中，确保了状态的一致性。
- **状态不可变**：状态是不可变的，每次状态变化时，都会生成一个新的状态对象。
- **reducer**：通过reducer来处理状态变化，使得状态变化可预测。
- **中间件支持**：支持中间件，可以扩展 Redux 的功能，如异步操作、日志记录等。
- **开发者工具**：提供了强大的开发者工具，可以调试、回溯和重放状态变化。

### **一、为什么需要 Redux Toolkit？**

#### **传统 Redux 的痛点**

1. **繁琐的样板代码**：需手动编写 action types、action creators、reducers。
2. **配置复杂**：需自行集成中间件（如 Thunk、Logger）、DevTools。
3. **不可变更新易错**：手动使用 `...` 或 `Object.assign` 更新状态，容易出错。
4. **异步处理麻烦**：需依赖额外库（如 Redux-Saga、Redux-Observable）。

#### **Redux Toolkit 的优势**

- **简化代码**：内置 `createSlice` 自动生成 action 和 reducer。
- **开箱即用**：预置 `@reduxjs/toolkit` 包含 Immer、Thunk、DevTools。
- **类型安全**：完美支持 TypeScript。
- **高效开发**：减少 80% 的 Redux 代码量。

### **二、核心 API 与功能**

#### **1. `configureStore`：创建 Store**

替代 `createStore`，自动集成 Thunk、DevTools 和中间件。

```js
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './reducers';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
  devTools: process.env.NODE_ENV !== 'production'
});
```

#### **2. `createSlice`：定义 Slice**

自动生成 action types 和 action creators，简化 reducer 编写。

```js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: 0,
  reducers: {
    increment: (state) => state + 1,
    decrement: (state) => state - 1,
    addBy: (state, action) => state + action.payload
  }
});

export const { increment, decrement, addBy } = counterSlice.actions;
export default counterSlice.reducer;
```

#### **3. `createAsyncThunk`：处理异步操作**

简化异步逻辑（如 API 请求），自动生成 pending/fulfilled/rejected 状态。

```js
import { createAsyncThunk } from '@reduxjs/toolkit';
import api from './api';

export const fetchUser = createAsyncThunk(
  'user/fetchUser',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await api.get(`/users/${userId}`);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);
```

#### 4、**集成 React**

使用 `Provider` 包裹应用，并通过 `useSelector`/`useDispatch` 访问状态。

```js
// store.ts
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// App.tsx
import { Provider } from 'react-redux';
import { store } from './app/store';

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}

// Counter.tsx
import { useDispatch, useSelector } from 'react-redux';
import { increment } from './counterSlice';
import type { RootState } from '../app/store';

function Counter() {
  const count = useSelector((state: RootState) => state.counter);
  const dispatch = useDispatch();

  return (
    <button onClick={() => dispatch(increment())}>Count: {count}</button>
  );
}
```

#### **5、`useDispatch`：派发 Action**

**作用**

**获取 Redux Store 的 `dispatch` 函数**，用于触发 Action 以更新 Store 中的状态。

**使用场景**

当组件需要触发状态变更时（如用户点击按钮、提交表单、发起异步请求等）。

**代码示例**

```js
import { useDispatch } from 'react-redux';
import { increment } from './counterSlice'; // 导入 Action Creator

function CounterButton() {
  const dispatch = useDispatch();

  return (
    <button onClick={() => dispatch(increment())}>
      Increment Counter
    </button>
  );
}
```

**关键特性**

1. **直接派发 Action**：
   可以派发同步 Action（如 `dispatch(increment())`）或异步 Action（如 `dispatch(fetchData())`）。
2. **无需手动订阅 Store**：
   React-Redux 自动处理与 Store 的连接。

------

#### **6、`useSelector`：获取 Store 状态**

**作用**

**从 Redux Store 中提取需要的状态值**，并订阅该状态的更新。当状态变化时，组件会自动重新渲染。

**使用场景**

当组件需要读取 Store 中的状态时（如显示计数器值、用户信息等）。

**代码示例**

```js
import { useSelector } from 'react-redux';

function CounterDisplay() {
  const count = useSelector((state) => state.counter.value);

  return <div>Current Count: {count}</div>;
}
```

**关键特性**

1. **选择器函数**：
   接受一个函数 `(state) => selectedValue`，返回需要的状态片段。
2. ****严格相等****：
   默认使用严格相等（`===`）比较前后状态值。**如果返回值是对象或数组，需确保引用稳定**，否则会导致不必要的重新渲染。
3. **性能优化**：
   - **使用记忆化选择器**（如 `createSelector`）避免重复计算。
   - **按需提取状态**：避免返回整个 Store 的根状态。

**`shallowEqual` 的作用**

- **默认行为问题**：
  `useSelector` 默认使用 `===` 比较前后两次选择器返回的值。如果返回的是新对象（如 `{ a: 1, b: 2 }`），即使内容相同，引用不同也会触发重新渲染。
- **`shallowEqual` 的优化**：
  比较对象或数组的第一层属性/元素的值，若所有值相同，则判定为“未变化”，跳过重新渲染。

如果对reducer状态值有计算，可以使用**`createSelector`** 

**createSelector作用**

- **缓存输入和输出**：记录上一次的输入参数和计算结果。
- **参数未变化时直接返回缓存结果**：跳过重复计算。
- **参数变化时重新计算**：更新缓存。

## 10、react的模块化与组件化

React 的 **模块化** 通过拆分代码逻辑（如工具函数、API 服务）实现功能复用和高效维护，而 **组件化** 将界面拆分为独立、可复用的 UI 单元（如按钮、表单），通过状态隔离和组合模式提升开发效率。二者结合形成了高内聚低耦合的架构，优势在于**逻辑复用性高**（如自定义 Hook）、**协作便捷**（并行开发）、**维护性强**（修改独立模块不影响整体），同时支持动态加载优化性能，适用于从简单页面到复杂应用的灵活构建，是 React 高效开发的核心设计理念。

## 11、数据路由

##### 一、核心 API 作用

1. **`createBrowserRouter`**
   创建一个基于 HTML5 History API 的路由实例，支持数据加载、路由嵌套等特性。
   - 参数：路由配置数组（定义路径、组件、数据加载逻辑等）。
   - 返回：路由对象（传递给 `RouterProvider`）。
2. **`RouterProvider`**
   将路由实例注入 React 应用，替代传统的 `<BrowserRouter>` 包裹方式。
   - 参数：`router`（由 `createBrowserRouter` 创建的路由对象）。

##### 二、用法

**定义路由表**

```
// src/routes.js
import { createBrowserRouter } from "react-router-dom";
import Home from "./pages/Home";
import Login from "./pages/Login";
import ErrorPage from "./pages/ErrorPage";

// 定义路由配置
const router = createBrowserRouter([
  {
    path: "/",
    element: <Home />,       // 直接渲染组件
    errorElement: <ErrorPage />, // 全局错误边界
  },
  {
    path: "/login",
    element: <Login />,
    // 可添加数据加载或 Action
    loader: () => fetchUserData(), // 预加载数据
  },
  {
    path: "/user/:userId",
    element: <UserProfile />,
    loader: ({ params }) => fetchUser(params.userId), // 动态参数加载
  },
]);

export default router;
```

 **注入路由到应用**

```
// src/main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import { RouterProvider } from "react-router-dom";
import router from "./routes";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
```

##### 三、高级功能实现

1. **数据加载（Data Loading）**

通过 `loader` 函数预加载路由所需数据：

以下是一个典型的数据加载流程：

1. **用户触发导航**（如点击链接 `/user/123`）。
2. React Router **挂起当前 UI**，显示 `Suspense` 的 `fallback`（若有）。
3. **执行目标路由的 `loader` 函数**，获取数据。
4. **数据加载完成后**，渲染目标路由的组件，并将数据通过 `useLoaderData` 传递给组件。
5. 若 `loader` **加载失败**，渲染 `errorElement` 组件。

在项目中未使用，因为希望从redux中通过createAsyncThunk获取各项数据。

```
// 路由配置
{
  path: "/posts",
  element: <PostsPage />,
  loader: async () => {
    const posts = await fetch("/api/posts").then(res => res.json());
    return posts; // 数据会传递给组件
  },
}

// 组件中获取数据
import { useLoaderData } from "react-router-dom";

function PostsPage() {
  const posts = useLoaderData(); // 直接获取 loader 返回的数据
  return (
    <div>
      {posts.map(post => <div key={post.id}>{post.title}</div>)}
    </div>
  );
}
```

2. **错误边界（Error Boundary）**

通过 `errorElement` 定义错误处理组件：

```
{
  path: "/dashboard",
  element: <Dashboard />,
  errorElement: <ErrorPage />, // 捕获子路由错误
  children: [
    { path: "profile", element: <Profile /> },
    { path: "settings", element: <Settings /> },
  ],
}
```

## 12、echarts实现统计

- 使用 `ReactECharts` 组件包裹 ECharts 实例
- 通过其中的`option` 属性配置相应的统计图

1、对于收入支出数据通过柱状图进行统计。Xaxis属性配置月份，Yaxis属性配置值。series属性对数据进行遍历分别配置pir上收入和支出数据，type是bar。

2、对于分类数据通过饼状图进行统计，series属性中的data配置数据，type为pie

## 13、localStorage

### cookie/sessionStorage/localStorage 的区别

> 参考答案：
>
> cookie、sessionStorage、localStorage 都是保存本地数据的方式
>
> 其中，cookie 兼容性较好，所有浏览器均支持。浏览器针对 cookie 会有一些默认行为，比如当响应头中出现`set-cookie`字段时，浏览器会自动保存 cookie 的值；再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得 cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为，给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然 cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式
>
> HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据，后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据、读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。
> cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M，而 sessionStorage 和 localStorage 则没有限制
> cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与 domain 关联

### 前端该用 LocalStorage 还是 Cookie 存 Token？**

- **优点：**
  - 存储容量较大，适合存放较多或较大的数据。
  - 操作简单，通过 JavaScript API 直接读写，不需要每次请求都自动携带，便于在客户端灵活控制。
- **缺点：**
  - 数据完全暴露给前端脚本，无法设置 HttpOnly，容易受到 XSS 攻击。
  - 需要手动将 token 附加到 HTTP 请求头中，增加了实现复杂度。
  - 数据不会自动随请求发送，跨域时需额外处理。

**Cookie 存储 Token**

- **优点：**
  - 浏览器会自动在每个请求中附带 Cookie，便于服务器端识别用户会话。
  - 可以设置 HttpOnly 属性，防止 JavaScript 访问，从而降低 XSS 风险。
  - 配置 SameSite 和 Secure 属性后，可在一定程度上防范 CSRF 等攻击。
- **缺点：**
  - 存储容量有限（通常约 4KB），不适合存放大量数据。
  - 自动随请求发送，可能会带来不必要的流量开销。
  - 如果配置不当（例如未设置 SameSite 或 Secure），依然存在安全隐患。

## 14、移动端适配

通过媒体查询结合rem与flex的方式，实现了移动端适配。

1、flex布局：用来设置较大的元素布局，如控制一行中显示几列房源item。

2、rem布局：用来设置较小的元素布局，如房源item中的文字大小，边距等。首先给根元素html设置字体大小，其余元素的设置为几倍的rem。rem的优势：每个元素父元素文字大小可能不一致， 但是整个页面只有一个html，这样一来可以很好来控制整个页面的元素大小。

3、通过媒体查询，实现在不同页面改变根元素字体大小，从而改变元素大小。通过min-width，max-width来控制断点。

### 问题1：响应式布局如何实现切换栏数

1、通过flex-wrap，确保元素可切换

2、默认是一行显示五列，简写形式是flex: 1, 0, 20%

其中第一个参数为flex-grow，定义子元素在容器有**剩余空间**时如何分配剩余空间。值为1说明在页面中占一份。flex-grow的值代表全部子元素加起来宽度占到几份。由于20%*5=100，已占满，所以不会再起作用。如果是flex: 1，是flex: 1, 1, 0。初始宽度为0.通过flex-grow等于1所以将剩余空间占满。同时flex-shrink为1所以可以收缩。

第二个参数为flex-shrink定义子元素在容器**空间不足**时如何收缩。值为0，元素禁止收缩。

第三个参数为flex-basis定义子元素在分配剩余空间前的初始大小。值为20%，说明初始大小为20%，20%*5=100，正好占满。

3、当页面宽度逐渐减小时，通过max-width设置范围，当减小到程度flex-basis就换位25%变成4列，并以此类推变为三列两列一列。

### 问题2：都有哪些响应式布局方案，优缺点都是什么

| **布局方法**       | **优点**                                                     | **缺点**                                                     |
| :----------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Flexbox**        | 1. 灵活的对齐和空间分配 2. 一维布局简单直观 3. 代码简洁，支持响应式 | 1. 二维复杂布局能力有限 2. 旧版浏览器（如 IE10-）需前缀      |
| **CSS Grid**       | 1. 强大的二维布局能力 2. 简化复杂网格结构 3. 支持现代浏览器无缝响应 | 1. 旧版浏览器兼容性差（如 IE11 部分支持） 2. 学习曲线较陡    |
| **流式布局**       | 1. 基于百分比自适应屏幕 2. 实现简单，无需复杂计算            | 1. 内容可能拉伸失真 2. 嵌套元素百分比计算复杂                |
| **Rem 布局**       | 1. 基于根字体大小适配多屏 2. 结合媒体查询实现精细控制        | 1. 需工具转换像素单位（如 PostCSS） 2. 动态调整根字体可能影响性能 |
| **Viewport 单位**  | 1. 直接基于视口尺寸（vw/vh） 2. 天然响应式，减少媒体查询使用 | 1. 部分浏览器支持不全（如 vmin/vmax） 2. 小屏幕内容可能过小  |
| **Bootstrap 栅格** | 1. 快速搭建响应式布局 2. 预设断点，社区支持完善 3. 跨浏览器一致性 | 1. 冗余代码增加体积 2. 定制性受限 3. 依赖框架更新            |
| **媒体查询**       | 1. 精准控制不同断点样式 2. 高度定制化，适配任意设备          | 1. 维护多断点时代码臃肿 2. 无法覆盖所有设备尺寸              |
| **混合布局**       | 1. 结合多种方法优势（如 Grid + Flex） 2. 灵活应对复杂场景    | 1. 代码复杂度高 2. 需开发者深入理解各方法特性                |

### 问题3：使用rem与flex布局的好处是什么

rem：普通em是根据父元素规定的字体大小确定的，对于不同的元素父元素可能不同，设置的字体大小可能也不同，也就会导致em设置较混乱。而rem只根据根元素html设置，所以各个子元素中的rem都按照同一套标准设置，较为统一，更改时也只需要更改html中的字体大小即可，方便控制。

flex: 空间分配很灵活方便，很多时候只需要配置一个flex: 1即可。构建自适应布局也很简单，如两栏布局，一栏设置固定宽度，另一栏直接设置flex: 1就可以占满剩余部分。

## 15、如何实现点击链接跳转

1、酒店中的每种房源都几个a链接来代表对应的平台

2、以携程为例，所有酒店的详情页面的协议，域名，路由hotel/detail都是相同的，只有查询参数不同。查询参数是hotelId和adult，从后端获取到相应的参数后，通过模板字符串放到href的链接中，就可以实现链接跳转。

# 计网篇

## HTTP协议

### HTTP协议的优点和缺点

**定义**：HTTP 是超文本传输协议，定义了客户端和服务端之间交换报文的方式和格式，默认端口号为80端口。使用 TCP 作为传输层协议，保证数据交换的可靠性。

**优点**：

- 简单快速
- 无连接
- 无状态：无通信过程的上下文信息，这样后续处理前面的信息需要重传
- 灵活：允许任意类型的数据对象

**缺点**：

- 无状态：HTTP不会保留关于客户的任何信息
- 明文传输：报文是文本形式，会暴露给外界，不安全
- 不安全

### HTTP请求报文

**请求行   请求头   空行   请求体**

- **请求行**：请求方法、URL字段、HTTP协议版本字段，用空格分离
- **请求头：**请求头关键词/值组成
- **请求体：**post put 等请求携带的数据

### HTTP响应报文

**相应行   响应头   空行   响应体**

- **相应行**：网络协议版本、状态码、状态码原因   如 HTTP/1.1 200 OK 
- **响应头**：响应首部字段
- **响应体**：服务器响应的数据

### 常见的HTTP请求方法

- GET：获取数据；
- POST：提交数据；
- PUT：更新数据；
- DELETE：删除数据；
- HEAD：获取报文首部；
- OPTIONS：询问支持的请求方法，检查访问权限，用来跨域请求；
- CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；
- TRACE：回显收到的请求，用于测试或诊断。

### 常见的HTTP请求头和响应头

**请求头：**

- Accept:浏览器能够处理的内容类型
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookie：当前页面设置的任何Cookie
- Host：发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

**响应头：**

- Date：表示消息发送的时间，时间的描述格式由rfc822定义
- server:服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache-Control：控制HTTP缓存
- content-type:表示后面的文档属于什么MIME类型

### GET 和 POST 请求的区别

| 特性               | GET 请求                         | POST 请求                                    |
| ------------------ | -------------------------------- | -------------------------------------------- |
| 数据传输方式       | 在 URL 中传递                    | 在请求体中传递                               |
| 主要用途           | 获取数据                         | 提交数据、改变服务器状态                     |
| URL 长度限制       | 有（受浏览器限制，约 2048 字符） | 无（理论上无大小限制，实际受限于服务器配置） |
| 安全性             | 相对不安全（数据可见）           | 相对安全（数据不可见，但需要结合 HTTPS）     |
| 可缓存性           | 可以被缓存                       | 默认不缓存                                   |
| 是否改变服务器数据 | 否                               | 是                                           |
| 书签和共享         | 可以（因为数据在 URL 中）        | 无法（因为数据在请求体中）                   |

### POST 和 PUT 区别

POST：专注于创建数据

PUT：专注于更新数据

### HTTP1.0 HTTP1.1 HTTP2 三者区别

| 特性             | HTTP/1.0                                                     | HTTP/1.1                                                     | HTTP/2                                                       |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **TCP连接**      | 默认**无连接**（需要手动配置 `Connection: keep-alive` 实现`close` 关闭） | 默认**持久连接**（通过 `Connection: close` 关闭              | 持久**连接** + **多路复用**                                  |
| **数据传输格式** | 文本                                                         | 文本                                                         | 二进制                                                       |
| **并发请求**     | 不支持                                                       | 部分支持（**管线化**：第一个请求未响应前可发送后去请求）     | 支持**多路复用**（同一个TCP并发处理多个请求和响应）          |
| **缓存控制**     | 基本支持（缓存控制主要依赖于响应头中的 `Expires` 字段）      | 先进的缓存控制（通过 `Cache-Control` 响应头来控制缓存策略）  | 先进的缓存控制（通过 `Cache-Control` 响应头来控制缓存策略）  |
| **虚拟主机支持** | 不支持                                                       | 支持（多域名共享同一IP： host 字段）                         | 支持（多域名共享同一IP： host 字段）                         |
| **头部压缩**     | 不支持                                                       | 不支持                                                       | 支持（HPACK算法压缩：如去重）                                |
| **服务器推送**   | 不支持                                                       | 不支持                                                       | 支持（服务器客户端请求前主动推送资源，如请求html，推送相关css，js） |
| **典型用途**     | 静态网站请求                                                 | 动态内容和静态内容混合                                       | 高性能的现代应用                                             |
| **资源请求**     | 返回整个对象                                                 | 支持**断点续传**，且**允许只请求资源中某一部分**（range 头域） |                                                              |

**断点续传：**

在**传输中断后从中断的位置继续传输**，而不必从头开始

**工作原理**：

1. **文件分块**：将文件划分为多个小块，每块都有一个唯一的标识符和位置。
2. **记录传输状态**：在传输过程中，客户端和服务器会**记录已经成功传输的文件部分**，**以及剩余需要传输的部分**。
3. **继续传输**：当传输中断时，客户端可以向服务器**请求从上次中断的地方继续传输**，服务器根据客户端的请求和记录的数据从指定位置开始继续传输数据。

使用场景：大文件上传

### HTTP和HTTPS的区别

**HTTP + SSL/TLS 加密**：HTTPS 是在 HTTP 的基础上加入了 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）加密协议，确保通信数据的机密性、完整性和真实性。

**安全性**：

- **数据加密**：传输的数据被加密，第三方无法窃取通信内容。
- **数据完整性**：保证数据在传输过程中不会被篡改。
- **身份验证**：通过证书确认服务器的身份，防止中间人攻击。

**端口**：

- HTTP 使用 **80 端口**
- HTTPS 使用 **443 端口**

**性能**：HTTPS 需要额外的 SSL/TLS 握手过程，会增加一些开销，但随着硬件的进步和 HTTP/2 的引入，这种开销已经大大降低。

### HTTP3.0

**定义：**基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。

- 流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。
- 集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。
- 多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。
- 快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。

### URL组成部分

例如：**[www.aspxfans.com:8080/news/index.…](https://link.juejin.cn/?target=http%3A%2F%2Fwww.aspxfans.com%3A8080%2Fnews%2Findex.asp%3FboardID%3D5%26ID%3D24618%26page%3D1%23name)**

- 协议部分
- 域名部分
- 端口部分
- 虚拟列表部分
- 文件名部分：最后一个 / 到 ？开始
- 锚部分：# 开始到最后
- 参数部分：参数之间由 & 分隔

### 缓存相关的HTTP请求头

强缓存：

- Expires
- Cache-Control

协商缓存：

- Etag、If-None-Match
- Last-Modified、If-Modified-Since

## HTTPS协议

### 什么是HTTPS协议

**定义**：超文本传输安全协议（HTTPS），是 HTTP 的加密版。通过 SSL/TLS 协议对数据进行加密，确保客户端和服务器之间传输数据时安全的，防止被窃听篡改或冒充。

**优点**：

- 验证服务器身份
- 数据安全
- 增加了中间人攻击的成本

**缺点**：

- 加密和解密消耗服务器资源
- SSL 证书是收费的
- TLS 握手费时，增加页面加载时长
- SSL 证书需要绑定 IP，不能使用同一个 IP 绑定多个域名

### HTTPS工作原理

**访问网站的过程：**

- 浏览器发送 HTTPS 请求
- 服务器返回证书，浏览器验证有效性
- 通过 TLS 握手建立连接
- 建立连接后使用绘画密钥进行加密通信

### HTTPS 如何确保数据传输的安全性

HTTPS 通过**使用 TLS/SSL 协议对数据进行加密**，防止被窃听和篡改

**TLS 使用对称加密和非对称加密相结合**的方式保证数据完整，同时通过**数字证书验证服务的身份**来防止中间人攻击

**流程：**

- **数字证书验：证服务器身份，确保服务器的合法性**
- **TLS 握手：然后使用非对称加密（使用证书中的服务器公钥发送预主密钥，服务器使用私钥解密）生成主密钥，最终生成会话密钥**
- **最后使用对称加密进行数据交换**

### TLS/SSL工作原理

TLS 是 SSL 改进后的版本，有更强大安全性、更好的加密算法支持

**定义：** **安全传输层协议**，是在 TCP 和 HTTP 之间的一层安全协议

**TLS握手过程（协商安全参数、验证身份、建立安全密钥，确保数据传输的安全性）：**

- 客户端：发送支持的**加密算法列表和随机数**
- 服务器：**选择加密算法**，返回**服务器的证书和另外随机数**
- 客户端：**验证证书**真实性，生成**预主密钥**，并**用服务器的公钥加密**给服务器
- 服务器：使用私钥**解密预主密钥**，**生成主密钥**
- 客户端和服务器**根据主密钥生成会话密钥**，用于后续数据加密

**依赖三类基本算法：散列函数 hash、对称加密、非对称加密**

- 基于散列函数**验证信息完整新**
- 对称加密采用**协商的密钥进行数据加密**
- 非对称加密**实现身份认证和密钥协商**

**对称加密和非对称加密：**

- **对称加密：**使用相同密钥加密和解密，速度快，但分发不安全；**用于加密真实传输数据**
- **非对称加密：**使用公钥和私钥加密和解密，速度慢，但安全；**用于安全交换密钥**
- 公钥和私钥：公钥是公开的，私钥是保密的。公钥和私钥加密的数据只能使用对应的私钥和公钥解密。

### 什么是数字证书

数字证书是 CA 签发的电子邮件，用于验证服务器的身份

CA 是受信任的第三方机构，确保客户端连接到的服务器是合法的

## HTTP 状态码

| **类别** | **原因**                        | **描述**                   |
| -------- | ------------------------------- | -------------------------- |
| 1xx      | Informational(信息性状态码)     | 接受的请求正在处理         |
| 2xx      | Success(成功状态码)             | 请求正常处理完毕           |
| 3xx      | Redirection(重定向状态码)       | 需要进行附加操作一完成请求 |
| 4xx      | Client Error (客户端错误状态码) | 服务器无法处理请求         |
| 5xx      | Server Error(服务器错误状态码)  | 服务器处理请求出错         |

### 2xx   成功

- **200  OK**      请求正常处理完毕
- **204 No Content**      正常处理，**没有返回内容**（响应体无主体）
- **206 Partial Content**      **客户端进行了范围请求**（响应报文中有 Content-Range 指定范围的实体内容）

### 3xx   重定向

- **301 Moved Permanently**      **永久重定向**

  请求的资源已经分配了新的 URL，在响应头的 Location 首部字段中指出

  搜索引擎会在新网址上抓取内容

  使用场景：更新域名

- **302 Found**      **临时重定向**

  （本次）能使用新的 URL 访问资源

  使用场景：做活动，未登录的用户中心重定向到登录页面，404页面重新定到首页

- **303 See Other**      

  和 302 有相似的功能，但 303 明确表示客户端要采用 GET 的方式获取资源

**注意：当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做**

- **304 Not Modified**      **浏览器缓存相关**

  告诉客户端有缓存，直接使用缓存中的数据

- **307 Temporary Redirect**   **临时重定向**

  和 302 相同含义，但307遵循浏览器标准，不会从 POST 变成 GET

### 4xx   客户端错误状态码

- **400 Bad Request**      

  **请求报文语法错误**，浏览器会像200 OK 一样对待这个状态码

- **401 Unauthorized**

  发送的**请求要有 HTTP 认证的认证信息**，当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。

  - 401.1 - 登录失败。
  - 401.2 - 服务器配置导致登录失败。
  - 401.3 - 由于 ACL 对资源的限制而未获得授权。
  - 401.4 - 筛选器授权失败。
  - 401.5 - ISAPI/CGI 应用程序授权失败。
  - 401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。

- **403 Forbidden**

  **请求被服务器拒绝了**

  - 403.1 - 执行访问被禁止。
  - 403.2 - 读访问被禁止。
  - 403.3 - 写访问被禁止。
  - 403.4 - 要求 SSL。
  - 403.5 - 要求 SSL 128。
  - 403.6 - IP 地址被拒绝。
  - 403.7 - 要求客户端证书。
  - 403.8 - 站点访问被拒绝。
  - 403.9 - 用户数过多。
  - 403.10 - 配置无效。
  - 403.11 - 密码更改。
  - 403.12 - 拒绝访问映射表。
  - 403.13 - 客户端证书被吊销。
  - 403.14 - 拒绝目录列表。
  - 403.15 - 超出客户端访问许可。
  - 403.16 - 客户端证书不受信任或无效。
  - 403.17 - 客户端证书已过期或尚未生效
  - 403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。
  - 403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。
  - 403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。

- **404 Not Found**   **服务器无法找到请求的资源**

  - 404.0 -（无） – 没有找到文件或目录。
  - 404.1 - 无法在所请求的端口上访问 Web 站点。
  - 404.2 - Web 服务扩展锁定策略阻止本请求。
  - 404.3 - MIME 映射策略阻止本请求。

- **405 Method Not Allowed**   **服务器禁止使用此方法**

  客户端可以通过 OPTIONS 方法查看允许的访问方法

  `Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE`

### 5xx   服务器错误状态码

- **500 Internal Server Error**   **服务器端发生错误**，可能是 bug 或某些临时故障
- **502 Bad Gateway**   **网关或代理服务器出错与上有服务器通信出错**
  - 502.1 - CGI （通用网关接口）应用程序超时。
  - 502.2 - CGI （通用网关接口）应用程序出错。
- **503 Service Unavailable**   **服务器处于超负荷或停机维护状态**
- **504 Gateway Timeout**   **网关和代理服务器等待上有服务器超时**

## DNS

### 什么是DNS

DNS 是域名系统，可以将域转换为计算机可以理解的 IP 地址

### DNS工作步骤

- **DNS 递归查询：**客户端向本地 DNS 解析器发送查询请求
- **本地 DNS 解析器查询根服务器：**如果本地缓存没有，向根服务器请求
- **根服务器回应：**根服务器返回顶级域名（.com、.net）服务器地址
- **查询顶级域名服务器：**本地 DNS 解析器向 TLD 服务器请求域名信息
- **TLD 服务器回应：**提供域名的权威 DNS 服务器地址
- **查询权威 DNS 服务器：**本地 DNS 服务器向权威 DNS 服务器请求最终 IP地址
- **权威 DNS 服务器回应：**返回 IP 地址，**本地 DNS 服务器将结果缓存，并发给客户端**

### 什么是递归查询和迭代查询

- **递归查询：**本地 DNS 解析器代替客户端完成整个查询过程（从根服务器到权威服务器）   **向本地 DNS 服务器请求的方式**
- **迭代查询：**在每一步中，DNS 解析器只会提供下一步应该查询的服务器地址，解析器根据这些提示进行查询   **本地 DNS 服务器向域名服务器请求的过程**

## 网络模型

### 七层网络（OSI）

**通信特点：对等通信（源和目的端对等层通信）**

**（1）应用层**   为应用提供服务

最靠近用户的一层，**为用户提供应用接口和网络服务**

HTTP   HTTPS   FTP   SMTP

**（2）表示层**    数据格式转换、数据加密

**用于应用层数据的编码和转换**，确保应用层之间发送的数据可被互相识别

**（3）会话层**   建立、管理、维护会话

负责建立、管理、终止表示层通信，保证长时间文件传输不被打断

**（4）传输层**   建立、管理、维护端到端的连接

**负责端到端的传输，保证数据的完整性和可靠性**，建立、管理、终止传输连接，检查错误

TCP传输控制协议   UDP用户数据报协议   SCTP（流控制传输协议）

**（5）网络层**   数据包路由选择和转发

**提供 IP 地址，处理数据包的路由和转发**，以及流量控制

Router路由   IP互联网协议  ICMP互联网控制报文协议

**（6）数据链路层**   提供介质访问和链路管理

**将网络层的 IP 数据封装成帧**，一对一和一对多的数据传输

Switch交换机   Wi-Fi无线局域网

**（7）物理层**   

负责网络设备之间的物理连接和传输介质，如电缆类型、连接器、信号类型

网线   光纤

### TCP/IP五层协议

**应用层：**为应用进程提供服务

**传输层：**两台主机中提供通信服务，源端口和目标端口

**网络层：**选择合适的路由在两台主机间传递，源IP和目标IP

**数据链路层：**将网络层的 IP 数据封装成帧，并在链路的两个相邻节点间传送

**物理层：**保证数据的传输物理媒介

## TCP和UDP

TCP 和 UDP 都是传输层协议

### TCP

**定义：**TCP 是传输控制协议。是一种面向连接的、可靠的、基于字节流的传输层通信协议。

**特点：**

- **面向连接**

  **发送数据之前必须在两端建立连接**，连接方法为三次握手

- **仅支持单向传播**

  每条 TCP 传输连接只能有两个端点，**只能进行点对点的数据传输**

- **面向字节流**

  不保留报文边界的情况下，**以字节流方式进行传输**

- **可靠传输**

  TCP 的**段编号和确认号可以判断丢包和误码**

- **提供拥塞控制**

  当网络出现拥挤，TCP **能够减小向网络注入数据的速率和数量**，缓解阻塞

- **全双工通信**

  客户端和服务器什么时候都能通信，不需要客户端发送新的请求

**应用场景：**

**效率要求相对低，但准确性要求高的场景**

例如：文件传输、接收邮件

**三次握手和四次挥手：**

- 三次握手
  - 客户端发送 SYN（同步标志）和一个初始序列号（x）
  - 服务器发送 SYN 、确认标志（ACK=x+1）、服务器初始序列号（y），表示同意建立连接
  - 客户端发送ACK（y+1），双方建立连接
- 四次挥手
  - 客户端发送终止标志（FIN）
  - 服务器发送确认标志（ACK）并进入等待关闭状态
  - 服务器发送（FIN），并进入确认关闭状态
  - 客户端发送 ACK，确认关闭

**为什么需要三次握手和四次挥手：**

- 三次握手：确保双方都有能力发送和接收数据，通过三次握手协商初始序列号，并同步双方发送和接受能力，**确保连接的可靠性**
- 四次挥手：因为 TCP 是全双工的。双方确认都没有数据发送才能安全断开连接

**TCP的重传机制：**

TCP 在发送一个数据之后，没有在规定时间内收到发送数据的 ACK 确定报文，就会重新传送（**一定时间内没有完成则放弃并重新发送**）

**TCP的阻塞控制机制（四种机制）：**

- **慢启动：**在开始的时候不发送大量数据，**先测试网络阻塞程度**，由小到大增加**阻塞窗口**的大小
- **拥塞避免：** **将拥塞窗口控制为按线性增长**，是网络不容易阻塞
- **快速重传：**接收到收到一个失序报文段就会发送一个重复确认，**当连续发送三个重复确认就立即重传**，不用等到计时器到期
- **快速恢复：**连续收到三个重复确认时，**把慢启动门限减半**

### UDP

**定义：**用户数据报协议，是一种面向连接、简单的传输层协议。**直接将数据报发送给接收方，不保证数据的到达、顺序或完整性，不进行流量控制和错误检测**

**特点：**

- **无连接**

  在传输数据前**不需要建立连接**

- **不可靠**

  **不保证数据的可靠性**，数据可能丢失、重复、无序到达

- **低开销**

  **不进行错误修复、重传、流量控制等操作**，开销小，数据传输快

- **面向数据报文**

  使用**数据报文进行传输**

- **有单播，多播，广播功能**

  支持一对一，一对多，多对一，多对多的方式。

**使用场景：**

- 在线游戏
- 实时应用（短视频软件，网络电视，网络通话）

## WebSocket

**基本概念：**一个可以在单个 TCP 连接上进行**持久、双向连接**的**实时**通信通道

**特点：**全双工通信（建立连接后双方可以互发消息），低开销，实时性，有状态（长连接），跨平台（独立于平台和语言的协议），安全（加密协议）

**工作步骤：**

- **握手阶段：**客户端发送请求到服务器，表明希望建立 WebSocket 连接。请求头包含特定字段，如 `Upgrade: websocket` 和 `Connection: Upgrade`。
- **服务器响应：**如果服务器支持，返回 101 确认**升级协议（握手成功后）**，HTTP 协议升级为 WebSocket 协议
- **数据传输阶段：**自由发送和接受数据，不需要额外的 HTTP 请求
- **关闭阶段：**由任意一方关闭

**使用场景：**

- 实时聊天应用
- 实时数据推送（股票，体育赛事）
- 协同编辑（多用户同时编辑文档）

**WebSocket和http的区别**

| **特性**         | **HTTP**                              | **WebSocket**                  |
| ---------------- | ------------------------------------- | ------------------------------ |
| **通信**         | 单向通信                              | 双向实时通信                   |
| **连接方式**     | 无状态、短连接                        | 持久连接                       |
| **数据传输效率** | 低效（每次请求/响应需传输完整头信息） | 高效（轻量级数据帧，低延迟）   |
| **使用场景**     | 页面加载、API 请求、文件下载等        | 在线聊天、实时数据更新、游戏等 |

## 输入一个url，浏览器会做哪些事情

- **URL 解析：**提取协议、主机、端口、路径
- **DNS 解析：**查找域名的 IP 地址
- **建立 TCP 连接：**三次握手
- **发送 HTTP 请求：**通过 TCP 连接将请求发送给目标浏览器
- **服务器处理请求**
- **接收 HTTP 响应**
- **渲染页面：**解析 HTML   解析 CSS   执行 js     构建渲染树   布局和绘制

# 浏览器篇

## 进程与线程

**定义：**

- 进程：**正在运行的程序（微信、QQ）**，资源分配的最小单元
- 线程：任务调度和执行的基本单位

**区别：**

- **通信：**线程共享同一进程资源，进程通信需要辅助进程间通信
- **开销：**进程创建和回收开销大，因为会分配独立内存和资源。线程开销小，因为共享进程的资源
- **崩溃：**一个线程崩溃会导致所在进程崩溃，但是不会影响到其他进程
- **回收内存：**一个进程关闭之后，系统会回收进程的内存

**进程之间通信方式：**

- **管道：**
  - 匿名管道：单向通信机制，适合父子进程通信。一端写入，一端读取
  - 命名管道：双向通信机制，无关系进程通信。
- **消息队列：**
  - 可以支持一个进程以消息的形式给另一个进程发送数据
  - 发送的数据具有优先级，可以按照优先级对消息进行读取
  - 支持复杂的数据格式和结构，支持多种操作（读写、清空等）
- **共享内存：**
  - 允许进程直接访问相同的内存区域
  - 适合大量数据快速传输
- **内存映射文件：**
  - 将文件映射到内存，实现多个进程对文件的并行访问
  - 适合共享大数据文件

**僵尸内存：**

子进程结束后，父进程有没有释放子进程占用的资源，等待父进程读取

**孤儿进程：**

父进程终止，但子进程还在继续运行，会被 init 进程接管并正常运行

### 如何实现多标签页通信（跨页面通信）

- `localStorage` + `storage`事件   **数据量小**

  所有标签页共享同一个 localstorage 空间，另一个标签页通过 storage 事件监听

- `BroadcastChannel`   **实时通信且浏览器支持**

  同源多个浏览器上下文通信（标签页，iframe，web worker）

  **实现步骤：**

  1. 每个标签页创建一个`BroadcastChannel`对象并订阅相同的频道名称。
  2. 标签页之间通过`postMessage`发送消息，其他订阅该频道的标签页可以接收到消息。

- WebSockets   **跨域或双向实时通信**

  WebSocket是一种持久的双向通信协议，允许客户端和服务器之间实时交换数据，服务器中作为中介传递数据

  **实现步骤：**

  1. 在服务器上配置WebSocket或SSE。
  2. 各标签页连接到同一个WebSocket服务器，实现通信。

### 浏览器的多进程

- **Browser 进程**：浏览器的**主进程**，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。
- **GPU 进程**：用于 **3D 绘制**等，最多一个。
- **第三方插件进程**：每种类型的插件对应一个进程
- **浏览器渲染进程**（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。
- **网络进程：**加载网络资源

### 渲染进程（浏览器内核）

- **GUI 渲染线程**：渲染浏览器界面，回流重绘会执行
- **JavaScript 引擎线程**：处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码
- **事件触发线程**：控制事件循环，把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。
- **定时触发器线程**：setInterval 与 setTimeout 所在线程
- **异步 http 请求线程**：XMLHttpRequest 连接后新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

**GUI 渲染线程与 JavaScript 引擎线程是互斥的**，GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞，此时需要requestAnimationframe

### requestAnimationframe

把动画相关的 js 分成小的任务块，每一帧只执行一个任务快，GUI 线程通常每秒60帧进行一次更新页面，此方法会在每一帧开始之前调用回调函数，保证 js 动画更新，避免页面阻塞。

### 单线程的 JavaScript

所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。

## 协程（Coroutine）

协程是一种用户态的轻量级线程，由程序员显式控制其执行流程。协程可以在执行过程中暂停和恢复，适合用于异步编程和非阻塞I/O操作。

**关键点**：

1. **用户态控制**：协程的调度由程序员控制，而不是操作系统。协程可以在执行过程中暂停和恢复，而不需要进行上下文切换。
2. **轻量级**：协程的创建和销毁开销非常小，适合用于高并发的场景。
3. **非阻塞I/O**：协程适合用于异步编程和非阻塞I/O操作，可以避免线程切换的开销。
4. **协作式调度**：协程通过协作式调度（Cooperative Scheduling）进行任务切换，而不是抢占式调度（Preemptive Scheduling）。

**示例**：

- 在异步编程框架（如Python的asyncio）中，协程用于处理异步I/O操作。
- 在高并发的网络服务器中，协程可以用于处理大量的客户端连接，提高系统的吞吐量。

## 浏览器缓存机制（本地缓存）

- 浏览器缓存是提升网页性能的核心机制，通过减少重复请求和网络传输，显著加快页面加载速度。缓存机制分为两个层级：**强缓存**和**协商缓存**，二者协同工作形成高效的缓存策略。

### 浏览器缓存机制及使用过程详解

#### 一、首次请求资源（无缓存）

1. **用户访问网页**：浏览器解析 HTML 时发现需要加载资源（如 CSS、JS、图片）
2. **发送完整请求**：浏览器向服务器发送标准 HTTP 请求
3. **服务器响应**：
   - 返回资源内容（状态码 200）
   - 在响应头中设置缓存策略：
     - `Cache-Control: max-age=3600`（资源有效期 1 小时）
     - `ETag: "abc123"`（资源指纹标识）
     - `Last-Modified: Wed, 21 Jun 2023 10:30:00 GMT`（最后修改时间）
4. **浏览器存储**：
   - 保存资源到内存缓存（Memory Cache）或磁盘缓存（Disk Cache）
   - 记录缓存策略和验证信息

#### 二、后续请求 - 强缓存阶段

1. **再次访问相同资源**：
   - 浏览器检查缓存策略
   - 计算`Cache-Control`有效期：当前时间 < (首次请求时间 + max-age)
2. **强缓存生效**：
   - 若资源在有效期内，浏览器直接使用本地缓存
   - **不发送任何网络请求**
   - 开发者工具显示：`200 OK (from disk cache)` 或 `200 OK (from memory cache)`
3. **缓存位置优先级**：
   - 小文件优先使用内存缓存（Memory Cache）
   - 大文件使用磁盘缓存（Disk Cache）

#### 三、强缓存失效 - 协商缓存阶段

1. **强缓存过期后**：
   - 浏览器准备网络请求
   - 添加缓存验证信息到请求头：
     - 若有 ETag：添加 `If-None-Match: "abc123"`
     - 若有 Last-Modified：添加 `If-Modified-Since: Wed, 21 Jun 2023 10:30:00 GMT`
2. **发送条件请求**：
   - 请求头包含验证信息
   - 服务器收到后检查资源状态
3. **服务器响应**：
   - **资源未修改**：返回 `304 Not Modified`（空响应体），浏览器使用本地缓存
   - **资源已修改**：返回 `200 OK` + 新资源内容，浏览器更新缓存
4. **网络消耗对比**：
   - 完整资源请求：传输整个文件（如 100KB）
   - 304 响应：仅传输响应头（约 0.5KB）

#### 四、缓存更新机制

1. **收到 304 响应**：
   - 浏览器更新缓存有效期
   - 继续使用现有缓存资源
2. **收到 200 响应**：
   - 替换旧缓存内容
   - 存储新的缓存策略
3. **资源更新策略**：
   - 文件名哈希：`style.abc123.css` → `style.def456.css`
   - HTML 引用更新，强制获取新资源

#### 五、用户行为影响

1. **地址栏输入 URL/页面跳转**：
   - 正常触发强缓存和协商缓存
2. **普通刷新（F5）**：
   - 跳过强缓存，直接进入协商缓存
3. **强制刷新（Ctrl+F5）**：
   - 忽略所有缓存，直接请求最新资源
   - 请求头添加 `Cache-Control: no-cache`

## 浏览器本地存储

### Cookie

- **定义：**大小只有 4kb，是一种纯文本文件，每次发起 HTTP 请求都会携带
- **特性：**
  - 一旦创建，名称无法修改
  - 无法跨域名，不同域名下 cookie 无法共享
  - 每个域名 cookie 不能超过 20 个，每个大小不能超过 4kb
  - 有安全问题，如果被拦截，可获取 session 的所有信息
- **使用场景：**统计页面点击次数；和session 结合使用，将 sessionID 储存到 cookie ，这样服务器就知道谁发起的请求
- **字段：**Name   Value   Size   Path   Domain可以访问cookie的域名   Expires

### SessionStorage

- **作用：**临时保存同一窗口的数据，刷新窗口不会删除
- **同源策略：**只有在同一浏览器的同一窗口下才能共享
- **使用场景：**游客登陆信息，临时浏览器记录信息，关闭网页后信息消除
- **API：**
  - `sessionStorage.setItem('key', 'value'); `  保存
  - `let data = sessionStorage.getItem('key');`   获取
  - `sessionStorage.removeItem('key');`   删除
  - `sessionStorage.clear();`   清空
  - `sessionStorage.key(index)`   获取索引

### LocalStorage

- **优点：**
  - 大小为 5MB，可以储存更多信息
  - 持久储存，不会随着页面关闭小时，除非主动清理
- **缺点：**
  - 浏览器隐私模式，无法读取 LocalStorage
  - 同源策略限制
- 使用场景：换肤功能的网站，用户浏览信息，不常变动的个人信息
- **API：**
  - `localStorage.setItem('key', 'value'); `  保存
  - `let data = localStorage.getItem('key');`   获取
  - `localStorage.removeItem('key');`   删除
  - `localStorage.clear();`   清空
  - `localStorage.key(index)`   获取索引

### IndexedDB

**特点：**

- **键值对储存：**数据以键值对形式储存
- **异步：**存储数据异步执行，防止大量数据读写拖慢网页表现
- **同源限制**
- **储存空间大：**不少于 250MB ，甚至没有上限
- **支持二进制储存：**可以存储字符串和二进制数据

### **三者区别**

| 特性         | `cookie`                    | `localStorage` | `sessionStorage`       |
| ------------ | --------------------------- | -------------- | ---------------------- |
| **大小**     | 约 4KB                      | 5-10MB         | 5-10MB                 |
| **存储时间** | 指定过期时间或会话结束      | 永久存储       | 关闭标签页或窗口后清除 |
| **访问范围** | 客户端和服务器              | 客户端         | 客户端                 |
| **安全性**   | 支持 `Secure` 和 `HttpOnly` | 与同源策略一致 | 与同源策略一致         |
| **适用场景** | 持久化少量数据              | 长期存储数据   | 临时存储数据           |

## 浏览器组成

浏览器分为两部分：shell 和 内核

- 外壳：菜单，工具栏。主要提供用户界面操作，设置参数等。调用内核来实现
- 内核：浏览器核心。显示内容的程序或模块

### 浏览器主要组成部分

- **用户界面**   地址栏，前进后退按钮，主窗口以外部分
- **浏览器引擎**   用户界面和渲染引擎传达指令
- **渲染引擎**   显示请求的内容。请求、解析、显示文件
- **网络层**   网络调用
- **UI 后端**   用于绘制基础组件（输入框、按钮、下拉菜单）和网页各种元素   
- **JS 解释器**   解析和执行 JS 代码
- **数据储存**   在硬盘上持久化储存数据，如 Cookie
- **安全模块**   防止攻击，HTTPS 加密、沙盒隔离、同源策略、隐私模式
- **插件和扩展模块**  允许用户安装额外功能和工具（广告拦截、密码管理）
- **GPU进程**   复杂图片处理使用 GPU 加速（Canvas）

### 对内核的理解

浏览器内核分为两部分：

- **渲染引擎：**在窗口显示请求的内容（html xml 图片）
- **JS引擎：**解析和执行 js 来实现页面动态效果。

js 引擎越来越独立，内核倾向于指渲染引擎

### 常见内核对比

- **Trident：** **IE 浏览器内核**。早期占有大量市场份额，但是 IE 内核和 W3C 标准脱节，以及大量 Bug 和安全问题没有解决，很多用户转向其他浏览器
- **Gecko：** **火狐内核**。功能强大，支持复杂页面效果。但是消耗资源多
- **Webkit：** **Safari 内核**。网页浏览速度快。但对网页代码的兼容性低，一些编写不标准的网页无法显示。
- **Blink：**谷歌开源内核，**Chrome，edge，Opera浏览器**核心内核。Webkit 分支而来。高性能，支持现代化标准，跨平台兼容（Windows，Linux，安卓，Mac）

## 浏览器渲染原理

### 浏览器渲染过程

- 解析请求的文档，创建 DOM 树
- 解析 CSS，生成 CSSOM 树
- 加载和执行 JS
- 根据 DOM 树和 CSSOM 树构建 render 树
- 根据渲染树进行布局（回流）
- 绘制：遍历渲染树将内容显示在屏幕上

为了快速呈现，浏览器解析一部分就显示一部分

### 回流重绘复合

- **回流：**浏览器重新计算元素位置和大小
  - 操作 DOM / 修改几何属性 / 改变窗口大小 / 读取某些属性（滚动距离）
- **重绘：**重新绘制元素外观
  - 修改 CSS
- **复合：**浏览器将不同图层合成在一起，生成最终屏幕图像的过程。浏览器会将页面分为多个图层，并使用 GPU 进行加速渲染，将图层合成为一个最终的页面显示
  - transform / opacity

### 浏览器渲染优化

- **针对 JS：**

  - JS 放在 body 最后
  - async 异步加载立即执行  defer 异步加载，DOM树解析好顺序执行

- **针对 CSS：**导入外部样式最好使用 link，CSS 少最好使用 style（GUI直接渲染）

- **针对DOM树，CSSOM树：**

  - 使用语义化标签
  - 减少 HTML，CSS层级

- **减少回流重绘：**

  - 尽量在最底层操作 DOM

  - 减少盒子不必要的大小改动

  - 将元素设置为 display：none，这种元素上DOM操作不会引发回流重回，操作结束再显示出来

  - 使用 transform 和 opacity，避免回流重绘，只会发生复合

  - **渲染队列**

    **浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**

## 浏览器安全

### XSS 攻击

**概念：**指**跨站脚本攻击**，攻击者**在网站注入恶意脚本**，在用户浏览器运行，窃取用户信息，调用网站接口执行攻击者操作

**攻击操作：**

- 获取页面的数据，如DOM、cookie、localStorage；
- DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
- 破坏页面结构；
- 流量劫持（将链接指向某网站）；

**攻击类型：**

- **储存型：**恶意脚本储存在服务器上，请求资源时传回（论坛发布，商品评论）
- **反射型：**诱导服务器返回恶意代码的 URL，服务器接收带有 XSS 的数据当作脚本运行（网页搜索，跳转）
- **DOM 型：**通过修改页面的 DOM 节点形成 XSS（ JS 自身的安全漏洞）

**如何防御：**

- **输入验证和过滤：**确保只接受复合预期格式和类型的输入，过滤潜在的危险字符（> < " ’ &）
- **输入编码和转义：**对所有不恶心的数据进行编码 （`<` 转换为 `<`，将 `>` 转换为 `>`），防止解释为 HTML 或者 JS
- **使用安全的库或框架：**React，Vue
- **内容安全策略（CSP）：**能够限制网页允许执行的内容来源，可以防止注入的脚本运行，限制脚本的来源，发送 `Content-Security-Policy` HTTP 头来配置 CSP，如`Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-scripts.com;`

### CSRF攻击

**概念：**指**跨站请求伪造攻击**，诱导进入第三方网站，该网站象被攻击网站发送跨域请求。**本质是利用用户在已登录状态下对目标网站的信任，诱导用户在不知情的情况下执行非预期的操作。。**

**攻击类型：**

- **GET 请求：**网站中的一个 img 标签构建一个请求，用户打开网站后自动发起请求
- **POST 请求：**构建一个表单然后隐藏，进入页面后自动提交表单
- **链接类型：**在 a 标签的 herf 属性构建一个请求，有道用户点击

**如何防御：**

- **对 Cookie 进行双重验证：**用户请求页面时，服务器生成 CSRF Token，并且通过 Cookie 和 AJAX 发送 Token 给客户端，客户端通过 Cookie 和请求参数同时发给服务器，服务器验证 Token 是否与 Cookie 的 Token 匹配。 
- **Cookie 设置 Samesite，限制不能被第三方使用**

### 网络劫持

- **DNS 劫持：**通过修改运营商的本地 DNS 记录，来引导用户跳转到其他服务器；（输入京东被强制跳转到淘宝）
- **HTTP 劫持：**由于 http明文传输，运营商会修改 http 响应的内容，如加广告（浏览器上一直有贪玩蓝月的广告）

## 浏览器同源策略

### 什么是同源策略

**定义：**所谓同源就是**协议、端口号、域名**必须一致，限制不同源之间资源交互的策略，一个重要的安全机制。

**限制：**

- 不同域不可访问 sessionStorage、localStorage 和 indexDB
- 不能操作不同域下 DOM
- 不同域之间无法发送 AJAX 跨域请求

**跨域请求类型：简单请求 和 复杂请求（预检请求）**

- **简单请求**

  满足以下条件

  - 请求方法方法是 `GET`、`POST` 或 `HEAD`。
  - 请求**头部仅包含浏览器自动设置的字段**（如 `Accept`、`Accept-Language`、`Content-Language`、`Content-Type` 等）。
  - 如果使用了 `Content-Type` 头部，则其值仅限于 `text/plain`、`multipart/form-data` 或 `application/x-www-form-urlencoded`。

- **预检请求**

  如果不符合简单请求，则在**实际请求前自动发送一个 OPTIONS 请求，询问服务器是否允许实际请求**，服务器响应后再绝地给是否发送实际请求

### 如何解决跨域问题

- **CORS**

  **定义：**资源跨域共享（CORS），服务器在响应头中设置特定 HTTP 头，告知浏览器允许的跨域请求

  - **Access-Control-Allow-Origin**：源
  - **Access-Control-Allow-Methods**：方法
  - **Access-Control-Allow-Headers**：头
  - **Access-Control-Allow-Credentials**：凭据（如 cookies）。

- **JSONP**

  **定义：**只适用于 GET 请求，通过创建 script 标签发送请求。

  **原理：**利用 sctipt 标签没有跨域限制，在 script 标签 src 属性发送 GET 请求，服务器通过回调函数把数据传给浏览器

  **具体实现：**

  ```
  function handleResponse(data) {
    console.log(data);
  }
  // 动态插入 script 标签
  const script = document.createElement('script');
  script.src = 'http://example.com/api?callback=handleResponse';
  document.body.appendChild(script);
  ```

- **WebSocket**

  WebSocket 是一种双向通信协议，建立在单个 TCP 连接上的持久连接，不受同源策略的限制。可以用于需要跨域的实时数据传输。

  - WebSocket 通过HTTP协议握手 ，但数据传输使用 WebSocket
  - 握手成功后通信直接通过 TCP 连接进行，不受 HTTP 同源策略约束

- **代理服务器**

  使用代理服务器将跨域请求转发到目标服务器

## 浏览器事件机制

### 什么是事件

用户触发的交互动作（文档加载，窗口滚动），这些事件包含了事件发生的相关信息和操作（ event 属性 / event 方法）

**事件模型：**

- **DOM事件模型：**按照一定顺序在页面传播。捕获、目标、冒泡三个阶段。
  - **事件委托：**利用冒泡机制，在父元素绑定程序来处理子元素事件
- **IE事件模型：**
  - 注册事件：`element.attachEvent('onclick', handler)`
  - 没有捕获，只有冒泡

### 事件循环

**定义**：事件循环是**管理异步操作的机制**，可以让 JS 在单线程中执行异步代码而不阻塞主线程

**核心部分**：

- **执行栈：**每当一个函数被调用，就会被推入执行栈，执行结束弹出
- **任务队列：**储存待处理的异步任务（定时器回调、网络请求）
- **事件循环：**不断检查执行栈和任务队列。执行栈为空，则把任务队列中任务取出放进执行栈

**工作流程：在主线程空闲时，将任务队列的任务取出执行，循环操作**

- **执行执行栈同步代码：**函数调用，函数声明，算术操作
- **处理微任务：**比宏任务优先级更高的任务，在当前宏任务执行结束后立即执行，在下一个宏任务执行之前清空微任务队列       `Promise` 的回调、`MutationObserver` 等
- **处理宏任务：**需要在主线程上排队等待的任务      整个 JS 代码，定时器，交互事件，IO操作
- **更新 UI**
- **进行下一轮**

### **事件流**

- **捕获阶段**：**事件由父元素传递到子元素**的过程叫做事件捕获（true）。
- **目标阶段**：在目标节点上触发，称为“目标阶段”
- **冒泡阶段**：**事件由子元素传递到父元素**的过程叫做冒泡（false）。

### 事件委托（事件代理）

**定义**：把子元素的响应事件委托给父元素，让父元素担当事件监听的职务。

**原理**：**事件冒泡**。

**e.target 和 e.currentTarget**

- target 是**触发事件的元素** （ <li>）

- currentTarget 是**绑定事件的元素**  （<ul>）

**使用场景**：在ul上使用事件委托绑定所有li

```
<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  ......
  <li>item n</li>
</ul>
```

**优点**：

- 可以大量节省内存占用，减少事件注册。

**注意事项**：如果同一个dom绑定了两个点事件，一个是捕获，一个是冒泡，那么点击之后会触发两次事件，**先捕获，后冒泡**

**不会冒泡的事件有哪些**

- **`focus`**：获得焦点
- **`blur`**：失去焦点
- **`focusin`**：与 `focus` 类似，但会在元素或其父元素上触发（冒泡），因此这个事件是特例。
- **`focusout`**：与 `blur` 类似，但会在元素或其父元素上触发（冒泡），因此这个事件是特例。
- **`load`**：当图像、音频、视频或其他资源加载完成时触发。例如，在 `img` 元素上触发的 `load` 事件不会冒泡。
- **`unload`**：当页面即将被导航离开时触发。这通常用于执行清理工作，也不会冒泡。
- **`stop`**：通常与 `media` 元素相关，例如 `audio` 或 `video` 元素。这是在媒体播放停止时触发的事件。
- **`readystatechange`**：当 `document` 的 `readyState` 改变时触发。这通常在页面加载时使用。
- **`scroll`**：当元素滚动时触发。这个事件在某些浏览器中可能会冒泡，但在其他浏览器中通常不会冒泡。

### 阻止默认事件和阻止冒泡

- **event.stopPropagation()方法**

不让事件向 document 上蔓延，但是默认事件仍然会执行

- **event.preventDefault()方法**

阻止默认事件，链接则不会被打开，但是会发生冒泡到上一层元素；

- **return false**

同时阻止事件冒泡也会阻止默认事件，等于同时调用了 event.stopPropagation() 和 event.preventDefault()
