# 面试准备

## 1、自我介绍

​	面试官您好，我是王本硕，来自西安邮电大学。我在大一加入了学校的一个软件实验室，了解了各个方向后，结合自己兴趣选择了前端方向进行学习。我先学习了html，css和js，然后选择了React框架并学习了相关知识。学完React后，我比照课程完成了第一个项目——记一笔简易记账平台，并且对平台功能独立进行了一些改进与拓展。之后我与实验室同学合作，协作开发了第二个项目——宅宿甄选，这是一个酒店民宿甄选平台，项目功能较多，较为完善，是由我和另一个前端同学还有两个后端同学合作开发的，我在其中担任前端开发负责人职务。目前项目代表实验室正在参加大学生挑战杯，互联网+等比赛，获得了不错的名次。我热爱前端开发，喜欢结合文档与ai钻研解决问题，了解前端发展新动向，目前希望找到一个实习，通过实践进一步精进自己的技术。以上就是我的自我介绍，谢谢面试官。

​	面试官您好，我是王本硕，来自西安邮电大学。我在大一加入了学校的一个软件实验室，了解各个方向后，结合兴趣选择了前端方向进行学习。我先学习了html，css和js，然后选择了React框架并学习了相关知识。学完React后，我与实验室同学合作，作为前端开发负责人，一起协作开发了宅宿甄选项目，项目参加过挑战者杯、互联网加等比赛，获得了不错的名次。本学期我在智学同行科技有限公司进行了一段为期三个月的实习，这段实习使我进一步磨练了自己的技术，熟悉了企业中实际开发项目的大致流程。我热爱前端开发，喜欢结合文档钻研问题，了解前端发展新动向。以上就是我的自我介绍，谢谢面试官。

## 2、实习介绍

#### 	项目背景

​	在这段实习里我参与的项目是一个整合多种 实用工具与助手的 Web 平台，项目最初以教育学习相关业务为主，比如搜题工具，单词助手等等。而随着生成式ai的发展，它在各种垂直细分领域的应用场景也在越来越多。我们的项目积极顺应时代潮流，在许多业务中也接入了AI，例如ai解题，ai翻译等，围绕生成式AI发展了各种聊天助手、AI工具等新业务，为用户的生活学习工作全方位提供便利。这一部分便是我所参与到的，在其中我主要负责开发了两个AI工具助手的页面。分别是「健康助手」页面，通过对话式交互为用户解决医疗健康相关问题；以及「AI 辩论」页面，用户可以设置正方和反方的观点，交给ai进行辩论。需要我跟您详细介绍一下这两个页面的内容吗吗？

#### 	如果详细介绍

​	好的，首先是健康助手，在这个页面中，用户可以向AI咨询医疗健康相关问题，AI是通过**多agent**模式协作构建的，保证了专业性和严谨性。健康助手通过**对话式交互**，以**流式输出**结合**Markdown格式渲染**的形式快速为用户提供丰富的症状分析、就医指导及保健方案等。健康助手支持**多模态消息**传递，为用户提供了**图片上传**功能，以便于AI根据图片更仔细全面地判断病情，提出建议，上传的图片用户也可以点开进行浏览。健康助手记录着用户的所有**历史会话**，用户可以随时查看过往会话并依照原来话题和AI继续展开对话，也可以删除历史会话或修改会话标题。用户还可选择是否开启**联网搜索**与**本地知识库**，这两个功能都可以有效提升医疗助手的专业性和准确性。

​	接着是AI辩论，在这个页面中，用户可以**设置正方和反方的观点**，交给ai进行辩论，AI会根据不同的辩论角色和立场，模拟真实的辩论场景，提升用户的思辨能力和互动体验。辩论过程分为**立论、质询、驳论、自由辩论和总结**五个环节，正反方ai根据**本方观点与当前环节进行辩论**。AI辩论页面中同样具有**历史辩论列表**查看过往会话的功能。此外，AI输出内容中包含了“**思考过程**”部分，AI会先输出思考过程，思考过程结束后再输出正式回答部分。用户可展开查看思考过程，以便于理解AI的推理逻辑。以上就是我负责开发的两个AI工具助手的大致内容。



**对话式交互**：用户可以向健康助手随时咨询各类医疗健康相关问题，健康助手（AI医生）通过对话式交互的方式，依托AI先进的自然语言处理技术，能够理解用户的提问并给出专业、个性化的解答。在交互过程中，系统采用了**流式输出**机制，AI医生的回复会以“边生成边输出”的打字机模式实时展现，极大提升了用户的沉浸感和等待体验。所有回复内容均支持**Markdown格式**渲染，不仅可以清晰地展示文本，还能美观地呈现列表、表格等丰富内容，便于用户阅读和理解。用户与健康助手的每一次对话，都是通过**WebSocket**实现的实时双向通信，保证了消息的即时性和互动的流畅性。此外还设置了**心跳检测机制**，定时向服务器发送心跳包，确保WebSocket连接的稳定与可靠，避免因网络波动导致的对话中断。



**多模态消息**：健康助手不仅支持文本交流，还实现了多模态消息传递，为用户提供了便捷的图片上传功能。用户在咨询过程中，可以通过直接上传与病情相关的图片（比如体检报告、患处照片等），健康助手在收到图片后，会结合图片内容和用户的文字描述，进行更为精准的分析和建议。图片上传功能基于**AntDesign**的**Upload组件**实现，支持多张图片的批量选择与上传。上传的图片会自动展示在对话输入区上方，用户可以随时预览、删除或重新选择。此外在图片浏览方面，我之前在宅宿甄选项目中封装过一个**图片浏览器组件**用来展示房源图片，在开发本项目时我发现这两个需求大致相同，就在项目中复用了这个组件。用户只需点击任意一张已上传的图片，即可进入全屏浏览模式，支持图片的丝滑切换浏览。图片浏览器底部是**indicator图片指示器**，按顺序展示当前图片与前后六张图片的略缩图，方便用户对上传的所有图片进行详细查看。



**联网搜索和本地知识库**：**联网搜索**是指在用户提问时，AI大模型可以实时访问互联网，检索最新的医学信息、权威文献或相关健康资讯，辅助生成更准确、时效性更强的答案。**本地知识库**是指AI大模型在回答用户问题时，可以调用内置的医学知识库、常见问答、疾病库等本地数据资源。适用于常见疾病、标准诊疗流程、健康科普等内容，保证答案的权威性和一致性。这两个功能在前端的实现方法大致相同，

- 在输入框下方的工具栏区域，有”联网搜索“和“本地知识库”按钮，用户可以手动开启或关闭。

- 其状态由变量控制，点击按钮会切换其值（true/false）。

- 发送消息时，会将 useLocalRag: isUseLocalRag.value 作为参数一同发送给后端，告知AI是否需要联网搜索或参考本地知识库。



**历史会话列表**：是用来展示用户以往的所有对话（会话）记录，方便用户随时回顾、切换、管理历史对话

- 主要实现在左侧侧边栏（.sideMenu）中，有一个“历史对话”区域。
- 会话列表通过 chatList 变量存储，页面加载时会从后端接口获取历史会话数据并渲染出来。

- 每个会话项会显示标题（chat.title），如果没有标题则显示“新对话”。

- 每个会话项右侧有下拉菜单，支持重命名、导出、删除等操作。
- 用户点击左侧历史会话列表中的某一项，可以切换到该会话，查看和继续之前的对话内容。
- 历史会话列表和历史会话的数据都是使用的是二次封装的**axios**进行前后端数据交流的。



**AI辩论**：辩论过程分为**立论、质询、驳论、自由辩论和总结**五个环节。简单来讲，在立论环节双方陈述本方观点和支持的论据，质询环节双方会针对对方的立论漏洞进行攻击，驳论环节回应对方的质疑，自由辩论环节针对核心争议点展开攻防，最后的结论环节进行总结陈词。核心是用状态变量和轮次计数来管理辩论流程，每次发言后自动判断是否切换发言方或推进到下一个阶段，保证辩论流程的有序进行。用户和AI的发言通过输入框和WebSocket/HTTP接口实时交互，整个过程自动流转，界面与流程状态实时联动，带来流畅的辩论体验。



**思考过程**：AIDebate模块的“输出思考过程”功能，是通过前后端协作实现的：后端在每轮辩论中，先通过WebSocket推送AI的推理链（思考过程），再推送正式观点内容，前端将每条消息的思考过程（thinkContent）与观点内容（content）结构化存储，并通过自定义消息组件分开展示，通过折叠面板形式展现推理链，既保证了AI推理的透明可见，也不影响主内容的阅读体验，实现了多轮辩论中AI思考过程的完整输出和友好展示。



​	在这段实习里我参与的项目是一个整合多种 AI 工具与助手的 Web 平台，致力于借助ai解决各种用户需求，为用户的生活学习工作提供便利。在项目中我主要负责开发了「健康助手」和「AI 辩论」两个页面，以及首页的导航气泡。我分别来介绍一下。首先是健康助手，在这个页面中，用户可以咨询医疗健康相关问题，健康助手通过**对话式交互**，以**流式输出**外加**markdown格式渲染**的方式，快速为用户提供丰富的症状分析、就医指导及保健方案等。用户与健康助手的对话是通过**WebSocket**实现的实时双向通信，并通过**心跳检测**保证连接稳定性。而历史记录等数据使用的是二次封装的**axios**进行前后端数据交流，并通过**本地存储localstorage**保存了用户token和对话id。健康助手支持**多模态消息**传递，为用户提供了图片上传功能，借助了**AntDesign**的**update组件**。用户可以将图片上传到对话中，以便于健康助手根据图片进一步判断病情。图片浏览复用了我在宅宿甄选项目中封装的**图片浏览器组件**，用户可以点开对所有上传图片进行浏览。用户还可选择是否开启**联网搜索**与**本地知识库**，结合互联网和本地知识库，可以有效提升医疗助手的专业性和准确性。另一个页面是ai辩论，在这个页面中用户可以设置正方和反方的观点，交给ai进行辩论。辩论过程分为立论、质询、驳论、自由辩论和总结五个环节，正反方ai根据本方观点与当前环节进行辩论。AI回复内容中包含了“**思考过程**”部分，用户可展开查看，以便于理解AI的推理逻辑。此外我还负责开发了首页的导航气泡，鼠标悬浮导航气泡，会在上方弹出两个圆形按钮，点击后分别前往设置和个人中心。点击导航气泡，会弹出一个对话框，框内是用**iframe**嵌入的通过**dify**搭建的智能体。这个智能体可以对用户的问题进行基本的回答，如果有和问题匹配的相应ai工具或助手，会输出相应链接文字让用户跳转到该页面，进一步解决用户需求。

## 3、项目介绍

​	（1）宅宿甄选·酒店民宿甄选平台

​	宅宿甄选平台致力于解决旅游或商务出行人士的住宿选择问题。项目集成了多家住宿平台优质酒店民宿资源，在项目首页中用户可以选择目的城市，然后通过热门、低价、高分等模块向用户展示该城市的优质房源。用户在首页点击更多房源链接，就可以跳转到全部房源页面。这个页面通过**虚拟滚动列表+懒加载**方式向用户推荐目的城市的海量房源，借助**多条件精准查询**为用户提供条件筛选功能，依靠**模糊查询**结合**防抖函数**给用户提供搜索功能，并尝试使用了**React19新API useActionState**优化表单提交过程。还拥有对价格和评分的排序功能。在全部房源页面点击任意一个房源，就可以进入该房源的详情页面。页面中集成了该房源在多家住宿平台的详细信息，如图片、价格、评分、热门评论等。在具体页面中，项目封装了**PictureBrowser**组件，为用户提供了沉浸浏览房源图片的功能。用户如果有心仪的酒店，就可以点击链接跳转到合适的平台进行购买。项目中使用了**路由懒加载**、**图片懒加载**、**React.memo**等方式进行性能优化，大幅提升首屏加载速度。项目使用**axios**进行前后端数据交互，并对axios进行了**二次封装**。未来项目希望结合**媒体查询与rem和Flex布局**实现**响应式布局**。

​	（2）记一笔·简易记账平台

​	记一笔记账平台是我结合React课程实现的一个简易记账平台。用户登陆平台后，可在首页选择日期（通过**AntDesign** 中的 **DatePicker 组件**）查看自己的过往账单，也可在记账页面根据消费类别记录新的收入或支出，还通过**Echarts**实现了一个统计页面，收入支出数据与账单分类数据进行展示。项目还提供了账单收藏功能，通过localStorage进行保存。项目使用了**React-Router6** 的**数据路由**进行路由配置，实现了路由集中式配置与管理。

# 实习

## 1、websocket通信

### （1）简单介绍

​	WebSocket 主要用于健康助手和ai辩论页面的前后端实时通信，实现“打字机”式的AI回复体验。WebSocket 是一种全双工（full-duplex）通信的协议，与传统 HTTP 通信的「客户端发起请求、服务器返回响应、连接断开」的模式不同，WebSocket 在建立连接后可保持通道长连接，客户端和服务器能够彼此主动发送消息，直到其中一方主动关闭。相比传统的HTTP轮询，WebSocket能实现双向通信，解决了 HTTP 长轮询（Long Polling）、轮询（Polling）等方案存在的时延高、资源浪费（需要不断创建/销毁连接）等问题，极大提升了对话流畅度和交互体验，适合实时性要求较高的应用（如即时聊天、在线协作、实时推送等）。在本项目中websocket的连接建立、消息接收与发送、连接中断、心跳机检测和错误重连等机制都有所实现。



### （2）websocket连接建立的大致过程（理论）

​	客户端会先通过一次普通的 HTTP 请求告知服务器“我想把这条连接升级到 WebSocket”，并附带一个用于安全校验的随机值；服务器收到后进行验证并以特殊回应表示同意升级，此时原本的 TCP 连接就从 HTTP 切换到 WebSocket，随后双方即可在同一条持久化连接上进行双向实时通信。 



### （3）项目中websocket的全过程



#### 1、建立连接

​	当进行一个新对话或切换到历史对话时，就会建立一个新的websocket连接，过程是：

- 关闭已有连接并清空心跳机制，防止资源泄漏和重复连接。如果是新消息没有会话id就生成一个

- new websocket初始化一个新的websocket连接（通过ref保存 ref.current来注册事件监听），其中地址是参数化拼接的，包括基础URL，用户id、会话id、角色id、模型id等参数，保证每个连接的唯一性和安全性。

- 注册open message close error事件监听器，为后续消息收发和异常处理做准备

- 当打开新对话或切换到历史对话都会触发**open事件**，如果是新对话，通过send向后端发送一条“初始化对话”的消息，后端会在数据库中为该用户新建一条会话记录（ChatItem），并一个**对话已创建**的消息。并建立新的心跳机制

  (初始化消息如果问起详情)包括

  - type: "chat"：表示这是一次聊天消息（但content为空，属于初始化）。

  - content: ""：内容为空，说明不是用户主动输入，而是系统初始化。

  - 其它如 chatId、roleId、modelId等，都是会话的元信息。

  - imageUrls: []：没有图片。

  - useNetwork、useLocalRag：是否联网、是否用本地知识库。



#### 2、如果问起上边这些id如何获取

基础URL通过getURL函数获取，window.location.hostname得到网站的url

用户id通过getSession函数获取，会从localStorage找有没有session，如果没有就通过定义好的**randString**方法生成一个（问起的话，生成方法就是从0-9和a-z中随机通过for循环结合Math.random随机取值获得一个session）

会话id是如果是历史会话则已经存在，直接拼接；如果是新对话则不存在，通过uuid库的方法重新生成一个

角色id和模型id都是确定好的，因为在这两个页面中的角色和模型都是固定的。



#### 3、websocket接收消息

**消息的接收通过监听message事件进行处理**，返回的**event**点**data**里存在消息type用来区分消息类型，根据type判断不同的返回的消息类型并进行不同的处理。（心跳检测、用户输入、AI回复分阶段等）。分阶段推送消息分片，实现ai回复的流式输出。

- 如果类型是心跳检测就直接跳过消息处理，

- 如果类型是用户输入代表后端将用户输入发送回来进行回显，前端存储消息数组是**chatData**，给chatData追加一个新消息对象，包括id 类型prompt 和用户输入内容content，随后渲染到页面上。不过回显后来不再使用了，改为用户点击发送后直接从前端将新的消息对象追加到chatData数组中。这是因为回显操作虽能保证前后端数据一致，但当前后端通信出现问题时，前端用户收不到后端返回的回显，连自己输入的内容都无法出现再页面上。改为从前端直接追加，当出现网络问题时至少能显示出用户的输入，体验好一些。

- 如果类型是对话已创建，就通过get获取由新对话的历史会话列表，链接由用户id和角色id决定。这里未进行更改，因为历史会话列表希望追求前后端一致性，所以等接收到后端返回的对话已创建的消息后再对chatData进行更新并渲染。

  剩下的是ai回复的输出部分，与ai输出有关的有**start**、**chat**、**end**三种类型。前端存储消息数组**chatData**，当类型为**start**时，代表AI 开始输出，往chatData中push一个**新的消息对象**准备**接收输出内容**，对象包括新消息的**id**（后端传过来的）、**内容**（空字符串）和消息**类型**（reply），并禁用发送按钮和重新生成按钮，启用停止生成按钮。当类型为**chat**时，代表AI正在**输出内容的分片**，将这个内容分片**追加**到当前消息对象（通过id确定）的内容里并重新渲染到页面上。当类型为end时，代表这个消息的结束，启用发送按钮和重新生成按钮，禁用停止生成按钮。



#### 4、websocket发送消息

​	发送消息会触发sendMessage函数，先判断ai是否正在回答或发送内容是否为空（prompt.value.trim.length）。如果没问题，一是将用户输入的内容作为新的消息对象push到chatData中，包括id（前端randString生成的），类型prompt，用户输入内容content，以及已上传图片的URL。二是通过send事件将消息对象发送给后端，里边包含（用户输入的内容，消息类型，会话id模型id和角色id，上传图片的URL，是否使用联网搜索和数据库等）。



#### 5、关闭连接

​	当退出登录，关闭页面，切换对话等操作都会关闭连接，通过触发close事件实现。并将心跳检测清空。



#### 6、错误重连

​	当连接发生错误时会触发error事件，前端会尝试进行重连。具体的过程是，先再外部确定好最大重连次数5次，重连间隔时间3秒；并定义连接次数。每次创建websocket连接时，在open事件触发时都会重置连接次数。如果发生错误时，达到重连间隔时间就会重新调用连接函数，并将重连次数+1。到最后如果重连次数超过最大重连连接次数就不再继续尝试，触发close事件关闭websocket连接，并给用户弹出错误信息。

```js
let socket = null;
let reconnectTimer = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_INTERVAL = 3000; // 3秒

function connect() {
  // ...参数拼接略
  socket = new WebSocket(wsUrl);

  socket.addEventListener("open", () => {
    console.log("WebSocket连接已打开");
    reconnectAttempts = 0; // 重置重连次数
    // 启动心跳、注册消息监听等
  });

  socket.addEventListener("message", onMessage);

  socket.addEventListener("close", () => {
    // 这里一般不自动重连，除非你想支持“意外断开”场景
    // 可以根据业务需求判断是否需要重连
  });

  socket.addEventListener("error", (error) => {
    console.error("WebSocket连接错误:", error);
    // 避免多次重连
    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
      reconnectAttempts++;
      reconnectTimer = setTimeout(() => {
        console.log(`WebSocket重连第${reconnectAttempts}次...`);
        connect();
      }, RECONNECT_INTERVAL);
    } else {
      console.error("WebSocket重连失败，已达最大次数");
      // 可以提示用户“网络异常，请刷新页面”
    }
  });
}
```



#### 7、心跳检测

​	在项目中，每30秒通过send发送一条{ type: "heartbeat", content: "ping" }的消息到后端，并记录一个“等待回应”的状态。后端接收到后，也会返回一个心跳检测的消息{ type: "heartbeat", content: "pong" }代表心跳检测，前端清除“等待回应”状态。如果下次发送心跳包时，上一次的回应还没收到，即仍然处于等待回应状态，就认为连接异常，可以主动关闭WebSocket并触发重连。

​	在连接成功时启动心跳检测，定时发送心跳消息。在连接断开或发生错误时停止心跳检测。

```js
let socket = null;
let heartbeatInterval = null;   // 心跳定时器
let waitingHeartbeat = false;   // 是否在等待心跳回应
const HEARTBEAT_INTERVAL = 30000; // 30秒发送一次心跳

function connect() {
  socket = new WebSocket("ws://yourserver/ws");

  socket.addEventListener("open", () => {
    console.log("WebSocket已连接");
    startHeartbeat();
  });

  socket.addEventListener("message", (event) => {
    const data = JSON.parse(event.data);
    if (data.type === "heartbeat") {
      // 收到心跳回应
      waitingHeartbeat = false;
      // 你可以在这里做一些连接状态的UI提示
    } else {
      // 处理其他类型消息
    }
  });

  socket.addEventListener("close", () => {
    stopHeartbeat();
  });

  socket.addEventListener("error", (error) => {
    stopHeartbeat();
  });
}

function startHeartbeat() {
  stopHeartbeat(); // 防止重复定时
  heartbeatInterval = setInterval(() => {
    if (waitingHeartbeat) {
      // 上一次心跳还没回应，说明连接异常
      socket.close(); // 触发close事件，自动重连
      return;
    }
    // 发送心跳包
    waitingHeartbeat = true;
    socket.send(JSON.stringify({ type: "heartbeat", content: "ping" }));
  }, HEARTBEAT_INTERVAL);
}

function stopHeartbeat() {
  clearInterval(heartbeatInterval);
  waitingHeartbeat = false;
}

// 启动连接
connect();
```

**为何选择前端发ping后端发pong？**

​	1、**客户端主导监测**：只要后端不返回 `pong`，前端就能立即做出重连判断，能够恢复连接。主导权掌握在自己手里。

​	2、项目规范，在之前的项目中有使用到心跳检测都是前端发ping后端发pong

**如何通过后端发ping而前端发pong**

**流程示例**

1. **后端** 每隔固定时间（比如 30 秒）主动向所有已连接的 WebSocket 客户端广播一条心跳消息：

   ```json
   { "type": "heartbeat", "content": "ping" }
   ```

2. **前端** 一旦收到这条 `{ type: "heartbeat", content: "ping" }`，马上返回：

   ```json
   { "type: "heartbeat", "content": "pong" }
   ```

3. **后端** 在发送 `ping` 后，给自己打个“已发送心跳，还在等待 pong”标记；如果在下次期望收到 pong 的时限（比如 5 秒内）没收到前端回来的 `pong`，就默认客户端掉线／断网，直接把 WebSocket 关掉或标记为“失效”，并决定要不要在后端层面进行重连或通知上游逻辑。



### （4）自定义的消息格式是怎样的?

发送消息格式

```json
socket.current.send(
    JSON.stringify({
      type: "chat",	// 消息类型
      content: content,	// 消息内容
      chatId: curChatInfo.value.chatId,	// 会话id
      roleId: roleId.value,	// 使用的角色id
      modelId: modelId.value,	// 使用的模型id
      imageUrls: imageUrls, // 图片URL数组
      useNetwork: isUseNetwork.value,	// 是否使用联网搜索
      useLocalRag: isUseLocalRag.value,	// 是否使用本地知识库
    })
  );
```

返回消息格式

```
type	// 消息类型
text	// 消息内容
chatId	// 消息id
roleId	// 使用的角色id
modelId	// 使用的模型id
```

### （5）轮询、长轮询和websocket的对比

#### 1. 基本原理

**1.1 轮询（Polling）**

- **原理**：客户端以固定的时间间隔（如每隔 1 秒或 5 秒）向服务器发送一次 HTTP 请求，询问服务器是否有新数据。如果服务器有新数据，则在响应中返回；否则返回空或状态标示客户端继续下一次轮询。
- **连接方式**：一个独立的短链接（HTTP 请求-响应）完成一次查询后即断开，下次查询时重新建立连接。

**1.2 长轮询（Long Polling）**

- **原理**：客户端向服务器发起一次 HTTP 请求，如果服务器端暂时没有新数据则保持此请求（不立即返回），直到有新数据可用时才返回响应；客户端收到数据后立即发起下一次长轮询请求，如此循环。相当于“服务端先等数据准备好再回复，客户端收到后马上重连”。
- **连接方式**：与轮询类似，依旧是一次请求对应一次响应，但服务器可以“延迟”响应以减少空回应。每次响应后，客户端重新开启新的连接。

**1.3 WebSocket**

- **原理**：基于 HTTP/1.1 的一次“握手”升级（Upgrade）请求，将连接从 HTTP 协议切换到 WebSocket 协议；握手完成后，客户端与服务器之间建立起一个**持久双向**的 TCP 连接，双方可随时互发消息，无需再次建立 HTTP 请求。
- **连接方式**：一次握手后创建长连接，后续在同一连接上双向通信。

#### 2. 优缺点对比

**3.1 连接建立与开销**

- **轮询**：每次轮询都是一个完整的 HTTP 请求/响应周期（包括 TCP 建立三次握手、TLS 握手（若使用 HTTPS）、请求报头 + 响应报头等）。如果轮询间隔设置得很短（如 1 秒），会产生非常大的网络开销和服务器压力。
- **长轮询**：客户端发出一次请求后，如果服务器暂时没有可用数据，便“挂起”此请求并保持连接一段时间（通常服务端会设置超时时间，如 30 秒）。当出现新数据时立即响应，否则在超时后返回“没有数据”，然后客户端再发起新请求。这样能大大减少“空回应”的次数，但在数据空闲期仍会维持一定数量的长连接。
- **WebSocket**：通过一次 HTTP 握手，将连接升级为 WebSocket。之后无需多次握手，客户端与服务器之间在同一 TCP 连接中互发数据。省去了每次都建立连接和关闭连接的开销，只需传输很少的 WebSocket 报头，即可实现低开销的双向通信。

**3.2 实时性与延迟**

- **轮询**：实时性最差。假设轮询间隔为 5 秒，服务器在第 1 秒左右产生一条新消息，客户端要等到第 5 秒才能下一次请求拿到数据。平均延迟约为 `轮询间隔 / 2`。
- **长轮询**：实时性较好。服务器一有新消息就立即返回响应，客户端马上收到并处理，响应时间仅受网络往返的影响。缺点是客户端收到一次响应后，要重新发起新的 HTTP 请求才能继续“保持等待”状态，这中间会有极短暂的延迟（毫秒级）。
- **WebSocket**：实时性最好。客户端与服务器在同一连接里，任一方随时都能“推送”消息，网络往返延迟几乎与纯 TCP 消息传输相同，没有额外的重连耗时。

**3.3 服务器资源和并发**

- **轮询**：短连接模式，每次请求都创建、处理、关闭连接。若并发用户数高、轮询间隔短，将导致服务器频繁创建/销毁连接，造成 CPU 与内存压力，网络带宽浪费也很严重。
- **长轮询**：每个活跃客户端至少会有一个“挂起”的 HTTP 连接，即使在长时间没有新消息期间也占用一个 TCP 连接。相比轮询，减少了空回应次数，但当用户量极大时也可能出现大量长连接，需要服务器以“异步非阻塞”或“事件驱动”的方式进行优化，防止线程/进程数爆炸。
- **WebSocket**：与长轮询类似，保持着持久 TCP 连接。不同的是，不仅能接收数据，也能主动向客户端推送。服务器需要维护这些持久连接的状态（如每个连接对应的会话、心跳检测等），如果使用不当（如线程模型不合理），并发量大时同样会出现瓶颈。但由于协议层面更加轻量（没有 HTTP 报头的开销），整体吞吐通常更高，更适合持续双向通信。



### （6）axios二次封装

#### 为什么要对axios进行二次封装？

对 Axios 的二次封装主要是为了**统一管理网络请求逻辑**，通过拦截器**全局处理错误提示**、**Token 鉴权**、**处理参数格式**等，减少重复代码；同时规范数据响应结构（如自动提取嵌套数据），**简化api（如get，post）调用方式**（如统一设置参数，统一返回 `[err, data]` 格式），并支持扩展缓存、重试等定制功能，最终提升代码复用性、维护性及项目协作效率。

#### 项目中进行了哪些封装？

**1. 基础配置**

- 动态获取后端 API 域名

设置 getBaseURL() 方法，根据当前前端页面的域名自动切换对应的后端 API 地址，方便在不同环境（如测试、生产）下自动适配。

- axios 全局配置

设置了请求超时时间、基础 URL、跨域携带 cookie、默认请求头（如 Content-Type、Authorization、Chat-Token 等）。

**2. 动态请求头处理**

- 设置 getDynamicHeaderData() 方法，动态获取用户的 token、sessionId 等信息，并在每次请求时自动加到请求头里，保证接口安全和用户身份校验。

**1、对get和post这些api进行了封装**

以get api为例，封装了一个新的get函数来获取各项数据，里边调用axios.get(url, params)方法，参数是请求路径url和和要查询的查询参数params。在then中处理请求结果，通过res.data获取到数据。获取成功就用resolve返回数据。请求失败通过catch接到，用rejected返回一个error。

post情况也类似，调用axios.post方法，传入请求数据与URL，在then中处理数据并返回，在catch中处理错误并返回

**2、对请求拦截器进行了封装**

请求拦截器是通过`axios.interceptors.request.use`，对config赋值实现，每次请求前调用getDynamicHeaderData()方法，自动添加动态请求头。

**3、对响应拦截器进行了封装**

对后端返回的数据进行统一处理，只有 code === 0（即请求成功）时才返回数据，否则抛出错误，方便前端统一处理异常。

## 2、流式输出

### （1）简单介绍

​	在健康助手和ai辩论页面，ai回答用户问题时都是通过流式输出进行回复的，可以让用户体验到ai边生成边输出的效果。所谓流式输出就是大模型在数据尚未全部准备好时，就将生成的部分内容分片不断推送给客户端，客户端接收到一段就立刻渲染，而无需等待服务端完整的输出结果。在我们这个项目中流式输出的实现，具体来讲就是后端与大模型 API 之间，采用**text/event-stream**这种sse服务端主动推送消息的通信形式，让大模型生成每段消息分片都马上返回给后端，后端逐步读取到这些消息分片，通过**websocket**实时推送给前端。前端监听websocket的message事件，每次接收到后端推送来的消息分片，就将其追加到当前 AI 回复的消息中，从而实现了用户能实时看到ai边生成边输出的效果。

### （2）详细讲讲如何接收到消息并渲染到页面上的

​	前端对websocket的message事件进行监听，返回的**event**点**data**里存在消息type，根据type判断不同的返回的消息类型并进行不同的处理。与流式输出有关的有**start**、**chat**、**end**三种类型。前端存储消息数组**chatData**，当类型为**start**时，代表AI 开始输出，往chatData中push一个**新的消息对象**准备**接收输出内容**，对象包括新消息的**id**（后端传过来的）、**内容**（空字符串）和消息**类型**（reply），并禁用发送按钮和重新生成按钮，启用停止生成按钮。当类型为**chat**时，代表AI正在**输出内容的分片**，将这个内容分片**追加**到当前消息对象（通过id确定）的内容里并重新渲染到页面上。当类型为end时，代表这个消息的结束，启用发送按钮和重新生成按钮，禁用停止生成按钮。

### （3）流式输出是否有做防抖或节流来控制渲染频率

​	并没有做防抖或节流。首先，防抖或节流目的是为了**控制高频的操作**以**减轻性能压力**。而对于流式输出，每个内容分片大概几十毫秒返回一次，相对来说渲染的**性能压力并没有那么大**，而且流式输出以**用户体验**优先，追求AI“打字”效果最好越快越流畅，所以并没有进行防抖或节流，每次返回消息分片都**立即渲染**到页面上。

### （4）如何处理流式输出的停止

​	在ai正在生成回复的时候，如果用户**点击停止按钮**，或者是**切换到其他会话**，都会**停止**当前进行的流式输出。具体来讲，项目通过状态变量来控制**是否正在渲染**，在**message**事件中对其进行判断，如果为false就直接结束事件，**不再执行**接下来的渲染过程。当点击停止按钮或切换其他对话时，就会调用**停止函数**，将状态变量设置为false，并向后端通过**webSocket.send**发送**停止生成**的信号，信号类型为stop并包含当前消息id，然后通过**webSocket.close**关闭通信。后端接收到停止生成信息后，立即发送给大模型服务器，让大模型停止继续生成。从而实现了流式输出的停止。

### （5）如何处理输出时的加载效果

​	当ai的最新消息在渲染时，右下角会出现一个**闪烁的小圆点**代表正在加载。这个小圆点通过css动画实现闪烁效果，在开始结束都是opacity: 0，50%（即中间时）是opacity: 1，动画持续时长是1秒，无限重复播放。通过状态变量控制小圆点的**显示**和**位置**，保证其只在**ai输出时**显示，且只在**最新的回复**中显示。

​	（如果详细问怎么实现）：当监听message时，如果event.data.type为start或chat，代表ai回复开始或在进行中，就将控制小圆点显示的状态变量设置为true并保存最新id，通过组间传递传到回复组件中，通过判断确定最新的消息，将小圆点动画渲染出来，从而实现了加载效果。

### （6）markdown格式的渲染

​	在项目中，健康助手的回复支持markdown格式的渲染，从而可以实现**丰富的内容展示**，尤其适合医学报告、结构化表格化建议等，让用户能够一目了然地了解健康助手回复的内容。项目中使用了`react-markdown` 库来实现 Markdown 格式的渲染，支持标题、段落、列表等元素，并通过`remark-gfm` 插件实现了表格的渲染。使用时，通过`react-markdown` 库引入ReactMarkdown标签，被标签包裹的内容就会通过被渲染成markdown格式，标签的属性中有remarkPlugins={[remarkGfm]}，从而将`remark-gfm` 插件加入以实现表格的渲染。



### （7）思考内容如何渲染到页面上

​	与正式回复内容的流程基本相同，思考过程同样被看做是一条对话消息。是根据start，end，think三种类型来判断，当类型为**start**时，代表AI 开始输出，往chatData中push一个**新的消息对象**准备**接收输出内容**。当类型为**think**时，代表AI正在**输出思考内容的分片**，将这个内容分片**追加**到当前消息对象（通过id确定）的思考内容里并重新渲染到页面上。当类型为end时，代表这个消息的结束，启用发送按钮和重新生成按钮，禁用停止生成按钮。

## 3、图片上传

### （1）如何实现的图片上传

**关键点解释**

#### 1、基本组件**`<Upload {...props}>`**

​	组件包含了很多属性和函数

- `name`：指定传给后端的图片参数名。
- `action`：上传地址，即后端接收上传请求的 URL。Upload 组件会把文件以 `multipart/form-data` 的形式 POST 到此地址。
- `headers`：因为后端需要鉴权（如 Bearer Token、Cookie 等）在这里统一设置请求头，这里直接调用request.js文件中设置好的**getDynamicHeaderData**函数动态设置请求头。
- maxCount： 设置最多上传图片数量，项目中为10张
- fileList = {picList} ：把 Upload 的“文件列表属性”与usestate picList数组 关联起来，属于受控模式。这样做可以在 `onChange` 里随时拿到当前所有上传进度、状态、后端返回信息等，并决定如何更新展示。
- `onChange(info)`：上传中、完成、失败都会调用这个函数，`info` 对象包含以下重要字段：
  - `info.file`：代表当前操作的文件对象（包含 `status`、`name`、`uid`、以及后端返回的 `response` 等）。
  - `info.fileList`：当前所有上传中文件的列表（数组）。
  - `info.event`：在上传过程中，如果开启了分片或流式，可以看到更详细的进度条事件。
- `info.file.status`：代表当前状态，可能的状态有
  - `"uploading"`：正在上传
  - `"done"`：上传完成并收到后端响应
  - `"error"`：上传出错
  - `"removed"`：文件被移除



**假如问为什么 “进行中” 会多次调用 `onChange`**

- `<Upload>` 底层其实是通过 `<input type="file" />` 选中文件后，使用 XHR（或 `fetch` + `FormData`）向后端上传文件。
- 浏览器在真正开始上传时，会不断触发 XHR 的 `upload.progress` 事件（每下载/上传一定字节就会发一次），以便前端更新进度条。
- Ant Design 的源码对这个 `progress` 事件做了监听，一旦收到新的进度，就会给当前那条 `file` 的 `percent` 字段“打上新值”，并且把更新后的 `file`（以及新的 `fileList`）传给你在 `onChange(info)` 中的 `info` 对象。
- 因此，当后端正在接收数据、浏览器不断上报进度时，`onChange` 会**随着每一次 XHR 进度事件**被调用一次，而且每次调用里的 `info.file.status` 都是 `'uploading'`，`info.file.percent` 则会逐步从 0 → 100。

简而言之，**“进行中”状态的 `onChange` 触发时机，就是每当浏览器报告上传进度时**。这个次数并不是固定的 “3 次” 或 “5 次”，而是取决于：

1. 你的网络带宽与后端处理速度。
2. 文件大小越大，越多字节被分批上传，浏览器就会触发更多次 `xhr.upload.progress`。
3. 浏览器和服务器之间的握手、分片策略也会影响进度事件触发的粒度。



最基本的用法，仅演示如何上传图片到后端（假设后端上传地址为 `/api/upload`）：

```jsx
import React from "react";
import { Upload, Button, message } from "antd";
import { UploadOutlined } from "@ant-design/icons";

export default function SimpleImageUpload() {
  const props = {
    name: "file",                           // 后端接收文件字段名，例如 req.file 或 req.files["file"]
    action: "/api/upload",                   // 文件上传的后端接口 URL
    headers: {
      authorization: "Bearer token_here",    // 如需鉴权，可在头部加 token；若无可省略
    },
    onChange(info) {
      // info.file.status: 上传状态：uploading | done | error | removed
      if (info.file.status === "uploading") {
        console.log("上传中：", info.file, info.fileList);
      }
      if (info.file.status === "done") {
        message.success(`${info.file.name} 上传成功`);
        // info.file.response: 后端返回的数据（假设后端返回 { url: "http://..." }）
        console.log("后端返回：", info.file.response);
      } else if (info.file.status === "error") {
        message.error(`${info.file.name} 上传失败`);
      }
    },
  };

  return (
    <Upload {...props}>
      <Button icon={<UploadOutlined />}>点击上传图片</Button>
    </Upload>
  );
}
```



#### 2、限制上传格式与大小

在项目中，需要校验用户只能上传指定图片类型（image下边的文件类型）且体积不能超过5MB。我们可以通过 `beforeUpload` 属性在前端先行拦截。	

**详细解释**

1. **`beforeUpload(file)`**
   - 会在文件发出网络请求之前被调用，参数 `file`为上传的文件。
   - 在函数中检查 `file.type`，来判断是否是图片类型文件（file.type.startsWith("image/")）、`file.size`，来检查图片是否小于5MB （file.size / 1024 / 1024 < 5）。
   - 如果返回 `false`，Upload 就会阻止该文件继续上传，并向用户进行提示。
   - 如果返回 `true`，则正常上传。
2. **`accept=".jpg,.jpeg,.png"`**
   - 只让用户在系统文件选择对话框中可见指定后缀的文件，但注意这只是前端“视觉”层面的过滤，让用户选择文件时只出现相关类型的文件，有可能被用户绕过，所以仍建议在 `beforeUpload` 中做二次校验。



#### 3、图片预览功能

用户选图进行上传，上传成功在输入框上方展示缩略图，上传失败显示错误的占位符，正在上传显示进度条。无论那种状态都附带叉号按钮可以将图片删除。核心在于：

1. 从后端获取到返回的文件对象，包括状态、URL、id和百分比，把它存到一个数组里（`picList`）；
2. 让 React 根据这个数组，动态地渲染出一排缩略图；
3. 每个缩略图外层用相对定位，里层是 `<img>`，右上角叠加一个 “×” 图标，点击时从数组里把对应项移除。

**详细说明**：

​	1、首先设置`picList`这个数组来存储每个上传文件的返回结果，数组的对象元素中包括状态status、URL（上传成功才有）、id和百分比percent（上传中才有）

​	2、在onchange事件对应的函数中，根据后端返回的不同的文件状态进行不同处理。

- `"uploading"`：代表正在上传中，通过find方法结合文件id在picList中找到那个文件对象，修改其百分比属性为新的file.percent；如果找不到相应文件代表这是新上传的图片，就给数组追加一个新的对象。
- "done"： 上传成功，后端返回结果中包括图片的URL,在picurls数组中找到相应文件对象并将图片URL和成功状态加进去
- "error"：上传失败，给用户弹出错误，并将失败状态赋值给数组中相应文件对象

​	3、对整个picList进行渲染，也分成三种状态对不同的文件进行渲染。

- `"uploading"`：结合antd库的Progress进度条组件，给Percent属性传入文件对象的百分比属性值，从而实现进度条加载效果。
- "done"： 将URL设置为img图片的src地址，显示缩略图
- "error"：显示一个错误的占位图标



#### **4、上传图片浏览**

​	用户可以对所有成功上传图片进行全屏浏览，我在做自己项目时封装过一个图片浏览器组件，这里需求相同，我就复用了之前封装的组件。给picList数组通过filter根据状态过滤出所有上传成功的图片，传入图片浏览器组件即可。



### （2）如果不使用antd，如何实现文件或图片上传功能？

​	可以使用input表单，表单类型为file，用户点击表单后就可以选择文件。再构造FormData，将用户选择的文件通过append添加到里边。最后把‘formData通过post发送到相应的后端接口，即可实现文件或图片上传。

#### **什么是FormData**

**定义**：`FormData` 是浏览器内置的一个构造函数（Web API），专门用来以 `multipart/form-data` 的格式组织键值对（key/value），其中 value 可以是简单的字符串，也可以是 `File`、`Blob` 等二进制对象。

**作用**：它会自动为你拼装出符合 HTTP “多部分表单”标准的请求体，包括自动生成 boundary（分隔符）并在请求头中加上正确的 `Content-Type: multipart/form-data; boundary=…`。开发者只需把字段（和文件）一一追加进去，最后把整个 `FormData` 对象当作请求体发送即可。



#### **什么是content-type**

**`Content-Type`** 实体头部用于指示资源的MIME类型 media type 比较常用的有数据接口`application/json`，文本`text/css`，图片`image/jpeg`

在请求中 (如`POST`或 `PUT`)，客户端告诉服务器实际发送的数据类型



#### **什么是multipart/form-data**

`multipart/form-data` 是一种在 HTTP 请求中传输“表单数据+文件”时常用的编码格式，主要用于实现文件上传功能。

1. **作用场景**
    当你在网页里有一个带文件输入（`<input type="file">`）的表单，并且要把文本字段和二进制文件（如图片、视频）一起发送到服务器时，就需要用 `multipart/form-data`。相比普通的 `application/x-www-form-urlencoded`（只能传文本），它能把文件分片并打包，让服务器正常解析。

2. **分段边界（boundary）**
    请求头里multipart/form-data后边会出现boundary

   ```
   Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAbCdEf123456
   ```

   `boundary`（分界符）是浏览器随机生成的一段字符串，用来把整个请求体分成若干“段”。每一段对应一个表单字段（可以是普通文本，也可以是文件），每遇到一个 `boundary`，就表示新一段内容开始。浏览器和服务器通过这个分隔符，就能把整块二进制数据拆成若干个独立的字段。

3. **请求体结构**

   - **普通字段**：
      每段最上面有一行 `Content-Disposition: form-data; name="字段名"`，紧接着空一行，然后放字段值。
   - **文件字段**：
      除了 `Content-Disposition` 里有 `filename="文件名"`，还会额外有一行 `Content-Type: 文件MIME类型`（如 `image/jpeg`、`application/pdf`），然后空一行后直接跟文件的二进制内容。

4. **优点**

   - 可以同时上传文本和一个或多个文件。
   - 浏览器自动处理边界，无需开发者手动拼接，只需把字段或文件 `append` 到 `FormData`，然后用 `fetch` 或 `XMLHttpRequest` 发送即可。
   - 后端框架（如 Node.js 的 multer、PHP 的 $_FILES、Java 的 MultipartResolver 等）都能自动识别 `multipart/form-data` 并提取各段数据。

5. **与其他编码的区别**

   - **`application/x-www-form-urlencoded`**：只能发送文本字段，所有数据都会被 URL 编码（例如把空格变成 `+`、把特殊字符变成 `%**`）。
   - **`text/plain`**：将表单内容按纯文本方式发送，根本不常用于文件上传。
   - **`multipart/form-data`**：把每个字段或文件都当成一段，用边界分隔，既能传文本又能传二进制，适合文件上传。



### （3）如何实现大文件上传

​	当大文件上传时，如果直接通过普通文件上传的模式，通过FormData包装上传，很容易上传失败，重新上传又从头开始，非常浪费时间。就算上传成功，下次上传同样的文件又要重新上传，对用户体验也是比较差。
​	为解决这些问题，可以通过秒传+分片上传+断点续传实现大文件上传。

我讲一下**整体思路**

1. 秒传 **计算文件指纹（或者叫Hash值）**
   - 用于“秒传”场景：先在前端对整个文件做一个唯一指纹（如果问：可以通过MD5结合webWorker实现）。
   - 指纹一旦计算出来，向后端查询该指纹是否已存在。如果后端已有该指纹且对应的文件完整可用，则说明后端已经上传过了这个文件，则告知前端可以“秒传”跳过，直接标记上传成功。
2. **分片切片（Chunk）+ 断点续传**
   1. `Blob`它表示原始数据，也是二进制数据，同时提供数据截取的方法`slice`，而 `File`是`Blob`的子类继承了`slice`方法，所以可以利用`slice`方法将大文件分割成若干份文件分片，每个块都有固定大小（比如 1 MB、2 MB、5 MB，或业务可配置），将分片存储起来并设置索引。
   2. 前端先与后端协商、获取哪些块已经上传。
   3. 仅上传未完成的块，并实时记录已成功上传的分片索引。中途若因为网络断开等原因导致上传失败，再次上传时仅需从上次中断处继续上传剩余的块。
3. **并发上传与进度控制**
   - 对每个分片进行并发上传，可以显著提升整体上传速度。
   - 需要对并发数做限流（比如同时上传 3~5 个分片），避免压垮网络或服务器。
   - 在界面上实时展示进度（已上传字节 / 总字节），并兼顾分片重试逻辑。
4. **断点续传状态存储**
   - 例如在前端使用 `localStorage` 临时记录上传进度（已成功上传的分片索引、已完成大小等）。
   - 这样即便页面刷新、浏览器崩溃，也能读取之前的状态，避免重头上传。



如果问：

**为什么要用 Web Worker？**
 浏览器中，主线程（UI 线程）同时负责渲染界面、响应用户操作、执行 JavaScript 等。如果直接在主线程里对一个很大的 `File` 对象做哈希（比如用 SparkMD5 一次性读完整个文件），这段计算会持续几秒甚至更长时间，页面会卡死，用户体验很差。
 Web Worker 相当于一个独立的 JavaScript 线程，它和主线程之间只能通过 `postMessage` 发送消息，互不干扰。我们可以把文件分片后的哈希计算逻辑放到 Worker 里，让主线程保持流畅。

**总体流程**

- 主线程负责把 `File` 对象按固定大小（例如 2 MB）切成若干分片。
- 主线程通过 `FileReader.readAsArrayBuffer` 依次将每个分片读成 `ArrayBuffer`，然后通过 `worker.postMessage` 把这一段二进制数据传给 Worker。
- 在 Worker 里（独立线程），使用增量哈希库（比如 SparkMD5）对每个收到的 `ArrayBuffer` 调用 `.append()`，一直循环累加。
- 当所有分片都发给 Worker 之后，主线程再发一个特殊的“hash 完成”信号，Worker 调用 `.end()` 得到最终的 hash 值，然后通过 `postMessage` 把最终结果回传给主线程。
- 主线程拿到这个最终 hash 后，就可以去调用后端“检查是否已存在”接口。



**并发上传大致思路**

1、设置每个上传批次的分片个数

1. 每次从 所有分片中选出对应的分片，组成一个批次
2. 用 `对批次进行遍历.map(uploadChunk)` 生成该批次的 `Promise` 数组
3. 调用 `await Promise.allSettled(batchPromises)`将所有Promise都上传，等待这批分片都“settle”（无论成功或失败）
4. 本批结束后，把指针往后移 `MAX_CONCURRENCY`，开始下一批
5. 最终，当所有批次都完成，再调用「合并接口」，让后端将所有上传的分片合并起来，形成最终的大文件

## 4、历史会话

### （1）如何获取的历史会话列表数据？

​	在项目的websocket连接中监听的Message事件，返回的**event**点**data**里存在消息type，根据type判断不同的返回的消息类型并进行不同的处理。在打开页面后，会返回一个conversation_created的类型消息，这个消息代表已创建的历史会话。前端得到这个消息后，就向后端通过get获取历史会话列表，拿到后存储起来渲染到页面上。

### （2）如何实现历史对话的切换？

​	在项目中，每个对话都有其对应的独一无二的会话id，通过会话id就可以判断是哪一段对话。切换历史对话时，会触发changeChat函数，将这一历史对话的id传进去。

在函数中

1、如果当前有正在进行的会话，先关闭掉websocket连接，清空心跳检测。然后清空存储当前多轮对话的chatData数组并重置当前对话信息，将其中的id改为历史会话的id

2、通过get将历史会话id传到后端，获取到对应历史会话的多轮消息，将这些新获取到的消息遍历存入chatData数组中，成为当前对话消息

3、将历史会话渲染到页面上，调用函数重新建立webSocket连接

在切换到历史对话后，用户可以接着就之前的话题进行问答。因为AI具有上下文记忆的功能（大模型端本身具有的功能，如果没有这个功能，可以由后端在向大模型发送用户消息时，带上之前几条的历史对话），所以可以无缝衔接，继续讨论之前的问题。



## 5、项目AI简介

------

健康助手是一种多agent协作构建的ai

### 1. 架构与模块划分

项目主要分为以下三大模块，每个模块对应若干个 Agent（智能体）：

1. **用户信息处理模块**
   - **作用**：对用户输入（包括病史描述、症状等）进行结构化、标准化处理，提取关键信息，方便后续推理和检索。
   - **模型选型**：采用 ERNIE Functions-8K-0321 —— 该模型在**结构化输出能力**和**输出格式稳定性**方面表现优异，能够保证批量信息抽取时的准确性和一致性。
2. **诊断推理模块**（双 Agent 协作架构）
   - **推理 Agent**
     - **模型选型**：DeepSeek-R1-Distill-Qwen-14B —— 推理能力较强、推理过程可解释性高，能够针对症状信息给出详细的病因分析。
   - **专科 Agent**
     - **模型选型**：DISC-MedLLM —— 专门针对医疗健康对话场景微调过的大模型，擅长根据患者需求给出“贴合实际”的专家建议。
   - **协作方式**：
     1. 用户信息处理模块提取到的结构化症状数据，先由“推理 Agent”进行初步的病症分析；
     2. 再将推理结果交给“专科 Agent”，结合专业医学知识给出更深入、更具可操作性的诊疗建议。
3. **治疗规划模块**（双 Agent 协作架构）
   - **治疗规划 Agent & 检查 Agent**
     - **模型选型**：都采用 ERNIE-4.0-8K —— 该模型自动对接百度搜索插件，能够实时检索最新医学指南、文献和诊疗规范，保证给出的治疗方案**准确且具有时效性**。
   - **协作方式**：
     1. 先由“治疗规划 Agent” 根据诊断结果和用户需求，制定初步的治疗思路（包括药物、检查、风险提示等）；
     2. 再由“检查 Agent”通过百度搜索插件实时查证或补充最新的检查流程、检查指标、费用估算等信息。

------

### 3. 多 Agent 协作链路的搭建

1. **统一使用百度千帆 SDK**（不主动讲）
   - 因为现有市面上的多 Agent 框架（如 Camel、AutoAgent 等）并不原生支持百度千帆 SDK，所以开发团队借鉴了它们的设计规范（尤其是 Camel 的链式调用逻辑）。
   - 最终搭建了包括：
     - **模型初始化调用**：统一通过千帆 SDK API 装载不同的大模型；
     - **记忆存储**：保存对话上下文、用户偏好等辅助信息；
     - **双 Agent 协作链路**：在一个业务流程里，先调用一个 Agent，获取中间结果后传给下一个 Agent；
     - **RAG（Retrieval-Augmented Generation）工具调用**：结合本地知识库和在线搜索插件，实现“问答+检索融合”的效果。
2. **RAG 工具具体实现**
   - **本地知识库**：使用 Camel 库搭建，内容来源于团队爬取的医学 PDF（指南、论文、临床规范等）。
   - **数据处理**：
     - 用 Pandas 读取 PDF 提取后的文本，将换行、制表符、空格等转义字符清洗干净；
     - 对重要医学术语或章节标题进行分段索引，便于后续检索。
   - **检索流程**：前端发起问题时，后端先根据用户输入的向量化信息在本地知识库中查找相关答案；如未命中或命中置信度较低，则进一步调用百度搜索插件，获取最新在线信息；最后将“本地检索结果 + 在线检索结果”综合传给对应模型，让模型生成最终回答。



## 6、ai辩论

### 1、前端发起辩论请求

- 用户在前端输入辩论主题、正方观点、反方观点，点击“开始辩论”。

- 前端将这些信息（包括主题、正反方观点、辩论ID等）通过 WebSocket 发送给后端。

------

### 2. 后端生成辩论内容

- 后端收到请求后，自动推进辩论流程，根据设定的辩论阶段（如立论、质询、驳论等），让AI分别以正方和反方的身份生成观点和发言。

- 每一轮、每一阶段，后端都会生成当前角色（正方/反方）的发言内容，并标记轮次和角色。

------

### 3. 前端接收并渲染

- 前端通过 WebSocket 实时接收后端推送的每一条消息。

- 每条消息都包含：

- 角色（正方/反方，speakerA/speakerB）

- 内容（观点、发言、思考过程等）

- 轮次（第几轮、第几阶段）

- 前端根据这些信息，将消息渲染到对应的角色和轮次位置，实现辩论流程的可视化推进。

------

### 4. 整体效果

- 用户只需设置主题和观点，后续流程全自动推进。

- 前端只负责收集输入、发送请求、接收消息、按角色和轮次渲染，无需关心AI如何生成内容。

- 整个辩论过程对用户来说是“所见即所得”的。



### 后端如何实现的这一过程

**并不是分开调用两个大模型**

- 不是分别调用两个大模型，而是同一个大模型，轮流以不同角色身份发言。

- 后端会在每一轮，先以正方身份组织 prompt，发送给大模型，得到正方发言；再以反方身份组织 prompt，发送给大模型，得到反方发言。

- 每次请求时，都会带上当前角色的身份、观点、历史发言等上下文，确保大模型能“扮演”好当前角色。

**代码流程**

1.前端发起辩论请求，带上主题、正反方观点等。

2.后端收到请求，进入辩论流程推进逻辑。

3.每一轮：

- 先组装正方的 prompt（包含主题、正方观点、历史发言等），发送给大模型，得到正方发言。

- 再组装反方的 prompt（包含主题、反方观点、历史发言等），发送给大模型，得到反方发言。

- 每次请求都带有 role 字段，告诉大模型“你现在是正方/反方”。

4.后端将每一轮的发言和角色信息推送给前端，前端按角色和轮次渲染。



## 7、白屏问题

白屏通常指的是页面加载过程中，由于各种原因导致用户在一段时间内看到一个空白页面，无法看到预期的内容。

### （1）出现白屏的原因

几种主要的原因：

1、资源加载失败页面依赖的关键资源(CSS、JS、图片等)加载失败,导致页面无法正常渲染。

2、资源加载延迟(或阻塞)，导致页面长时间等待资源加载完成。出现空白。

3、 代码执行中出现未被捕捉的错误，例如JavaScript执行错误，Promise错误等等。导致页面功能无法正常工作，出现空白。

4、浏览器兼容问题 不同的浏览器对于前端技术的支持程度不同，如果我们使用了浏览器不支持的语法或者CSS类型，可能导致某些浏览器无法正常显示页面。

### （2）如何排查白屏原因

#### 1、打开开发者工具（Console/Network）观察

**Console（控制台）报错**

- 通常首要打开控制台，看看有没有语法错误（`SyntaxError`）、找不到模块（`404` 或 `Module not found`）、运行时异常（`ReferenceError`、`TypeError` 等）。
- 如果出现报错，很可能是 JS 执行到某一行出错，导致后续的渲染流程直接中断，让页面显示白屏。

**Network（网络）请求**

- 查看 HTML、JS、CSS、图片等资源的请求状态。
- 如果核心的 `index.html`、`bundle.js`、`main.css` 加载失败（HTTP 404/500），页面肯定无法渲染。
- 注意检查 MIME 类型、CORS、域名配置、路径前缀（尤其是 SPA 部署在子目录时容易出错）。

**在代码中**

- 可以在代码中在一些关键的节点通过colsole.log输出一些关键的变量、参数、对象、数组等，判断流程是否成功
- 可以在react中的使用 Error Boundary，以便在渲染阶段出错时展示兜底 UI，并在 Console 打日志展示错误，避免直接白屏。
- 在关键的节点可以通过debugger添加调试节点，方便在开发者工具中进行调试

### （2）如何监测页面白屏

​	在代码中可以通过一些自动化方案，通过性能监测埋点，对白屏情况进行检测。

**方案一：检测根节点是否渲染+onerror监听**

原理很简单，DOM 一般挂载在一个根节点之下（比如 `<div id="app"></div>` ），发生白屏后通常是根节点下所有 DOM 被卸载。该方案就是通过监听全局的 `onerror` 事件，在异常发生时去检测根节点下是否挂载 DOM，若无则证明白屏。

这种方案，简单直接，直接检测根节点是否渲染完成即可。适用于SPA。SPA页面主要内容通过根节点下的组件渲染,所以监测根节点渲染情况可以判断SPA页面主要内容是否正常渲染。

**方案二：Mutation Observer 监听 DOM 变化**

实现方法：

- 在页面最早能执行的脚本里（比如放在 `<head>` 中的轻量埋点脚本），先定义一个 `MutationObserver` 实例。
- 同时在脚本里启动一个定时器（例如 `setTimeout`，5 秒或 10 秒为阈值）。
- 如果在阈值时间内，Observer 回调从未“认为页面已渲染”（即关键容器依旧空空如也），就可以判定为“疑似白屏”，然后在定时器到点时执行上报逻辑。
- 在回调和定时器中分别调用不同上报方法：
  - **正常渲染**：`reportRendered()` 上报首屏渲染成功的时间点、页面路径等。
  - **疑似白屏**：`reportWhiteScreen()` 上报白屏事件，包括 URL、UserAgent、网络类型、时间戳等。

收到埋点后，后端监控系统可以统计白屏率，并结合 `window.onerror`、资源加载失败等其他埋点进行分析。



一点小问题

同时如果用户长时间未操作DOM，Mutation Observer 监听到一定时间内没有 DOM 变化，就可能会误判为页面白屏。

实际应用中，可以通过一些手段来增加 DOM 的变化，从而避免误判。比如，在页面初始化时，可以在页面中插入一些隐藏的元素，然后定时更新这些元素的样式或内容，从而让 Mutation Observer 监听到 DOM 的变化。另外，一些自动化的数据推送、广告展示等行为也会引起 DOM 的变化，这些行为也可以被 Mutation Observer 监听到，从而避免误判。



**方案三：关键点采样对比**

所谓关键点采样就是在我们的屏幕中，随机取几个固定的点，利用document.elementsFromPoint（x,y）该函数返还在特定坐标点下的 HTML 元素数组。

在获取页面宽高之后，在页面垂直/交叉位置确定多个采样点，通过 [elementFromPoint](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDocument%2FelementFromPoint) 方法获取采样点的元素，然后判断采样点冒泡元素集合的第一个元素是否为容器元素（如标签为body）、加载态元素（例如骨架屏或有loading类名的元素），当存在一定比例（例如超过80%）的采样点元素为容器元素或加载态元素时则可以判定为白屏。



### 白屏优化

**1. 优化 HTML 结构**

- **减少 HTML 文件大小**：压缩 HTML 文件，移除不必要的空格、注释和冗余代码。
- **使用语义化标签**：使用语义化标签（如 `<header>`、`<footer>`、`<article>` 等），提高页面结构的可读性和可维护性。

**2. 优化 CSS**

- **内联关键 CSS**：将关键路径的 CSS 内联到 HTML 文件中，减少首次渲染时的网络请求。
- **使用 CSS 预处理器**：使用 Sass、Less 等 CSS 预处理器，减少重复代码，提高 CSS 的可维护性。
- **压缩 CSS 文件**：压缩 CSS 文件，减少文件大小，加快加载速度。

**3. 优化 JavaScript**

- **异步加载 JavaScript**：使用 `async` 或 `defer` 属性异步加载 JavaScript 文件，避免阻塞页面渲染。

  ```
  <script src="script.js" async></script>
  <script src="script.js" defer></script>
  ```

- **延迟加载非关键 JavaScript**：将非关键的 JavaScript 延迟加载，优先加载关键内容。

  ```
  <script src="non-critical.js" defer></script>
  ```

- **按需加载路由**：将每个页面路由组件，拆成单独的一个个 chunk 文件，这样 main.js 文件体积降低，在首屏加载时，不会再加载其他页面的资源，从而提升首屏渲染速度。

- **减少 JavaScript 文件大小**：压缩 JavaScript 文件，移除不必要的空格、注释和冗余代码。

**4. 优化图片**

- **使用适当的图片格式**：根据图片内容选择合适的格式（如 JPEG、PNG、WebP 等），减少图片文件大小。

- **压缩图片**：使用图片压缩工具（如 ImageOptim、TinyPNG 等）压缩图片，减少文件大小。

- **延迟加载图片**：使用懒加载技术，延迟加载页面中的图片，优先加载关键内容。

  ```
  <img src="placeholder.jpg" data-src="image.jpg" alt="Image">
  ```

**5. 优化网络请求**

- **减少 HTTP 请求**：合并 CSS 和 JavaScript 文件，减少页面加载时的 HTTP 请求数量。
- **使用 CDN**：使用内容分发网络（CDN）加速静态资源的加载。
- **启用 HTTP/2**：使用 HTTP/2 协议，提高页面加载速度。

**DNS 查询优化**

前端侧，可以通过在页面中加入 **dns-prefetch**，在静态资源请求之前对域名进行解析，从而减少用户进入页面的等待时间。如下所示：

```ini
<meta http-equiv="x-dns-prefetch-control" content="on" />

<link rel="dns-prefetch" href="https://s.google.com/" >
```

其中第一行中的 x-dns-prefetch-control 表示开启 DNS 预解析功能，第二行 dns-prefetch 表示强制对 s.google.com 的域名做预解析。这样在 s.google.com 的资源请求开始前，DNS 解析完成，后续请求就不需要重复做解析了。

**通过骨架屏或loading进行优化**

在未加载出来时展示骨架屏或loading，以提高用户体验

**借助webWorker**

Web Worker 相当于一个独立的 JavaScript 线程，它和主线程之间只能通过 `postMessage` 发送消息，互不干扰。我们可以把文件分片后的哈希计算逻辑放到 Worker 里，避免阻塞主线程加载，让主线程保持流畅。



## 8、项目中为什么不使用redux

### 1. 状态管理需求较简单

AI 对话页面的核心状态一般包括：

- 当前用户输入（input）

- 聊天记录（messages/history）

- 加载状态（如“正在生成回复”）

- 可能的错误提示

这些状态大多只在当前页面内使用，不需要在多个页面或组件间频繁共享。

------

### 2. 组件层级较浅，数据流简单

- 聊天页面通常结构简单，父组件（如 ChatPage）下有输入框、消息列表等子组件。

- 父组件用 useState 就能轻松管理所有状态，并通过 props 传递给子组件。

- 不存在跨页面、跨模块的数据同步问题。

------

### 3. 状态变化逻辑不复杂

- 聊天记录的增删改查、输入框内容的变化、loading 状态切换等，都是局部、同步、简单的状态变更。

- 不需要复杂的异步状态管理（如多个接口并发、全局 loading、复杂的业务流转等）。

------

### 4. 性能和开发效率考虑

- Redux 引入后会增加样板代码（actions、reducers、store 配置等），对于简单页面反而拖慢开发效率。

- 直接用 useState/useReducer/useContext，代码更简洁，维护成本更低。

------

### 5. 未来扩展性

- 如果后续项目变复杂，比如加入多页面、用户系统、全局主题、通知等，可以再考虑引入 Redux。

- 但对于单页面、单功能的对话应用，React 自带的状态管理能力完全足够。



## 9、实习中有遇到什么困难吗，最后是怎样解决的

​	有的，例如在实现图片上传功能时，除了借助AntDesign的upload组件实现了上传，还需要实现在输入框上方对上传图片的结果进行预览，以及浏览上传图片的功能。而这两个需求直接通过antd提供的方案难以完美实现。例如对图片上传结果进行预览，antd提供的照片墙方案较为简陋，形式上也不符合我们项目中输入框底部点击上传按钮，输入框上方展示图片的模式。所以考虑之后，我决定自己封装图片预览组件。我先和后端同事讨论，确定好返回的参数，包括状态、URL（成功返回）、id和进度（上传中返回），把所有返回结果存到一个数组（`picList`）；然后根据不同的状态渲染出一排不同结果的缩略图，成功渲染图片URL，失败是一个错误占位符，正在上传借助antd的progress组件与进度渲染出进度条；每个缩略图用定位在右上角叠加一个叉号图标，点击后就从数组里把对应项移除。此外，对于浏览上传图片功能，antd的方案仅能实现单个图片浏览，如果用户上传了多张图片，还需要退出重新点击另一张图片进行查看，用户体验较为麻烦。我在自己的宅宿甄选项目中曾经封装过图片浏览器组件，可以随意丝滑切换图片，底部还有图片指示器方便用户浏览。对比后我发现这两个项目图片浏览需求基本一致，于是我将自己的组件复用到了实习项目中，效果很不错。以上这就是我遇到的困难和解决的过程。



## 10、实习中有什么收获

​	在实习中，我首先了解到了参与到一个真实的企业项目开发的大致流程，有了实践的经验。也了解到了彼此间如何协作开发，进一步掌握了git的使用，并锻炼了我的沟通交流能力。参与到实际项目中的代码开发，也使我的技术进一步熟练。此外，我在项目中也学到许多之前没有用过的新知识新技术，并进行了实际应用，如webSocket的使用以及图片上传等功能的实现等等，拓宽了我的知识面。总的来讲收获很多。



## 11、项目的开发流程是怎样的？

​	开发流程的话，我实习的公司比较小，人也比较少，开发流程可能没有那么完整。我们项目使用的是阿里云的云效进行代码管理的。首先如果要开发一个新业务，需要开一个新的分支，在这个分支中进行开发。开发完之后，从本地验证没问题了，就发起合并请求。随后带我的老师会大致审阅一下我的代码有没有问题，看出来的问题就进行修改，没有的话就合并到dev分支中，并手动触发流水线，部署到测试网站上。在测试网站上我会和测试人员一起使用功能看看有无我没发现的问题，或者是生产环境与开发环境不同造成的问题，如果发现有问题就修改再重新测试。直到测试没问题后，代码就从dev分支合并到master分支中，触发对应的流水线部署上线。



## 12、有没有测试出现的问题，是如何修改的？

​	有的，有时会因为生产环境和开发环境不同造成问题。比如我在开发首页的导航助手悬浮球功能时，在本地实现很成功，但部署到测试网站中始终不显示。后来排查了很久发现是由于登录鉴权的问题。悬浮球只有在用户登录后才会显示，这需要登录鉴权来实现。项目在用户登录后会往localstorage中传递token，未登录时不存在token。所以我通过getItem加if条件判断检测是本地存储中是否有token这一项，有就显示，没有就不显示，从而实现登录鉴权。但生产环境和开发环境中，后端返回的token名称不一致，我在代码中if对比的是开发环境的token名称，在生产环境中没有这一项，所以不会显示。修改很简单，把对比的token名改成生产环境的token名就可以。



其他问题比如：在实现切换历史会话功能时，一开始只考虑到静态时的操作，未考虑到AI正在输出时点击切换的问题。自己测试时发现AI正在输出时，由于上一个对话的webSocket未关闭，有时会出现消息串台的问题，在当前会话中输出另一会话的内容。所以马上进行了修改，给切换会话的函数最开始就加上关闭WebSocket和清楚心跳检测的代码，并在输出时加上判断会话id是否一致的条件，从而解决了问题。

# 项目

## **1、虚拟列表+懒加载**

### （1）简单介绍

在项目的全部房源页面中，会向用户展示目的城市的**海量房源**。如果一次性将这些房源全部渲染出来，可能会导致加载时间过长，房源dom元素过多导致页面卡顿等**性能问题**，所以考虑使用虚拟列表+懒加载实现。

一开始是单纯使用的懒加载，当用户滑动到**靠近列表底部**时，就重新向后端**请求新的数据**并**添加到列表**中再**重新渲染到页面**上。这样由于开始页面中的房源dom很少，所以能够大幅减少首屏加载时间。但如果用户一直向下滑，加到页面中的房源**dom会越来越多**，最后还是会降低性能，造成页面卡顿等等。

所以后来考虑使用虚拟列表+懒加载的方式，同样是接近列表底部请求，区别在于虚拟列表只渲染数据列表中**当前页面以及附近两页**的房源dom，不论列表中有多少数据，都只渲染**有限的一部分**，所以可以避免页面卡顿等性能问题。多渲染两页dom，可避免滑动过快还未渲染，出现白屏。

### （2）具体如何实现的虚拟列表

1、设置**开始索引**和**结束索引**，代表列表**开始渲染的位置**和**结束渲染的位置**。设置**预留两屏的item数**（容器可视高度除以item高度乘五（一行有五列）），然后通过**已划过距离scrollTop**除以单个房源item高度再乘五就是已划过的item数，再减去预留数，得到开始索引，默认是0（通过Math.max(0,上边的操作)）。通过已划过距离scrollTop加上可视区域高度offsetHeigh以单个房源item高度再乘五，再加上预留数，得到结束索引。

2、通过**slice截取到数据列表**中的从开始索引到结束从索引的部分，在页面中进行渲染。

3、还需要计算通过开始和结束索引计算**顶部块**和**底部块**（如果结束索引比列表还长就是0）的高度，用来**撑开进度条**

4、如果划到了靠近列表底部（总高度scrollHeight-已划过距离scrollTop-容器可视高度<距离阈值），就触发请求函数，重新向后端请求数据并加到列表后边

### （3）为什么使用节流函数，起到什么作用

滚轮滚动可能会触发多次滚动事件，造成不必要的性能消耗，快速滚动也可能造成白屏问题。所以考虑采用节流函数来减少滚动触发的次数。

一开始采用的是防抖函数，防抖函数的作用就是短时间内触发多次事件，只执行最后一次，可以有效减少滚动触发的次数。但是在实际操作时出现问题，如果快速滑动滑轮，会导致房源item未渲染出来，页面出现白屏。分析后发现是由于滚动时页面会向下划，但由于速度过快，未达到防抖函数要求的时间，所以防抖函数并未执行，页面未重新渲染，导致白屏问题。

随后改用节流函数，节流函数的作用是触发一次在短时间内就不再次触发，从而既有效减少了滚动触发的次数，由于每次都会成功执行节流函数，也实现了及时渲染，从而顺利解决了白屏问题。



### **（4）如何优化快速滚动时的白屏问题？**

**考察点**：性能优化经验
**解答**：

1. **节流渲染**：使用 **节流函数** 控制滚动事件触发频率。

2. **占位符**：图片未加载时用**骨架屏**填充，提高用户体验。

   骨架屏方案，通过isPending判断是否处于请求中，返回为pending就渲染骨架屏，请求结束就渲染请求到的图片

3. **加载符**：如果滑倒列表底部请求新数据还未返回，同样是通过pending来判断，渲染`加载中...`的盒子，请求结束就渲染新item

### （5）使用**Intersection Observer**

**Intersection Observer** 方案优势：

- 原生API，简化可视区域判断逻辑。
- 自动检测，减少手动计算误差。

**局限性**：

- 兼容性问题（部分旧浏览器不支持）。
- 大量元素监听时性能开销较大（需配合虚拟列表减少节点数量）。

**结论**：结合两者，用虚拟列表控制DOM数量，用Intersection Observer实现了图片懒加载细节。

### **（6） 如何处理动态高度的元素（如高度不固定的图片或文本）？**

**考察点**：复杂场景的解决方案
**解答**：
动态高度需实时测量并缓存，常用方案：

1. **预估高度+惰性测量**：初始用预估高度渲染，元素进入可视区域后测量实际高度，更新缓存并调整布局。
2. **位置缓存表**：维护一个 `positions` 数组记录每个元素的真实高度和偏移量，重新计算后续元素的位置。
3. **ResizeObserver API**：监听元素尺寸变化，动态更新缓存。

**优化**：对已测量的元素跳过重复计算，使用二分查找快速定位滚动位置。

### **（7）如果列表项包含复杂组件（如视频），需要注意什么？**

**考察点**：实际应用细节
**解答**：

1. **组件销毁**：离开可视区域时销毁视频播放器，释放内存。
2. **状态保存**：使用 `keep-alive` 或缓存组件状态（如播放进度）。
3. **懒加载分级**：先加载轻量内容（如缩略图），用户交互后再加载完整资源。
4. **性能监控**：确保单个复杂组件不影响整体滚动性能。

### **（8） 如何测试虚拟列表+懒加载的准确性和性能？**

**考察点**：质量保障意识
**解答**：
**准确性测试**：

- 快照比对：确保不同滚动位置渲染内容正确。
- 交叉验证：手动滚动到特定位置，检查渲染数据与预期一致。

**性能测试**：

- **Chrome DevTools**：通过Performance面板分析FPS、布局重绘（Layout Thrashing）。
- **内存占用**：Memory面板检查是否存在内存泄漏（如未销毁的DOM节点）。
- **大数据压测**：渲染10万条数据，监控滚动流畅度（FPS≥50）。

**自动化工具**：

- Puppeteer模拟滚动并截图对比。
- Lighthouse生成性能报告。

## 2、模糊查询 多条件精准查询 useActionState 排序 防抖函数

#### 简单介绍：

**（1）搜索功能**

在项目的全部房源页面中，有着搜索功能，可以在输入框中输入想要查询的字符串，点击搜索按钮后就可以匹配到标题中有相应字符串的房源渲染在页面上，这个过程通过模糊查询实现。在搜索框输入时还会有一个下拉菜单，可以根据输入值实时显示匹配到的前五条房源标题，也是应用到了模糊查询，同时还做了防抖处理，防止高频输入造成多次渲染的性能问题。

**（2）条件筛选功能**

在项目的全部房源页面中，有条件筛选功能，可以根据人数、价格、位置条件来筛选房源。通过多条件精准查询来实现这一功能。

### （1）模糊查询简单介绍

全部房源页面中有搜索功能，可以匹配并渲染出标题中有搜索字符串的房源item。搜索功能主要应用到了模糊查询。模糊查询的基本原理是对房源数据列表通过filter进行遍历，对每个遍历到的item取标题，通过includes判断标题中有没有要搜索的字符串，有返回的就是true，item添加到filter得到的新数组里边。搜索时还具有搜索建议功能，使用onChange根据表单的输入值，通过下拉菜单实时展示出通过模糊搜索匹配到前五条的房源标题。

### （2）多条件精准查询简单介绍

全部房源中页面中有筛选功能，可以按照人数，价格，位置条件对房源item进行筛选。条件筛选功能应用到了多条件精准查询，基本原理也是对房源数据列表通过filter进行遍历，对每个遍历到的item取到人数，价格，位置这些属性，与条件进行比较，再对比较结果进行短路判断，如果都返回true的才返回到filter新数组内（短路判断时将高淘汰率的条件（如位置）放在判断逻辑前端，快速跳过不符合项）。

### **（3）useActionState**的尝试使用

在全部房源页面的代码中，存在搜索框、人数、价格、位置等多个表单元素，需要通过**useState**设置**多个状态变量**来保存并操作这些表单的内容，比较繁琐。之后了解到react19新api `useActionState`的更新，可以更好地**控制表单的action状态**，无需多个状态变量，于是尝试使用在了项目内。

`const [state, action, isPending] = useActionState(fn, null)`

`useActionState`有两个参数，第一个是**处理表单提交内容的回调函数**，第二个是初始值。回调函数由两个参数**prevData**（之前的表单数据）和**formData**（现在的表单数据）。可以得到通过formData参数得到各个表单的内容，通过**formData.get('表单名')**就能得到相应表单的内容。在项目中我先得到各个表单的内容，再**传入筛选函数**（通过filter进行模糊查询和精准查询的函数），最终筛选后的数组**返回出去**。

`useActionState`有三个返回值，第一个返回值是执行回调函数后**返回的状态**，在项目中就是返回的**筛选后的新数组**。第二个就是返回值action函数，react19更新后form的action属性可以**绑定要执行的action函数**，绑定后表单就可以执行相应的函数（相当于给之前的onSubmit加上以后个handle什么什么)。第三个返回值是判断表单提交**状态的isPending**，为做到在action函数**执行时无法再次提交**，通过isPending判断**button按钮是否禁用**（添加disabled属性），如果函数中有异步网络请求，这个功能更加有用。

这几个表单元素都是提交后获得的，所以使用useActionState。

### （4）排序的实现

通过一个状态变量来保存是通过价格还是评分进行排序。然后向后端发送请求，过程中设置isPending状态变量处理请求状态，请求状态中渲染一个蒙层到页面上。不使用useActionState是因为希望一改变状态变量就请求，而useActionState是提交后才执行，所以不使用。

### （5）防抖函数

在搜索框输入时，会展示一个搜索建议的下拉表单，包含前五条根据当前搜索字符串匹配到的房源item的标题，通过onChange获取搜索字符串。为解决高频输入时的性能问题，通过防抖对函数进行包裹，只在最后一次触发后才执行，解决了问题。



### 问题1：为什么不通过后端实现

这个项目是和实验室后端的同学一同配合实现的，做到搜索和筛选功能呢时后端的同学已经出去实习了，没时间再做搜索和筛选的接口，所以退而求其次选择从前端实现。当然从后端实现肯定是更完美的方案，因为项目使用的是懒加载，所以数据列表中只有已经请求到的房源数据。将搜索字符串和条件都传到后端，再由后端从全部房源数据中进行筛选，肯定是更合适的。

### 问题2：**多条件筛选采用`filter`链式遍历，如何保证多条件组合查询的效率？**

1. **短路判断**：将高淘汰率的条件（如位置）放在判断逻辑前端，快速跳过不符合项
2. **条件变化监听**：仅当筛选条件变化时重新计算，避免重复执行。具体实现是通过回调函数的第一个参数prevData可以保存上一次的表单提交的内容，与本次进行对比，如果相同就直接返回上一次过滤后的数据即可。

### 问题3：**搜索建议如何实现？**

在输入框输入时，会触发搜索框的onChange事件，给事件绑定上了函数来设置状态变量并调用模糊查询，将前五条匹配到的房源标题渲染到下拉菜单里边。这个过程中使用了防抖函数来控制快速输入的情况。（不使用useActionState是因为不是提交而是实时改变，所以要用onChange）

### 问题4：**如何处理用户输入的特殊字符或SQL注入风险？**

1. **前端过滤**：对搜索输入进行清理（如移除`<script>`标签）

```
const cleanInput = input.replace(/[<>]/g, '') 
```

**2.使用CSP **

CSP 通过设置HTTP 响应头，**限制浏览器只能加载指定来源的资源**，从而防御 XSS 攻击和数据注入。主要防护能力包括：

- 阻止未经允许的内联脚本（`<script>`标签）
- 禁止加载外域恶意脚本
- 阻止未授权的资源加载（图片、字体等）
- 禁用危险的 `eval()` 等函数

### 问题5：如何控制下拉菜单的显隐

设置一个状态变量来控制，当光标位于搜索框时（通过onFocus）设置为true，点击到搜索框外部时（通过e.target.closest('盒子类名')得到点击的是哪个盒子）就设置为false，通过短路逻辑判断是否显示。

### 问题6：如果一个item里有多种类型房间怎么办

1、通过useSelector获取到数据列表

2、对数据列表进行map遍历，并对每个item通过filter对房间进行筛选，获得返回符合条件的房间的数组，并重新设置item对象，修改房间属性为新数组。

3、对数据列表进行一次filter遍历，将不符合条件的酒店item过滤出去（item.rooms.length需要大于0），并将过滤后的数据列表保存到redux中。

4、点击房源item时，通过过滤后的数据列表将房间信息传进去，保证只有符合条件的房间。

## 3、防抖与节流

### 一、防抖（Debounce）

#### **核心思想**

是一个**延迟执行函数，直到事件停止触发后的经过指定时间间隔才执行**。如果在这段时间内事件再次触发，则重新计时。

#### **底层原理**

1. **闭包保存状态**
   通过闭包保留定时器变量（`timer`），避免全局污染。
2. **事件触发机制**
   每次事件触发时，先清除之前的定时器，再创建新的定时器，实现“重置延迟”。
3. **时间窗口控制**
   利用 `setTimeout` 延迟执行目标函数，时间窗口内重复触发会不断重置倒计时。

#### **代码实现（基础版）**

```
function debounce(func, delay) {
  let timer; // 闭包保存定时器
  return function(...args) {
    clearTimeout(timer); // 清除旧的定时器（每次执行的是这个函数，所以timer是旧timer）
    timer = setTimeout(() => { 
      func.apply(this, args); // 延迟执行
    }, delay);
  };
}
```

#### 实现步骤：

1、参数为包裹的函数与延迟时间

2、定义一个定时器，通过闭包保存

3、返回一个函数，每次执行先清除旧定时器

4、将新的定时器绑到timer上，延迟执行

#### **典型场景**

- 输入框实时搜索（用户停止输入后发送请求）
- 窗口 resize 事件（调整结束后计算布局）

------

### 二、节流（Throttle）

#### **核心思想**

**固定时间间隔内只允许函数执行一次**。无论事件触发多频繁，执行频率都会被严格控制。

#### **底层原理**

1. **时间戳**
   
   记录上次执行时间戳，对比当前时间决定是否执行。
   
2. **状态锁机制**
   通过闭包保存“是否可执行”的状态（如 `lastExecTime` 或 `timer`），避免重复触发。

#### **代码实现（时间戳版）**

```js
function throttle(func, interval) {
  let lastExecTime = 0; // 闭包保存上次执行时间
  return function(...args) {
    const now = Date.now();
    if (now - lastExecTime >= interval) { // 时间间隔外触发则执行
      func.apply(this, args);
      lastExecTime = now; // 更新时间戳
    }
  };
}
```

#### 实现步骤：

1、参数为包裹的函数与锁定时间

2、定义一个变量保存上次执行时间，是一个闭包

3、在返回函数中得到当前时间戳

4、如果当前时间减去上次执行时间大于锁定时间，就重新执行并更新时间戳



## 4、PictureBrowser组件

### 简单介绍：

在房源的详情页面中，封装了一个PictureBrowser这么一个图片浏览器组件来帮助用户更好地浏览房源图片。点击**显示更多照片**后，就可以进入到图片浏览器。右上角是一个**叉号**，点击就可关闭图片浏览器。图片浏览器**中央是一张房源图片**，**左右两边是箭头**，点击箭头图片就会**向前或向后切换一张**。切换时通过**第三方库 react-transition-group**对图片**传入传出动画效果**进行优化。图片下方是**indicator图片指示器**，按顺序展示当前图片与附近的六张图片（一共七张，都是略缩图），其他图片都用阴影覆盖。点击箭头后，图片指示器也**跟着切换图片**。当前图片位于房源图片列表**首或尾**时，图片指示器**按照顺序切换位置**，位于图片列表**中间**时，切换的图片**始终位于图片指示器中间**。而**点击图片指示器**中的图片，中央展示的图片就**切换到相应图片**，图片指示器的切换遵循之前同样的逻辑。由于逻辑较复杂，所以又封装了一个indicator组件来实现这一功能。图片浏览器中还有一个选择指示器显示与否的按钮。以上就是图片浏览器的大致功能。

### 问题1：如何通过react-transition-group优化动画效果

1、通过状态变量保存点击的是左箭头还是右箭头，点击箭头就会触发函数进行设置，并将新图片重新渲染上去

2、通过react-transition-group中的CSSTransition组件将图片包裹，设置单一盒子的动画效果。

内部属性：in来控制动画触发与否，key确保多个组件切换时都有唯一标识，classNames设置类名，timeout设置动画时长

动画的样式：根据CSSTransition属性确定的类名决定，直接在`类名-enter/类名-exit`设置开始动画效果，`类名-enter-active/类名-exit-active`设置结束的动画效果，结束样式中要包括transition设置过程，如transition: all 200ms ease，代表动画效果200ms，先慢后快后慢。

3、使用SwitchTransition标签处理两个组件之间切换的过程。通过mode属性来控制切换方式，"out-in": 当前组件先退出，新的组件再进入。"in-out": 新的组件先进入，当前组件再退出。子组件必须使用 CSSTransition 或 Transition，并确保 key 属性唯一。

### 问题2：React Transition Group（RTG）相比原生 CSS 或 JavaScript 动画方法，在 React 生态中有以下核心优势：

------

#### 1. **组件化生命周期管理**

RTG 提供 `Transition`、`CSSTransition`、`SwitchTransition` 等组件，**无缝集成 React 的生命周期**。

- 自动处理组件挂载（mount）和卸载（unmount）的时序问题。
- 原生方法需要手动用 `setTimeout` 或 `useEffect` 控制 DOM 元素的移除时机，容易导致动画未完成元素就被销毁的问题。

------

#### 2. **解决组件卸载动画难题**

原生 CSS 无法直接处理组件卸载时的动画（如元素消失的 `exit` 动画），因为 React 会立即移除 DOM 节点。

- RTG 通过**保留 DOM 节点直到动画完成**（如 `exiting` 状态结束后），确保退出动画能完整播放。

------

#### 3. **声明式 API 与状态驱动**

通过 `in` 属性控制动画状态（进入/退出），**状态变化自动触发动画流程**。

- 原生方法需要手动添加/移除 CSS 类或操作 DOM，代码冗余且易出错。
- 示例：通过 `in={isVisible}` 即可触发元素的进入/退出动画流程。

------

#### 4. **跨动画库兼容性**

RTG **不依赖具体动画实现**，可自由搭配 CSS、GSAP、Anime.js 或 React Spring。

- 原生 CSS 动画需硬编码 `@keyframes` 或类名，灵活性低。
- 示例：用 `CSSTransition` 直接绑定 CSS 类名，或用 `Transition` 结合 JS 动画库。

------

#### 5. **复杂场景简化**

- **路由切换动画**：通过 `SwitchTransition` 实现组件切换时的平滑过渡。
- **列表动画**：结合 `TransitionGroup` 管理动态列表项的增删动画，避免手动跟踪每个元素的 key 和状态。

### 问题3：**Indicator 的滚动策略如何实现**

滚动策略的核心是 **视口居中算法**

1、所有图片都放在一个盒子的内容中，盒子展示区宽度固定，改变的其实是盒子内容的位置，默认图片从第一个开始，盒子所以在最右边。

2、图片切换后，得到新图片的索引，从而获取到图片对应的宽度clientWidth和离左侧父盒子边缘距离offsetLeft。

3、获取到盒子显示区的长度和内容长度，通过**左侧距离+盒子本身宽度*0.5-显示宽度**计算出距离，得到要盒子要移动到的位置，从而使得当前图片居中

4、如果位于头部，计算出距离会小于零，这种情况就不移动盒子。同理如果位于尾部，计算出距离会超过盒子内容宽度，同样也不移动盒子

## 5、前端优化方法

### 1、路由懒加载

**传统问题**：所有路由组件打包到单一JS文件，导致首屏加载缓慢，

**作用**：通过路由懒加载将应用拆分为按路由分割的代码块，初始仅加载核心框架，仅在用户导航到对应路由时才会加载相应资源，可以减少初始加载体积，大幅提高首屏加载速度。

**如何使用**：在react中，通过lazy实现懒加载。用Lazy将一个导入组件的箭头函数包裹起来，用Suspense组件来处理路由导入过程中的加载过程，如果请求状态是pending就通过fallback属性来渲染加载过程中显示的内容，在我的项目中是在路由切换过程中显示一个白色透明蒙层。

**底层原理**：实现路由懒加载的底层原理主要依赖于**代码分割**与**动态加载**技术，其核心思路是把整个应用拆分为多个独立的代码块（chunk），只有在用户真正访问某个路由时才加载对应的代码，从而减小初始加载包的体积，加快首屏渲染速度。下面是具体的原理和步骤：

1. **代码分割**
    使用打包工具（如 Webpack、Rollup 等）将应用按路由或功能模块拆分成多个独立的代码块。这样每个路由对应的组件和依赖会被打包到单独的文件中。
2. **动态导入（Dynamic Import）**
    利用 JavaScript 的 `import()` 函数实现动态加载。例如，当用户导航到某个路由时，路由配置中会触发动态导入操作，返回一个 Promise，等待模块加载完成后再进行渲染。
3. **缓存机制**
    一旦动态加载成功，对应的代码块会被缓存（通常浏览器层面已经缓存该文件），避免重复请求，提高用户体验。

### 2、图片懒加载

**简单介绍**：

在全部房源页面里，存在大量带图片的房源item，如果直接加载所有图片，肯定会造成性能问题，给用户带来较差体验，所以采用图片懒加载的方式。

**实现过程**：

房源 Item 组件中，整体房源信息（如标题、价格和加入购物车按钮）直接渲染，而房源图片则交由 LazyImage 组件处理，从而实现按需加载图片，提高页面加载效率。

LazyImage 组件内部使用了 React 的 **hooks**（useState、useEffect 和 useRef）来管理**图片加载状态**。组件首先通过 **useRef** 获取图片 **DOM 元素**，并用 useState 管理图片**是否加载完成（isLoaded）**和图片**是否加载失败**（**hasError**）的状态。核心部分是利用 **Intersection Observer** API 监听图片元素是否**进入视口**。开始时为所有图片元素加上观察，当检测到图片元素的**可见度超过设定的阈值**（threshold 0.1）时（即进入视口），就会将图片的datasrc中的图片地址赋值到src中，从而加载图片，并结束观察。如果图片加载成功，触发img元素onLoaded事件，更新加载状态为true，让真正的图片得以显示；如果加载失败，则触犯onError事件，将错误状态置为 true，并展示相应的错误提示。

在图片加载未完成的期间，组件使用 **antd** 的 Skeleton.Image 显示**骨架屏**，作为占位效果，以提升用户体验。只有当图片加载成功时，真实的图片才会被展示，并且通过 CSS 样式设置为覆盖整个容器，同时保证了图片自适应布局。通过这种设计，不仅有效地降低了页面初始加载的压力，也能在加载过程中提供良好的视觉反馈和错误处理。

#### 使用**Intersection Observer** 的好处是什么？

- **作用**：监听目标元素与父容器（或视口）的**交叉状态变化**（如元素进入/离开视口）。
- **优势**：
  - **高性能**：异步回调，**避免频繁触发** `scroll` 事件。
  - **灵活**：可配置触发交叉的**阈值**（threshold），触发的**范围**和监听的根容器。
  - **自动管理**：**无需手动计算元素位置**。

**对比传统方案**

| **场景**         | **传统方案（scroll + getBoundingClientRect）** | **Intersection Observer**  |
| :--------------- | :--------------------------------------------- | :------------------------- |
| **性能影响**     | 频繁触发强制布局，导致性能抖动                 | 无强制布局，异步批量处理   |
| **代码复杂度**   | 需手动管理监听、防抖、计算逻辑                 | 声明式 API，自动管理       |
| **精确度**       | 依赖手动计算，可能误差                         | 浏览器原生计算，精确到像素 |
| **动态内容支持** | 需手动跟踪新增元素                             | 自动观察新注册元素         |

#### Intersection Observer的底层原理是什么？

Intersection Observer 的底层原理主要依赖于浏览器的渲染与布局机制，通过异步检测目标元素与观察容器（通常是视口）之间的交叉情况来工作。当页面发生滚动、窗口尺寸变化或其他布局更新时，浏览器会重新计算各个目标元素与根容器之间的交叉区域，然后将这些计算结果与预先设定的阈值进行比较。当某个目标元素的交叉比例超过（或低于）阈值时，浏览器就会生成对应的 IntersectionObserverEntry 对象，并异步调用注册的回调函数。

这种机制的好处在于，浏览器可以批量处理多元素的可见性变化，从而避免频繁监听滚动事件带来的性能问题，实现高效、低开销的可见性检测。

### 3、react.memo

**React.memo 的好处**
`React.memo` 是 React 提供的高阶组件（HOC），主要用于优化函数组件的渲染性能。它的核心优势是可以**避免不必要的重新渲染**

当父组件更新时，即使子组件的 `props` 未变化，默认情况下子组件也会重新渲染。使用 `React.memo` 后，子组件会**浅层比较新旧 `props`**，仅当 `props` 变化时才会重新渲染。

如果`props`是一个对象，即使内容一样，但由于每次传过来的都是一个新对象，引用不同，子组件也会重新渲染。解决方法就是给memo添加一个shallowEqual，这样如果引用不同，会再对内部属性方法进行比较，如果相同就不用重新渲染

### 4、虚拟列表+懒加载

在上边

### 5、防抖与节流

在上边



## 6、axios二次封装

#### 为什么要对axios进行二次封装？

对 Axios 的二次封装主要是为了**统一管理网络请求逻辑**，通过拦截器**全局处理错误提示**、**Token 鉴权**、**处理参数格式**等，减少重复代码；同时规范数据响应结构（如自动提取嵌套数据），**简化api（如get，post）调用方式**（如统一设置参数，统一返回 `[err, data]` 格式），并支持扩展缓存、重试等定制功能，最终提升代码复用性、维护性及项目协作效率。

#### 项目中进行了哪些封装？

创建一个axios示例，将基础路由和请求超时时间抽离出来，如果以后要修改方便修改。

**1、对get和post这些api进行了封装**

以get为例，封装了一个新的get函数来获取各项房源数据，里边调用axios.get(url, params)方法，参数是请求路径url和和要查询的查询参数params。在then中处理请求结果，通过res.data获取到数据。获取成功就用resolve返回数据。请求失败通过catch接到，用rejected返回一个error。

post情况也类似，调用axios.post方法，传入请求数据与URL，在then中处理数据并返回，在catch中处理错误并返回

**2、对请求拦截器进行了封装**

在第一个项目中，只是封装了一些公共请求头。在第二个项目中，存在登录功能，所以在请求拦截器中通过getItem获取用户的token ，如果有token就设置到请求头的Authorization。请求拦截器是通过`axios.interceptors.request.use`，对config赋值实现。

**3、对响应拦截器进行了封装**

在第一个项目中，没有登录功能，所以仅通过响应拦截器封装了处理网络请求错误显示的错误信息，如400是'错误的请求'，404是'请求错误,未找到该资源'，500是'服务器端出错'，502是网络错误。并通过message(error)弹出错误信息。在第二个项目中封装了对用户token过期或失效进行处理，当返回结果为401时说明token过期或失效，重新刷新token（通过存储的有更长有效期的refreshToken，将其post到服务器端，正常情况下会返回新token）。如果成功获取新token就使用新token重新请求，如果还是失败就弹出错误信息、清除token并跳转至登录页面。

4、对各个接口进行进一步封装，调用上边的get函数，将请求的url传进去，在外部使用相应数据请求时直接调用即可。



## 7、登录与注册的实现

项目2中登录通过token方式实现。

通过状态变量设置显示登录还是注册

**注册的实现**：首先设计了注册的用户名，密码与重复输入密码的表单。点击注册按钮后先进行前端检查，如果密码符合规则且两次输入密码相同，就触发注册请求，将用户名和密码通过post传进去，返回一个响应，如果成功调用就登录函数，失败就弹出注册失败。

**登录的实现**：

1、首先在设计了登录的用户名和密码表单，点击登录按钮会触发登录请求，将用户名和密码传进去，如果登录成功就把用户名放到redux中存起来，并跳转到首页，失败就弹出登录失败。

2、触发登录请求，会通过post方法将用户名和密码传到服务器，如果成功就获取响应中的token和refreshToken放到localStorage中存起来（通过setItem）,并返回一个true。失败就返回一个false

3、在请求拦截器中，会将token放进请求头Authorization中。在响应拦截器中，会对响应结果进行处理，如果token过期或失效就通过refreshToken重新获取一个新token存起来，通过新token重新进行请求。如果还是失败就弹出错误信息，清除token并跳转至登录页面。

4、首页中设置了登出按钮，点击后就可以触发登出函数，清除token并跳转至登录页面。

5、通过设置一个高阶组件来实现路由守卫，在高阶组件中对token的有效性和是否过期进行验证（通过jwtDecode对token进行解析），如果验证通过就跳转到响应的页面，如果不通过就回到登录页面。通过状态变量来保存用户token，并通过context传递。

### 问题1：都有哪些登录方式，都有什么特点和优势？

#### 一、**Session-Cookie 认证**

#### **原理**

- 服务端生成会话（Session）并存储（如内存、数据库、Redis），客户端通过 Cookie 保存 Session ID。
- **流程**：
  1. 用户提交用户名密码。
  2. 服务端验证后生成 Session 并返回 Session ID。
  3. 客户端通过 Cookie 存储 Session ID。
  4. 后续请求自动携带 Cookie，服务端校验 Session ID。

#### **特点**

- **优点**：
  - 简单易实现，适合传统 Web 应用。
  - 服务端可主动控制会话（如强制退出、实时更新权限）。
- **缺点**：
  - 服务端需存储会话数据，扩展性差（分布式场景需共享 Session）。
  - 依赖 Cookie，跨域场景需额外配置。

#### **适用场景**

- 传统服务端渲染的 Web 应用（如 PHP、Ruby on Rails）。

------

#### 二、**OAuth 2.0 / 第三方登录**

#### **原理**

- 用户通过第三方平台（如微信、Google、GitHub）授权登录。
- **流程**：
  1. 前端跳转至第三方登录页面。
  2. 用户授权后，第三方返回授权码（Code）。
  3. 前端将 Code 传给后端，后端换取用户信息。
  4. 后端生成自有 Token 或 Session 返回前端。

#### **特点**

- **优点**：
  - 用户无需注册新账号，提升转化率。
  - 依赖第三方平台的用户体系，减少密码管理成本。
- **缺点**：
  - 实现复杂，需处理多种第三方协议。
  - 依赖第三方服务稳定性。

#### **适用场景**

- 需要快速接入第三方账号登录的应用（如社交平台、工具类应用）

### 问题2：token方式的优势和缺点是什么？

**三、Token 认证的优势**

| 优势               | 说明                                                        |
| :----------------- | :---------------------------------------------------------- |
| **无状态**         | 服务端无需存储会话信息，适合微服务、分布式架构。            |
| **跨域支持**       | 可轻松实现跨域认证（CORS），适合前后端分离项目。            |
| **多端兼容**       | 适用于 Web、移动端（App）、IoT 设备等多种客户端。           |
| **灵活的权限控制** | Token 可携带用户角色、权限信息，实现细粒度访问控制。        |
| **易于扩展**       | 可通过添加自定义字段（如设备 ID、Token 版本）支持复杂场景。 |

------

**四、Token** **认证的缺点与挑战**

| 缺点               | 解决方案                                                     |
| :----------------- | :----------------------------------------------------------- |
| **Token 泄露风险** | 使用 HTTPS、短期 Token、Refresh Token 轮换、绑定 IP/设备信息。 |
| **无法主动失效**   | 使用 Token 黑名单、短期有效期 + 刷新机制、或改用不透明 Token。 |
| **存储安全性**     | 优先使用 `HttpOnly Cookie`，避免 LocalStorage（防 XSS）。    |
| **Token 膨胀**     | 避免在 Token 中存储过多数据，敏感信息由服务端动态查询。      |

### **问题三**：Token 认证 vs Session-Cookie 认证

| 对比项           | Token 认证                     | Session-Cookie 认证         |
| :--------------- | :----------------------------- | :-------------------------- |
| **状态管理**     | 无状态，适合分布式系统         | 有状态，服务端存储 Session  |
| **跨域支持**     | 天然支持（通过 Header 传递）   | 需配置 CORS 和 Cookie 域    |
| **移动端友好性** | 更友好（无需处理 Cookie）      | 需处理 Cookie               |
| **注销机制**     | 依赖黑名单或短期 Token         | 服务端直接删除 Session 即可 |
| **适用场景**     | 前后端分离、API 优先、多端应用 | 传统服务端渲染 Web 应用     |

### **问题4：前端该用 LocalStorage 还是 Cookie 存 Token？**

- **优点：**
  - 存储容量较大，适合存放较多或较大的数据。
  - 操作简单，通过 JavaScript API 直接读写，不需要每次请求都自动携带，便于在客户端灵活控制。
- **缺点：**
  - 数据完全暴露给前端脚本，无法设置 HttpOnly，容易受到 XSS 攻击。
  - 需要手动将 token 附加到 HTTP 请求头中，增加了实现复杂度。
  - 数据不会自动随请求发送，跨域时需额外处理。

**Cookie 存储 Token**

- **优点：**
  - 浏览器会自动在每个请求中附带 Cookie，便于服务器端识别用户会话。
  - 可以设置 HttpOnly 属性，防止 JavaScript 访问，从而降低 XSS 风险。
  - 配置 SameSite 和 Secure 属性后，可在一定程度上防范 CSRF 等攻击。
- **缺点：**
  - 存储容量有限（通常约 4KB），不适合存放大量数据。
  - 自动随请求发送，可能会带来不必要的流量开销。
  - 如果配置不当（例如未设置 SameSite 或 Secure），依然存在安全隐患。

## 8、style-components

**1、简单介绍**

styled-components 是一种流行的 CSS-in-JS 库，主要用于 React 应用中。它通过使用 ES6 的模板字符串（tagged template literals）让开发者可以在 JavaScript 文件中直接编写 CSS，然后将这些样式与具体的 React 组件绑定，从而达到组件化、模块化的样式管理效果。

**主要特点**

- **样式与组件紧密耦合**：样式定义在组件内，使得样式的作用域自动被限定在组件内，避免了全局样式冲突。
- **动态样式支持**：可以根据组件的 props 或 state 动态生成样式，满足复杂场景的需求。
- **主题支持**：提供 ThemeProvider，可以轻松实现全局主题切换，统一管理应用风格。
- **易于维护**：由于样式和逻辑在同一文件中管理，组件的可读性和可维护性较高。

**优点与适用场景**

- **提高复用性与封装性**：每个组件自带样式，方便复用和迁移。
- **简化开发流程**：不用再维护单独的 CSS 文件，减少样式冲突问题。
- **适用于大型 React 应用**：当应用组件化程度高时，styled-components 能够更好地管理复杂的样式体系。

### 1、通过参数实现动态样式

styled-components 利用 ES6 模板字符串的特性，可以在样式中嵌入 JavaScript 表达式。这样，你就可以根据组件的 props 动态计算出对应的 CSS 属性值。

**实现方式：**

- **插值**
   在模板字符串中使用插值，接收组件的 props 作为参数，然后返回一个 CSS 值，要以一个$开头。
   例如，根据一个 `primary` 属性来设置按钮的背景色，通过props.primary 判断那种样式：

  ```js
  import styled from 'styled-components';
  
  const Button = styled.button`
    background-color: ${props => props.primary ? 'blue' : 'gray'};
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
  `;
  ```

  在使用时，只需给组件传递相应的 props，如这里传primary：

  ```js
  <Button primary>主按钮</Button>
  <Button>普通按钮</Button>
  ```

  ### 2、整体将参数插入样式

  通过ThemeProvider将一个主题对象注入到整个组件树中。所有使用 styled-components 定义的组件都可以通过 `props.theme` 访问到这个主题对象，从而实现全局主题的统一管理和动态切换。

  **定义主题对象**
   首先定义一个包含全局样式变量（如颜色、字体、间距等）的主题对象：

  ```js
  // theme.js
  export const theme = {
    primaryColor: 'blue',
    secondaryColor: 'gray',
    fontSize: '16px',
  };
  ```

  **使用 ThemeProvider 包裹组件树**
   在应用的根组件中使用 `ThemeProvider` 将主题对象传递下去：

  ```js
  import React from 'react';
  import { ThemeProvider } from 'styled-components';
  import { theme } from './theme';
  import App from './App';
  
  const Root = () => (
    <ThemeProvider theme={theme}>
      <App />
    </ThemeProvider>
  );
  
  export default Root;
  ```

  **在 styled-components 中使用主题变量**
   组件中可以通过 `props.theme` 直接访问主题变量：

  ```js
  const Title = styled.h1`
    color: ${props => props.theme.primaryColor};
    font-size: ${props => props.theme.fontSize};
  `;
  ```

### 3、混入 Mixin 功能

**实现方式：**
 styled-components 通过内置的 `css` 辅助函数来实现 mixin。你可以把常用的样式封装成一个可重用的样式块，然后在多个组件中引入。这样可以避免样式代码重复，提高可维护性。

## 9、redux-toolkit

### 什么是 Redux？它的主要特点是什么？

**Redux** 是一个用于管理应用状态的 JavaScript 库，通常与 React 一起使用。它提供了一种集中管理应用状态的方式，使得状态管理更加可预测和可维护。

**主要特点**：

- **单一数据源**：整个应用的状态存储在一个单一的 store 中，确保了状态的一致性。
- **状态不可变**：状态是不可变的，每次状态变化时，都会生成一个新的状态对象。
- **reducer**：通过reducer来处理状态变化，使得状态变化可预测。
- **中间件支持**：支持中间件，可以扩展 Redux 的功能，如异步操作、日志记录等。
- **开发者工具**：提供了强大的开发者工具，可以调试、回溯和重放状态变化。

### **一、为什么需要 Redux Toolkit？**

#### **传统 Redux 的痛点**

1. **繁琐的样板代码**：需手动编写 action types、action creators、reducers。
2. **配置复杂**：需自行集成中间件（如 Thunk、Logger）、DevTools。
3. **不可变更新易错**：手动使用 `...` 或 `Object.assign` 更新状态，容易出错。
4. **异步处理麻烦**：需依赖额外库（如 Redux-Saga、Redux-Observable）。

#### **Redux Toolkit 的优势**

- **简化代码**：内置 `createSlice` 自动生成 action 和 reducer。
- **开箱即用**：预置 `@reduxjs/toolkit` 包含 Immer、Thunk、DevTools。
- **类型安全**：完美支持 TypeScript。
- **高效开发**：减少 80% 的 Redux 代码量。

### **二、核心 API 与功能**

#### **1. `configureStore`：创建 Store**

替代 `createStore`，自动集成 Thunk、DevTools 和中间件。

```js
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './reducers';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
  devTools: process.env.NODE_ENV !== 'production'
});
```

#### **2. `createSlice`：定义 Slice**

自动生成 action types 和 action creators，简化 reducer 编写。

```js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: 0,
  reducers: {
    increment: (state) => state + 1,
    decrement: (state) => state - 1,
    addBy: (state, action) => state + action.payload
  }
});

export const { increment, decrement, addBy } = counterSlice.actions;
export default counterSlice.reducer;
```

#### **3. `createAsyncThunk`：处理异步操作**

简化异步逻辑（如 API 请求），自动生成 pending/fulfilled/rejected 状态。

```js
import { createAsyncThunk } from '@reduxjs/toolkit';
import api from './api';

export const fetchUser = createAsyncThunk(
  'user/fetchUser',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await api.get(`/users/${userId}`);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);
```

#### 4、**集成 React**

使用 `Provider` 包裹应用，并通过 `useSelector`/`useDispatch` 访问状态。

```js
// store.ts
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// App.tsx
import { Provider } from 'react-redux';
import { store } from './app/store';

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}

// Counter.tsx
import { useDispatch, useSelector } from 'react-redux';
import { increment } from './counterSlice';
import type { RootState } from '../app/store';

function Counter() {
  const count = useSelector((state: RootState) => state.counter);
  const dispatch = useDispatch();

  return (
    <button onClick={() => dispatch(increment())}>Count: {count}</button>
  );
}
```

#### **5、`useDispatch`：派发 Action**

**作用**

**获取 Redux Store 的 `dispatch` 函数**，用于触发 Action 以更新 Store 中的状态。

**使用场景**

当组件需要触发状态变更时（如用户点击按钮、提交表单、发起异步请求等）。

**代码示例**

```js
import { useDispatch } from 'react-redux';
import { increment } from './counterSlice'; // 导入 Action Creator

function CounterButton() {
  const dispatch = useDispatch();

  return (
    <button onClick={() => dispatch(increment())}>
      Increment Counter
    </button>
  );
}
```

**关键特性**

1. **直接派发 Action**：
   可以派发同步 Action（如 `dispatch(increment())`）或异步 Action（如 `dispatch(fetchData())`）。
2. **无需手动订阅 Store**：
   React-Redux 自动处理与 Store 的连接。

------

#### **6、`useSelector`：获取 Store 状态**

**作用**

**从 Redux Store 中提取需要的状态值**，并订阅该状态的更新。当状态变化时，组件会自动重新渲染。

**使用场景**

当组件需要读取 Store 中的状态时（如显示计数器值、用户信息等）。

**代码示例**

```js
import { useSelector } from 'react-redux';

function CounterDisplay() {
  const count = useSelector((state) => state.counter.value);

  return <div>Current Count: {count}</div>;
}
```

**关键特性**

1. **选择器函数**：
   接受一个函数 `(state) => selectedValue`，返回需要的状态片段。
2. ****严格相等****：
   默认使用严格相等（`===`）比较前后状态值。**如果返回值是对象或数组，需确保引用稳定**，否则会导致不必要的重新渲染。
3. **性能优化**：
   - **使用记忆化选择器**（如 `createSelector`）避免重复计算。
   - **按需提取状态**：避免返回整个 Store 的根状态。

**`shallowEqual` 的作用**

- **默认行为问题**：
  `useSelector` 默认使用 `===` 比较前后两次选择器返回的值。如果返回的是新对象（如 `{ a: 1, b: 2 }`），即使内容相同，引用不同也会触发重新渲染。
- **`shallowEqual` 的优化**：
  比较对象或数组的第一层属性/元素的值，若所有值相同，则判定为“未变化”，跳过重新渲染。

如果对reducer状态值有计算，可以使用**`createSelector`** 

**createSelector作用**

- **缓存输入和输出**：记录上一次的输入参数和计算结果。
- **参数未变化时直接返回缓存结果**：跳过重复计算。
- **参数变化时重新计算**：更新缓存。

## 10、react的模块化与组件化

React 的 **模块化** 通过拆分代码逻辑（如工具函数、API 服务）实现功能复用和高效维护，而 **组件化** 将界面拆分为独立、可复用的 UI 单元（如按钮、表单），通过状态隔离和组合模式提升开发效率。二者结合形成了高内聚低耦合的架构，优势在于**逻辑复用性高**（如自定义 Hook）、**协作便捷**（并行开发）、**维护性强**（修改独立模块不影响整体），同时支持动态加载优化性能，适用于从简单页面到复杂应用的灵活构建，是 React 高效开发的核心设计理念。

## 11、数据路由

##### 一、核心 API 作用

1. **`createBrowserRouter`**
   创建一个基于 HTML5 History API 的路由实例，支持数据加载、路由嵌套等特性。
   - 参数：路由配置数组（定义路径、组件、数据加载逻辑等）。
   - 返回：路由对象（传递给 `RouterProvider`）。
2. **`RouterProvider`**
   将路由实例注入 React 应用，替代传统的 `<BrowserRouter>` 包裹方式。
   - 参数：`router`（由 `createBrowserRouter` 创建的路由对象）。

##### 二、用法

**定义路由表**

```
// src/routes.js
import { createBrowserRouter } from "react-router-dom";
import Home from "./pages/Home";
import Login from "./pages/Login";
import ErrorPage from "./pages/ErrorPage";

// 定义路由配置
const router = createBrowserRouter([
  {
    path: "/",
    element: <Home />,       // 直接渲染组件
    errorElement: <ErrorPage />, // 全局错误边界
  },
  {
    path: "/login",
    element: <Login />,
    // 可添加数据加载或 Action
    loader: () => fetchUserData(), // 预加载数据
  },
  {
    path: "/user/:userId",
    element: <UserProfile />,
    loader: ({ params }) => fetchUser(params.userId), // 动态参数加载
  },
]);

export default router;
```

 **注入路由到应用**

```
// src/main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import { RouterProvider } from "react-router-dom";
import router from "./routes";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
```

##### 三、高级功能实现

1. **数据加载（Data Loading）**

通过 `loader` 函数预加载路由所需数据：

以下是一个典型的数据加载流程：

1. **用户触发导航**（如点击链接 `/user/123`）。
2. React Router **挂起当前 UI**，显示 `Suspense` 的 `fallback`（若有）。
3. **执行目标路由的 `loader` 函数**，获取数据。
4. **数据加载完成后**，渲染目标路由的组件，并将数据通过 `useLoaderData` 传递给组件。
5. 若 `loader` **加载失败**，渲染 `errorElement` 组件。

在项目中未使用，因为希望从redux中通过createAsyncThunk获取各项数据。

```
// 路由配置
{
  path: "/posts",
  element: <PostsPage />,
  loader: async () => {
    const posts = await fetch("/api/posts").then(res => res.json());
    return posts; // 数据会传递给组件
  },
}

// 组件中获取数据
import { useLoaderData } from "react-router-dom";

function PostsPage() {
  const posts = useLoaderData(); // 直接获取 loader 返回的数据
  return (
    <div>
      {posts.map(post => <div key={post.id}>{post.title}</div>)}
    </div>
  );
}
```

2. **错误边界（Error Boundary）**

通过 `errorElement` 定义错误处理组件：

```
{
  path: "/dashboard",
  element: <Dashboard />,
  errorElement: <ErrorPage />, // 捕获子路由错误
  children: [
    { path: "profile", element: <Profile /> },
    { path: "settings", element: <Settings /> },
  ],
}
```

## 12、echarts实现统计

- 使用 `ReactECharts` 组件包裹 ECharts 实例
- 通过其中的`option` 属性配置相应的统计图

1、对于收入支出数据通过柱状图进行统计。Xaxis属性配置月份，Yaxis属性配置值。series属性对数据进行遍历分别配置pir上收入和支出数据，type是bar。

2、对于分类数据通过饼状图进行统计，series属性中的data配置数据，type为pie

## 13、localStorage

### cookie/sessionStorage/localStorage 的区别

> 参考答案：
>
> cookie、sessionStorage、localStorage 都是保存本地数据的方式
>
> 其中，cookie 兼容性较好，所有浏览器均支持。浏览器针对 cookie 会有一些默认行为，比如当响应头中出现`set-cookie`字段时，浏览器会自动保存 cookie 的值；再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得 cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为，给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然 cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式
>
> HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据，后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据、读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。
> cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M，而 sessionStorage 和 localStorage 则没有限制
> cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与 domain 关联

### 前端该用 LocalStorage 还是 Cookie 存 Token？**

- **优点：**
  - 存储容量较大，适合存放较多或较大的数据。
  - 操作简单，通过 JavaScript API 直接读写，不需要每次请求都自动携带，便于在客户端灵活控制。
- **缺点：**
  - 数据完全暴露给前端脚本，无法设置 HttpOnly，容易受到 XSS 攻击。
  - 需要手动将 token 附加到 HTTP 请求头中，增加了实现复杂度。
  - 数据不会自动随请求发送，跨域时需额外处理。

**Cookie 存储 Token**

- **优点：**
  - 浏览器会自动在每个请求中附带 Cookie，便于服务器端识别用户会话。
  - 可以设置 HttpOnly 属性，防止 JavaScript 访问，从而降低 XSS 风险。
  - 配置 SameSite 和 Secure 属性后，可在一定程度上防范 CSRF 等攻击。
- **缺点：**
  - 存储容量有限（通常约 4KB），不适合存放大量数据。
  - 自动随请求发送，可能会带来不必要的流量开销。
  - 如果配置不当（例如未设置 SameSite 或 Secure），依然存在安全隐患。

## 14、移动端适配

通过媒体查询结合rem与flex的方式，实现了移动端适配。

1、flex布局：用来设置较大的元素布局，如控制一行中显示几列房源item。

2、rem布局：用来设置较小的元素布局，如房源item中的文字大小，边距等。首先给根元素html设置字体大小，其余元素的设置为几倍的rem。rem的优势：每个元素父元素文字大小可能不一致， 但是整个页面只有一个html，这样一来可以很好来控制整个页面的元素大小。

3、通过媒体查询，实现在不同页面改变根元素字体大小，从而改变元素大小。通过min-width，max-width来控制断点。

### 问题1：响应式布局如何实现切换栏数

1、通过flex-wrap，确保元素可切换

2、默认是一行显示五列，简写形式是flex: 1, 0, 20%

其中第一个参数为flex-grow，定义子元素在容器有**剩余空间**时如何分配剩余空间。值为1说明在页面中占一份。flex-grow的值代表全部子元素加起来宽度占到几份。由于20%*5=100，已占满，所以不会再起作用。如果是flex: 1，是flex: 1, 1, 0。初始宽度为0.通过flex-grow等于1所以将剩余空间占满。同时flex-shrink为1所以可以收缩。

第二个参数为flex-shrink定义子元素在容器**空间不足**时如何收缩。值为0，元素禁止收缩。

第三个参数为flex-basis定义子元素在分配剩余空间前的初始大小。值为20%，说明初始大小为20%，20%*5=100，正好占满。

3、当页面宽度逐渐减小时，通过max-width设置范围，当减小到程度flex-basis就换位25%变成4列，并以此类推变为三列两列一列。

### 问题2：都有哪些响应式布局方案，优缺点都是什么

| **布局方法**       | **优点**                                                     | **缺点**                                                     |
| :----------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Flexbox**        | 1. 灵活的对齐和空间分配 2. 一维布局简单直观 3. 代码简洁，支持响应式 | 1. 二维复杂布局能力有限 2. 旧版浏览器（如 IE10-）需前缀      |
| **CSS Grid**       | 1. 强大的二维布局能力 2. 简化复杂网格结构 3. 支持现代浏览器无缝响应 | 1. 旧版浏览器兼容性差（如 IE11 部分支持） 2. 学习曲线较陡    |
| **流式布局**       | 1. 基于百分比自适应屏幕 2. 实现简单，无需复杂计算            | 1. 内容可能拉伸失真 2. 嵌套元素百分比计算复杂                |
| **Rem 布局**       | 1. 基于根字体大小适配多屏 2. 结合媒体查询实现精细控制        | 1. 需工具转换像素单位（如 PostCSS） 2. 动态调整根字体可能影响性能 |
| **Viewport 单位**  | 1. 直接基于视口尺寸（vw/vh） 2. 天然响应式，减少媒体查询使用 | 1. 部分浏览器支持不全（如 vmin/vmax） 2. 小屏幕内容可能过小  |
| **Bootstrap 栅格** | 1. 快速搭建响应式布局 2. 预设断点，社区支持完善 3. 跨浏览器一致性 | 1. 冗余代码增加体积 2. 定制性受限 3. 依赖框架更新            |
| **媒体查询**       | 1. 精准控制不同断点样式 2. 高度定制化，适配任意设备          | 1. 维护多断点时代码臃肿 2. 无法覆盖所有设备尺寸              |
| **混合布局**       | 1. 结合多种方法优势（如 Grid + Flex） 2. 灵活应对复杂场景    | 1. 代码复杂度高 2. 需开发者深入理解各方法特性                |

### 问题3：使用rem与flex布局的好处是什么

rem：普通em是根据父元素规定的字体大小确定的，对于不同的元素父元素可能不同，设置的字体大小可能也不同，也就会导致em设置较混乱。而rem只根据根元素html设置，所以各个子元素中的rem都按照同一套标准设置，较为统一，更改时也只需要更改html中的字体大小即可，方便控制。

flex: 空间分配很灵活方便，很多时候只需要配置一个flex: 1即可。构建自适应布局也很简单，如两栏布局，一栏设置固定宽度，另一栏直接设置flex: 1就可以占满剩余部分。

## 15、如何实现点击链接跳转

1、酒店中的每种房源都几个a链接来代表对应的平台

2、以携程为例，所有酒店的详情页面的协议，域名，路由hotel/detail都是相同的，只有查询参数不同。查询参数是hotelId和adult，从后端获取到相应的参数后，通过模板字符串放到href的链接中，就可以实现链接跳转。
